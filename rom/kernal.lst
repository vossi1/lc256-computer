
; ******** Source: lc256.b
     1                          ; LC256 ROM
     2                          ; for ACME assembling by Vossi 09/2024, last update 10/2024
     3                          ; v1.0 initial
     4                          ; v1.1 added yjk mode
     5                          !cpu 65c02
     6                          !ct pet		; Standard text/char conversion table -> pet = petscii
     7                          !to "kernal.bin", plain
     8                          ; * switches
     9                          FILL	= $ff	; Fills free memory areas
    10                          PI	= $99
    11                          HZ = 64		; System interrupt frequency, at 4MHz clock is minimum 62 because of 16 bit timer!
    12                          		;   if other then 64 the 1/8 seconds for TI$ are not correct!
    13                          V10PCB = 0	; select first PCB v.1.0: only 2x2 bit RAM banks (max. 128kB chips)
    14                          V11PCB128K = 0	; select PCB v.1.1 with 128kB RAM1 chip
    15                          NMI555 = 0	; enable for 555 Restore-key NMI, disable for VIA2 CA1 NMI
    16                          JIFFY = 1	; enable Jiffy-DOS 6.01 (Works at 1, 2, 3 or 4 MHz clock)
    17                          DISDEF	= 23	;bytes to disassemble by default
    18                          
    19                          NORAM1 = 0	; Test option without RAM1: screen+color RAM in RAM0 range
    20                          ; shared VDP sources

; ******** Source: lc256_vdpeq.b
     1                          ; * switches
     2                          CLOCK = 4		; CPU clock in MHz for VDP waits
     3                          ; vdp
     4                          MODE = 7		; 6 = graphics 6: 512px/16colors / 7 = graphics 7: 256px/256colors
     5                          PAL = 0			; PAL=1 / NTSC=0 selects V9938/58 PAL RGB-output, NTSC has a higher picture
     6                          LINES = 212		; lines = 192 / 212
     7                          ; VDP speed parameter - don't change!
     8                          WAIT12 = 1 ; 2		; us 1. - 2. byte VDP
     9                          WAIT23 = 2 ; 5		; us 2. - 3. byte VDP
    10                          WAITVRAM1 = 5		; us vram 1.access
    11                          WAITVRAM = 5		; us vram loop 
    12                          ;
    13                          !if MODE=6{
    14                          TITLECOL		= 1	; Title message color
    15                          TITLE2COL		= 10	; Title message line 2 color
    16                          BYTESCOL		= 6	; Title bytes color
    17                          TEXTCOL			= 3	; Default text color:   0=black, 1=white, 10=lightred, 6=blue, 3=cyan
    18                          BGRCOL			= 0	; background color
    19                          EXTCOL			= 0	; exterior color
    20                          }else {
    21                          TITLECOL		= $ff	; Title message color
    22                          TITLE2COL		= $3e	; Title message line 2 color
    23                          BYTESCOL		= $43	; Title bytes color
    24                          TEXTCOL			= $e7	; Default text color: $00=black, $ff=white, $3e=pink, $22=darkblue, $43=blue, $e7=cyan
    25                          BGRCOL			= $00	; background color
    26                          EXTCOL			= $00	; exterior color
    27                          }
    28                          VDPREG0			= $0a	; VDP reg 0 base value mode 6/7
    29                          VDPREG1			= $02	; VDP reg 1 value mode 6+7 (mode M1+M2, screen disabled, sprites 16x16)
    30                          VDPREG18		= $0d	; VDP reg 18 value (V/H screen adjust, $0d = Sony PVM 9")
    31                          !if LINES=192 {VDPREG9	= $00	; VDP reg 9 value (bit #7 = 192 / 212 lines, bit#1 = NTSC / PAL)
    32                          	}else {VDPREG9	= $80}
    33                          SIZEX6			= 512		; x size mode6
    34                          SIZEX7			= 256		; x size mode7
    35                          SIZEY			= LINES		; y size
    36                          COLORS6			= 16		; mode6 colors
    37                          SPRITES			= 32		; number of sprites
    38                          SPRX			= 16		; sprite x size 
    39                          SPRY			= 16		; sprite y size
    40                          PATTERNS		= 64		; sprite patterns, color patterns
    41                          FONTH			= 8		; userfont height
    42                          FONTW			= 6		; userfont width
    43                          !if LINES=192 {nrows	= 24		; screen rows
    44                          	}else {nrows	= 25}
    45                          COLUMNS7		= 40		; screen columns mode 7
    46                          COLUMNS6		= 80		; screen columns mode 6
    47                          ; vdp commands
    48                          HMMV			= $c0		; highspeed fill
    49                          HMMM			= $d0		; highspeed VRAM copy
    50                          YMMM			= $e0		; highspeed VRAM y copy
    51                          LINE			= $70		; line
    52                          ; ***************************************** ZEROPAGE **********************************************
    53                          ; kernal zero page / equates (outsourced)
    54                          !addr	ddisk		= $b7		; Default disk unit # for monitor/basic
    55                          !addr	color		= $cf		; Character color
    56                          !addr	sedsal		= $c1 ; 2by	; Scroll ptr
    57                          !addr	sedeal		= $c3 ; 2by	; Scroll ptr
    58                          	mxbank	=15+1			; 1st RAM bank out of range
    59                          ;
    60                          ; VDP zero page
    61                          *= $ea
    62                          !addr	mode		*=*+1		; graphics mode: bit#7=1: 7, bit#7=0: 6 (512px/16 colors)
    63                          !addr	lastvbank	*=*+1		; last vram bank
    64                          !addr	columns		*=*+1		; screen columns
    65                          !addr	scxmax		*=*+1		; Max column number
    66                          !addr	bgcolor		*=*+1		; background color
    67                          !addr	bgcolor_left	*=*+1		; background color for left pixel
    68                          !addr	temp1		*=*+1		; temp	
    69                          !addr	temp2		*=*+1		; temp
    70                          !addr	y0		*=*+1		; 8bit y
    71                          !addr	y1		*=*+1		; 8bit y1 (target)
    72                          !addr	cy				; cy (only in circle)
    73                          !addr	temp3		*=*+1		; temp
    74                          !addr	dy				; 8bit dy
    75                          !addr	temp4		*=*+1		; temp for circle, print, spritedata
    76                          ; $f6 16bit
    77                          !addr	zero				; zero value for command macro parameter (lo of sizex = 0)
    78                          !addr	sizex		*=*+2		; 16bit screen size
    79                          !addr	x0		*=*+2		; 16bit x
    80                          !addr	x1		*=*+2		; 16bit x1 (target)
    81                          !addr	tx				; 16bit tx (only in circle)
    82                          !addr	dx		*=*+2		; 16bit dx
    83                          !addr	sprite_colors 	*=*+2		; pointer to $7e00 64x 8by with 16 spriteline color nibbles
    84                          ; sedsal, sedeal only used in function keys, scroll routines
    85                          !addr	source_pointer	= sedsal	; pointer to source
    86                          !addr	pointer1	= sedeal	; pointer
    87                          ; ***************************************** ABSOLUTE **********************************************
    88                          ; VDP sprites
    89                          !addr	sprite_flags	= $0361 ; 32by	; 32x sprite flags EC, CC, IC
    90                          ; VDP absolute
    91                          !addr	bgcolor_del	= $038b		; double background color for vdp commands
    92                          !addr	arg		= $038c		; command arg
    93                          !addr	userfont_adr	= $038d	; 2by	; userfont address
    94                          !addr	wtemp		= $038f	; 2by	; 16bit temp
    95                          ; **************************************** ADDRESSES **********************************************
    96                          ; I/O addresses
    97                          VDPWriteAdr	= $dc00		; Port#0 RamWrite, #1 Control, #2 Palette, #3 Indirect
    98                          VDPReadAdr	= $dc80		; Port#0 RamRead, #1 Status
    99                          ; sprite_colors 200 bytes at $7e00 - $7fff 	64x 8 bytes with 16 spriteline color nibbles
   100                          ; VDP ports
   101                          !addr	VDPRamWrite	= VDPWriteAdr
   102                          !addr	VDPControl	= VDPWriteAdr+1
   103                          !addr	VDPPalette	= VDPWriteAdr+2
   104                          !addr	VDPIndirect	= VDPWriteAdr+3
   105                          !addr	VDPRamRead	= VDPReadAdr
   106                          !addr	VDPStatus	= VDPReadAdr+1
   107                          SpritePatternTable	= $f000
   108                          SpriteAttributeTable	= $fa00
   109                          SpriteColorTable	= SpriteAttributeTable - $200	; always $200 below sprite attribute table
   110                          

; ******** Source: lc256.b
    21                          

; ******** Source: lc256_vdpmacro.b
     1                          ; ******************************************* MACROS **********************************************
     2                          ; VDP macros
     3                          !macro VdpWait .u, .c{		; *** us wait - cycles already present - for VDP access
     4                          	!set .t = (.u*10-(.c*10/CLOCK))*CLOCK/20
     5                          	!do while .t > 0{
     6                          		nop			; each nop needs 2 cycles
     7                          		!set .t = .t -1}
     8                          }
     9                          !macro VdpSetReg .r{		; *** set VDP Register
    10                          	sta VDPControl			; first writes data in A to control port #1
    11                          	lda #.r | $80			; writes register no. with bit#7 = 1 to Port #1
    12                          	+VdpWait WAIT12,5-1
    13                          	sta VDPControl
    14                          }
    15                          !macro VdpWriteAddress{		; *** set VDP write vram address-pointer to AAXX
    16                          	stx VDPControl
    17                          	ora #$40			; bit#6 = 1 write
    18                          	+VdpWait WAIT12,5-1
    19                          	sta VDPControl
    20                          } 
    21                          			; *** execute VDP Command
    22                          !macro VdpCommand .sx, .sxhi, .sy, .dx, .dxhi, .dy, .nx, .nxhi, .ny, .clr, .arg, .cmr{
    23                          	lda #32				; first command register
    24                          	+VdpSetReg 17			; set register indirect
    25                          ; 32
    26                          	lda .sx
    27                          	+VdpWait WAIT23,6		; wait for DVP
    28                          	sta VDPIndirect
    29                          	lda .sxhi
    30                          	+VdpWait WAIT23,5-1
    31                          	sta VDPIndirect
    32                          	lda .sy
    33                          	+VdpWait WAIT23,6
    34                          	sta VDPIndirect
    35                          	lda #$00
    36                          	+VdpWait WAIT23,5-1
    37                          	sta VDPIndirect
    38                          ; 36
    39                          	lda .dx
    40                          	+VdpWait WAIT23,6
    41                          	sta VDPIndirect
    42                          	lda .dxhi
    43                          	+VdpWait WAIT23,5-1
    44                          	sta VDPIndirect
    45                          	lda .dy
    46                          	+VdpWait WAIT23,6
    47                          	sta VDPIndirect
    48                          	lda #$00
    49                          	+VdpWait WAIT23,5-1
    50                          	sta VDPIndirect
    51                          ; 40
    52                          	lda .nx
    53                          	+VdpWait WAIT23,6
    54                          	sta VDPIndirect
    55                          	lda .nxhi
    56                          	+VdpWait WAIT23,6
    57                          	sta VDPIndirect
    58                          	lda .ny
    59                          	+VdpWait WAIT23,6
    60                          	sta VDPIndirect
    61                          	lda #$00
    62                          	+VdpWait WAIT23,5-1
    63                          	sta VDPIndirect
    64                          ; 44
    65                          	lda .clr
    66                          	+VdpWait WAIT23,6
    67                          	sta VDPIndirect
    68                          	lda .arg
    69                          	+VdpWait WAIT23,6
    70                          	sta VDPIndirect
    71                          	lda #.cmr
    72                          	+VdpWait WAIT23,5-1
    73                          	sta VDPIndirect
    74                          }
    75                          !macro VdpSpriteBank{		; *** Switch to bank $C000-$FFFF for fast sprite access
    76                          	bit lastvbank			; bit#6 -> V, bit#7 -> N
    77                          	bpl .j
    78                          	bvs .k
    79                          .j	lda #SpritePatternTable>>14	; A14+15 = VDP bank
    80                          	+VdpSetReg 14			; writes VRAM bank
    81                          	lda #>SpritePatternTable&$c0	; isolate A14+15
    82                          	sta lastvbank

; ******** Source: lc256.b
    22                          
    23                          ; ########################################### INFO ################################################
    24                          ; loop3 = Main loop - wait for key input
    25                          ; Disable scrolling with control '-' ($82), enable '+' ($02)
    26                          ;
    27                          ; current memory map:
    28                          ;		$0000-$03ff  RAM (kernal/basic system)
    29                          ;		$0400-$7fff  RAM (banks 0-15)
    30                          ;		-$7d00-$7dff programmable keys
    31                          ;		-$7e00-$7fff Sprite colors
    32                          ;               $8000-$bfff  ROM (language)
    33                          ;		$c000-$c7ff  ROM (kernal/basic)
    34                          ;		$c800-$cfff  ROM Character
    35                          ;		$d000-$d7ff  kernal screen shadow ram
    36                          ;		$d800-$dbff  kernal color shadow ram
    37                          ;               $dc00-$dcff  i/o  VDP
    38                          ;               $dd00-$dd7f  i/o  USB
    39                          ;               $dd80-$ddff  i/o  unused
    40                          ;		$de00-$de3f  i/o  6522 VIA1
    41                          ;               $de40-$de7f  i/o  6522 VIA2
    42                          ;               $de80-$debf  i/o  OPL3
    43                          ;               $dec0-$deff  i/o  Audio DAC
    44                          ;               $df00-$df3f  i/o  IO3
    45                          ;               $df40-$df7f  i/o  IO4
    46                          ;               $df80-$dfbf  i/o  IO5
    47                          ;               $dfc0-$dfff  i/o  IO6
    48                          ;		$e000-$ffff  ROM  kernal
    49                          ; ***************************************** ZEROPAGE **********************************************
    50                          ; $02-$8f BASIC zeropage
    51                          ; $6f-$78 monitor buffer in Basic fac
    52                          !addr	hulp		= $6f ; 10by	; Monitor: assembler buffer
    53                          !addr	txtptr		= $83 ; 2by	; BASIC pointer to current term
    54                          ; Kernal page zero variables
    55                          ; Kernal indirect address variables
    56                          !addr	tick		= $01		; 1/64 time
    57                          !addr	fnadr		= $90 ; 2by	; Address of file name string
    58                          !addr	sal		= $92		; Current load/store address
    59                          !addr	sah		= $93		;   low, high
    60                          !addr	eal		= $94		; End of load/save
    61                          !addr	eah		= $95
    62                          !addr	stal		= $96		; Start of load/save
    63                          !addr	stah		= $97
    64                          ; Frequently used kernal variables
    65                          !addr	time		= $98 ; 3by	; 24 hour clock in 1/64th seconds
    66                          !addr	status		= $9b		; I/O operation status
    67                          !addr	fnlen		= $9c		; File name length
    68                          !addr	la		= $9d		; Current logical index
    69                          !addr	fa		= $9e		; Current first address
    70                          !addr	sa		= $9f		; Current secondary address
    71                          !addr	dfltn		= $a0		; Default input device
    72                          !addr	dflto		= $a1		; Default output device
    73                          ; Variables for kernal speed
    74                          !addr	stkey		= $a2		; Stop key flag
    75                          ; IEC / jiffydos / Monitor
    76                          !addr	c3p0		= $a3		; IEC buffer flag
    77                          !addr	wrap		= $a3		; Monitor: assembler temp
    78                          !addr	r2d2		= $a4		; IEC serial bus usage eoi / jiffy device
    79                          !addr	lastchr		= $a4		; Monitor: last basin char 
    80                          !addr	bsour		= $a5		; IEC character buffer 
    81                          !addr	bsour1		= $a5		; IEC character input
    82                          !addr	sxreg		= $a5		; Monitor: temp xreg, div
    83                          !addr	count		= $a6		; IEC bit counter / Monitor: assembler
    84                          !if JIFFY = 1{
    85                          !addr	jdtemp		= $a6		; JIFFY DOS temp (only used in jdload)
    86                          }
    87                          ; Monitor virtual registers - Place in these locations temporarly...
    88                          !addr	pch		= $a7		; counter
    89                          !addr	pcl		= $a8
    90                          !addr	flgs		= $a9		; Processor status
    91                          !addr	acc		= $aa		; Accumulator
    92                          !addr	xr		= $ab		; X register
    93                          !addr	yr		= $ac		; Y register
    94                          !addr	sp		= $ad		; Stack pointer
    95                          !addr	invh		= $ae		; User interrupt vector
    96                          !addr	invl		= $af
    97                          ; Monitor indirect variables
    98                          !addr	tmp0		= $b0 ; 2by	; Temp pointer
    99                          !addr	tmp1		= $b2 ; 2by	; Temp pointer
   100                          !addr	tmp2		= $b4 ; 2by	; Temp pointer
   101                          ; Other monitor variables
   102                          !addr	tmpc		= $b6		; Place to save last cmd
   103                          ; *** defined in shared lc256_vdpeq.b
   104                          ;!addr	ddisk		= $b7		; Default disk unit # for monitor/basic
   105                          ; Monitor Assembler variables
   106                          !addr	msal		= $b8 ; 3by	; Monitor: assembler
   107                          !addr	format		= $bb		; Monitor: assembler
   108                          !addr	length		= $bc		; Monitor: assembler 
   109                          ; Screen editor page zero variables
   110                          ; Editor indirect variables
   111                          !addr	pkybuf		= $bd ; 2by	; Start adr of pgm key
   112                          !addr	keypnt		= $bf ; 2by	; Current pgm key buf
   113                          ; *** defined in shared lc256_vdpeq.b
   114                          ;!addr	sedsal		= $c1 ; 2by	; Scroll ptr / pgmkey ptr
   115                          ;!addr	sedeal		= $c3 ; 2by	; Scroll ptr / pgmkey ptr
   116                          !addr	pnt		= $c5 ; 2by	; Current character pointer
   117                          ; Screen editor usage
   118                          !addr	bitabl		= $c7 ; 4by	; Wrap bitmap
   119                          !addr	user		= $cb ; 2by	; Pointer to color RAM
   120                          !addr	tcolor		= $cd		; Temporary color
   121                          !addr	crssw		= $ce		; Cursor visibility switch
   122                          ; *** defined in shared lc256_vdpeq.b
   123                          ;!addr	color		= $cf		; Character color
   124                          !addr	gdcol		= $d0		; Color behind cursor
   125                          ; Editor variables for speed & size
   126                          !addr	tblx		= $d1		; Cursor line
   127                          !addr	pntr		= $d2		; Cursor column
   128                          !addr	rptflg		= $d3		; Repeat flag
   129                          !addr	lstx		= $d4		; Last character index
   130                          !addr	lstp		= $d5		; Screen editor start position
   131                          !addr	lsxp		= $d6		; Screen editor start row
   132                          !addr	crsw		= $d7		; cr flag - cr pressed -> input from screen
   133                          !addr	ndx		= $d8		; Index to keyd queue
   134                          !addr	qtsw		= $d9		; Quote mode flag
   135                          !addr	insrt		= $da		; Insert mode flag
   136                          !addr	config		= $db		; Char before blink (petii)
   137                          !addr	indx		= $dc		; Last byte position on line (##234-02##244-02)
   138                          !addr	kyndx		= $dd		; Count of program key string
   139                          !addr	kount		= $de		; Delay between key repeats
   140                          !addr	delay		= $df		; Initial key repeat delay
   141                          !addr	sedt1		= $e0		; Frequently used temp variables
   142                          !addr	sedt2		= $e1
   143                          ; Frequently used editor variables
   144                          !addr	data		= $e2		; Current print data
   145                          !addr	crson		= $e3		; Cursor on = 0
   146                          !addr	keytab		= $e4 ; 2by	; Keyscan table indirect
   147                          !addr	lstshf		= $e6		; Last shift pattern
   148                          !addr	shflag		= $e7		; Keyscanner shift/control flags ($ff-nokey)
   149                          !addr	sfdx		= $e8		; Keyscanner normal key number ($ff-nokey)
   150                          !addr	saver		= $e9		; Temp store for output char
   151                          ; $ea - $ff VDP zero page
   152                          ; *** defined in shared lc256_vdpeq.b
   153                          ; ***************************************** ABSOLUTE **********************************************
   154                          ; System stack area
   155                          !addr	stack		= $0100		; Stack
   156                          !addr	stackp		= $01ff		; System Stack pointer transx code
   157                          ; -------------------------------------------------------------------------------------------------
   158                          ; $200 - $256 Basic's ROM page work area
   159                          !addr	buf		= $0200		; Basic input buffer
   160                          ; Basic RAM vectors
   161                          !addr	ierror		= $0280         ; Basic error indirect
   162                          ; -------------------------------------------------------------------------------------------------
   163                          ; System RAM vectors
   164                          !addr	cinv		= $0300		; IRQ vector
   165                          !addr	cbinv		= $0302		; BRK vector
   166                          !addr	nminv		= $0304		; NMI vector
   167                          !addr	iopen		= $0306		; Open file vector
   168                          !addr	iclose		= $0308		; Close file vector
   169                          !addr	ichkin		= $030a		; Open channel in vector
   170                          !addr	ickout		= $030c		; Open channel out vector
   171                          !addr	iclrch		= $030e		; Close channel vector
   172                          !addr	ibasin		= $0310		; Input from channel vector 
   173                          !addr	ibsout		= $0312		; Output to channel vector
   174                          !addr	istop		= $0314		; Check stop key vector
   175                          !addr	igetin		= $0316		; Get from queue vector
   176                          !addr	iclall		= $0318		; Close all files vector
   177                          !addr	iload		= $031a		; Load from file vector
   178                          !addr	isave		= $031c		; Save to file vector
   179                          !addr	usrcmd		= $031e		; Monitor extension vector
   180                          !addr	escvec		= $0320		; User ESC key vector
   181                          !addr	ctlvec		= $0322		; unused control key vector
   182                          !addr	isecnd		= $0324		; IEC listen secondary address
   183                          !addr	itksa		= $0326		; IEC talk secondary address
   184                          !addr	iacptr		= $0328		; IEC character in routine
   185                          !addr	iciout		= $032a		; IEC character out routine
   186                          !addr	iuntlk		= $032c		; IEC bus untalk
   187                          !addr	iunlsn		= $032e		; IEC bus unlisten
   188                          !addr	ilistn		= $0330		; IEC listen device primary address
   189                          !addr	italk		= $0332		; IEC talk device primary address
   190                          ; Kernal absolute variables
   191                          !addr	lat		= $0334 ; 10by	; Logical file numbers / table
   192                          !addr	fat		= $033e ; 10by	; Device numbers / table
   193                          !addr	sat		= $0348 ; 10by	; Secondary addresses / table
   194                          ;
   195                          !addr	lowadr		= $0352 ; 2by	; Start of system memory: low, high
   196                          !addr	hiadr		= $0354 ; 2by	; Top of system memory: low, high
   197                          !addr	memstr		= $0356 ; 2by	; Start of user memory: low, high
   198                          !addr	memsiz		= $0358 ; 2by	; Top of user memory: low, high
   199                          !addr	timout		= $035a		; IEC timeout enable
   200                          !addr	verck		= $035b		; load/verify flag
   201                          !addr	ldtnd		= $035c		; Device table index
   202                          !addr	msgflg		= $035d		; Message flag
   203                          !addr	relsal		= $035e		; moveable start load address
   204                          !addr	relsah		= $035f		; 
   205                          !addr	relsab		= $0360		;   bank
   206                          ; *** defined in shared lc256_vdpeq.b
   207                          ; $0361-$0380 VDP sprites
   208                          !addr	xcnt		= $0361 ; 32by	; Monitor: 32 bytes compare buffer
   209                          ; Screen editor absolute
   210                          !addr	pkyend		= $0381 ; 2by	; Program key buffer end address
   211                          !addr	keysiz		= $0383 ; 8by	; Sizes of function key texts 8 bytes
   212                          ; *** defined in shared lc256_vdpeq.b
   213                          ; $038b-$0390 VDP absolute
   214                          ; Kernal temporary (local) variables
   215                          !addr	t1		= $0391
   216                          !addr	t2		= $0392
   217                          !addr	xsav		= $0393
   218                          !addr	savx		= $0394
   219                          !addr	svxt		= $0395
   220                          !addr	temp		= $0396		; allround temp - not used by kernal
   221                          ; Screen editor absolute
   222                          !addr	rvs		= $0397		; Reverse mode flag
   223                          !addr	lintmp		= $0398		; Line # between in and out 
   224                          !addr	lstchr		= $0399		; Last char printed
   225                          !addr	insflg		= $039a		; Insert mode flag
   226                          !addr	scrdis		= $039b		; Scroll disable flag
   227                          !addr	bitmsk		= $039c		; Temorary bitmask
   228                          !addr	fktmp		= $039c		;   also used for function key temporary
   229                          !addr	keyidx		= $039d		; Index to programmables
   230                          !addr	pagsav		= $039e		; Temp RAM page
   231                          !addr	keyd		= $039f ; 10by	; Keyboard buffer 10 bytes
   232                          !addr	funvec		= $03a8 ; 2by	; Vector: funktion key handler
   233                          *= $03aa
   234                          !addr	ldtb1		*=*+25	; 50by	; screen lines hi byte table
   235                          !addr	ldtb2				; screen lines lo byte table
   236                          ; $03dc - $03f7 free
   237                          ; System warm start variables and vectors
   238                          !addr	evect		= $03f8 ; 5by	; Warm start vector and flags
   239                          ; ***************************************** EQUATES ***********************************************
   240                          ; Equates
   241                          	warm	= $a5		; Warm start flag
   242                          	winit	= $5a		; Initialization complete flag
   243                          	collen	= 40		; color ram line length
   244                          	scymax	= nrows-1	; Max line number
   245                          	keymax	= 9		; Keyboard buffer size - 1
   246                          	pgmkys	= 8		; Number of progam keys
   247                          	cr	= $d		; Carriage return
   248                          	sperr	= $10		; verify error
   249                          ; *** defined in shared lc256_vdpeq.b
   250                          ;	mxbank	=15+1		; 1st RAM bank out of range
   251                          ; **************************************** ADDRESSES **********************************************
   252                          ; ROM / RAM addresses
   253                          !addr	zp	= $00		; zeropage start
   254                          !addr	basic	= $8000		; Start of ROM (language)
   255                          !addr	font6x8	= $c800		; c64 font 6x8
   256                          !if NORAM1 = 1{			; Test option without RAM1: screen+color RAM in RAM0 range
   257                          !addr	scnram	= $7000		; kernal Video shadow RAM
   258                          !addr	clrram	= $7800		; kernal Color shadow RAM
   259                          } else{
   260                          !addr	scnram	= $d000		; kernal Video shadow RAM
   261                          !addr	clrram	= $d800		; kernal Color shadow RAM
   262                          }
   263                          !addr	kernal	= $e000		; Start of ROM (kernal)
   264                          ; USB
   265                          !addr	usb	= $dd00		; FTDI USB chip
   266                          ; OPL3 ports
   267                          !addr 	OPL3Adr	= $de80		; Port#0 Reg, #1 Data, #2 Reg high
   268                          !addr	oplreg	= OPL3Adr
   269                          !addr	opldata	= OPL3Adr+1
   270                          !addr	oplregh	= OPL3Adr+2
   271                          ; Audio DAC
   272                          !addr	dac	= $dec0	; write only
   273                          
   274                          ; 6522 VIA1 - keyboard, control ports
   275                          !addr	via1	= $de00
   276                          	; pra: kybd col out 0-7, joystick 2
   277                          	; prb: kybd row in 0-7 (inputs), joystick 1
   278                          
   279                          ; 6522 VIA2 - MMU, IEC, USB RXF/TXE, Restore
   280                          !addr	via2	= $de40
   281                          	; ca1: restore-key in
   282                          	; ca2: MMU ROML
   283                          	; cb2: MMU ROMH
   284                          	; pa0: USB #rxf
   285                          	; pa1: USB #txe
   286                          	; pa2:
   287                          	; pa3: IEC atn out
   288                          	; pa4: IEC clk out
   289                          	; pa5: IEC data out
   290                          	; pa6: IEC clk in
   291                          	; pa7: IEC data in
   292                          	; pb0: RAM0 bank bit #0 
   293                          	; pb1: RAM0 bank bit #1 
   294                          	; pb2: RAM0 bank bit #2 
   295                          	; pb3: RAM0 bank bit #3
   296                          	; pb4: RAM1 bank bit #0 
   297                          	; pb5: RAM1 bank bit #1 
   298                          	; pb6: RAM1 bank bit #2 
   299                          	; pb7: RAM1 bank bit #3
   300                          
   301                          ; VIA register
   302                          	prb	= $0	; Port reg b
   303                          	prah	= $1	; Port reg a (with handshaking)
   304                          	ddrb	= $2	; Direction reg b
   305                          	ddra	= $3	; Direction reg a
   306                          	t1lo	= $4	; Timer 1 low  byte
   307                          	t1hi	= $5	; Timer 1 high byte
   308                          	t1ldlo	= $6	; Timer 1 low  byte to load
   309                          	t1ldhi	= $7	; Timer 1 high byte to load
   310                          	t2lo	= $8	; Timer 2 low  byte
   311                          	t2hi	= $9	; Timer 2 high byte
   312                          	sr	= $a	; shift register
   313                          	acr	= $b	; auxilary control register
   314                          	pcr	= $c	; peripheral control register
   315                          	ifr	= $d	; Interrupt flags register
   316                          	ier	= $e	; Interrupt enable register
   317                          	pra	= $f	; Port reg a
   318                          ; ******************************************* MACROS **********************************************
   319                          ; IEC macro
   320                          !macro IECDelay .c{		; *** insert .c nops's
   321                          	!do while .c > 0{
   322                          		nop
   323                          		!set .c = .c -1}
   324                          }
   325                          ; ***************************************** ZONE VDP **********************************************
   326                          !initmem FILL			; All unused memory filled with $ff
   327                          !zone vdp
   328                          *= $c000
   329  c000 2408185c00000000...!binary "lc256_logo.rgb"
   330                          ; ************************************* MONITOR EXTENSION *****************************************
   331                          ; monitor extension
   332                          !zone monext
   333                          ;  simple assembler
   334                          ;  syntax: a 1111 lda ($00,x)
   335                          ; 	   a 1111 dex:		(':' = terminator)
   336  c122 20e8c5             assem:	jsr parse		; read adr
   337  c125 b032               	bcs aserr		; ...branch if missing sa
   338  c127 20d8f2             	jsr t2t2		; save sa
   339                          
   340  c12a a200               asspc:	ldx #0
   341  c12c 8670               	stx hulp+1		; clear left mnemonic
   342  c12e 86a6               	stx count		; clear operand
   343                          
   344  c130 205bf3             asnxchr:jsr gnc			; get a char
   345  c133 d005               	bne aspars		; check for eol
   346  c135 e000               	cpx #0
   347  c137 d001               	bne aspars
   348  c139 60                 	rts			; if eol & no mnemonic, exit cleanly
   349                          
   350  c13a c920               aspars:	cmp #' '		; is it a space ?
   351  c13c f0ec               	beq asspc		; yes - start again (passes over object code, if any)
   352  c13e 95b8               	sta msal,x		; no - save char
   353  c140 e8                 	inx
   354  c141 e003               	cpx #3	  		; got three chars ?
   355  c143 d0eb               	bne asnxchr		; no - loop
   356                          ; 3 char mnemonic in msal -> crunch to two bytes in hulp, hulp+1
   357  c145 ca                 asnxmch:dex			; squished all three ? (3x5bits in hulp,hulp+1 bit#15-1)
   358  c146 3014               	bmi asstart		; yes
   359  c148 b5b8               	lda msal,x		; no - first in last out
   360  c14a 38                 	sec	     		; no borrow
   361  c14b e93f               	sbc #$3f		; normalize
   362  c14d a005               	ldy #5	  		; set for 5 shift rights
   363                          
   364  c14f 4a                 ashftmn:lsr
   365  c150 6670               	ror hulp+1		; left mnemonic
   366  c152 666f               	ror hulp		; right mnemonic
   367  c154 88                 	dey	     		; done 5 shifts?
   368  c155 d0f8               	bne ashftmn		; no-loop
   369  c157 f0ec               	beq asnxmch		; always
   370                          
   371  c159 4c59ef             aserr:	jmp erropr		; syntax error jump
   372                          ; assemble
   373  c15c a202               asstart:ldx #2			; move output buffer index past crunched mnemonic
   374                          
   375  c15e a5a6               asoplp:	lda count		; after first number copy everything else to output buffer
   376  c160 d024               	bne asopend
   377  c162 2023c6             	jsr eval		; evaluate next parameter, if number crunch it
   378  c165 f019               	beq asoptxt		; ...branch if not a number
   379                          
   380  c167 a924               	lda #'$'
   381  c169 956f               	sta hulp,x		; buffer a number, either '$00' or '$0000'
   382  c16b e8                 	inx
   383  c16c a004               	ldy #4
   384  c16e c4a6               	cpy count
   385  c170 f006               	beq asop2by		; ...branch to force absolute	
   386  c172 a5b1               asopchk:lda tmp0+1
   387  c174 d002               	bne asop2by		; ...branch if 2-byte field
   388  c176 a002               	ldy #2			; else set up  1-byte field
   389                          
   390  c178 a930               asop2by:lda #'0'
   391  c17a 956f               asopzlp:sta hulp,x
   392  c17c e8                 	inx
   393  c17d 88                 	dey
   394  c17e d0fa               	bne asopzlp
   395                          
   396  c180 2054f3             asoptxt:jsr glc			; re-get last character
   397  c183 4c89c1             	jmp asopen1
   398  c186 205bf3             asopend:jsr gnc			; copy rest of input buffer to output buffer
   399  c189 f00d               asopen1:beq asopeol		; ...branch if eol
   400  c18b c920               	cmp #' '
   401  c18d f0cf               	beq asoplp		; ...squish out spaces
   402  c18f 956f               	sta hulp,x		; hopefully it's of one of these:   #,()
   403  c191 e8                 	inx
   404  c192 e00a               	cpx #10
   405  c194 90c8               	bcc asoplp		; ...loop until eol or
   406  c196 b0c1               	bcs aserr		; ...buffer overflow
   407                          
   408  c198 86b2               asopeol:stx tmp1		; save input # of characters
   409  c19a a200               	ldx #0
   410  c19c 86a3               	stx wrap		; start trial at zero
   411                          
   412  c19e a200               as110:  ldx #0
   413  c1a0 8e9603             	stx temp		; disa index=0
   414  c1a3 a5a3               	lda wrap		; get trial byte
   415  c1a5 2053c3             	jsr dset		; digest it
   416  c1a8 a6bb               	ldx format		; save format for later
   417  c1aa 86b3               	stx tmp1+1
   418  c1ac aa                 	tax	     		; index into mnemonic table
   419  c1ad bd59c4             	lda mnemr,x		; get compressed
   420  c1b0 2078c2             	jsr tstrx		; mnemonic and test
   421  c1b3 bd19c4             	lda mneml,x
   422  c1b6 2078c2             	jsr tstrx
   423  c1b9 a206               	ldx #6	  		; six format bits
   424                          
   425  c1bb e003               as210:  cpx #3
   426  c1bd d012               	bne as230
   427  c1bf a4bc               	ldy length
   428  c1c1 f00e               	beq as230		; skip-single byte instr
   429                          
   430  c1c3 a5bb               as220:  lda format
   431  c1c5 c9e8               	cmp #$e8		; a relative instr?
   432  c1c7 a930               	lda #'0'		; test zeros
   433  c1c9 b01d               	bcs as250		; no-3 byte
   434  c1cb 2075c2             	jsr tst2		; test a byte,2 chars
   435  c1ce 88                 	dey
   436  c1cf d0f2               	bne as220
   437                          
   438  c1d1 06bb               as230:  asl format
   439  c1d3 900e               	bcc as240
   440  c1d5 bd0cc4             	lda char1-1,x
   441  c1d8 2078c2             	jsr tstrx		; test syntax
   442  c1db bd12c4             	lda char2-1,x
   443  c1de f003               	beq as240
   444  c1e0 2078c2             	jsr tstrx		; test more syntax
   445                          
   446  c1e3 ca                 as240:  dex
   447  c1e4 d0d5               	bne as210
   448  c1e6 f006               	beq as300
   449                          
   450  c1e8 2075c2             as250:  jsr tst2		; test a word,4 chars
   451  c1eb 2075c2             	jsr tst2
   452                          
   453  c1ee a5b2               as300:  lda tmp1	  	; check # chars of both
   454  c1f0 cd9603             	cmp temp
   455  c1f3 f003               	beq as310		; match, skip
   456  c1f5 4c83c2             	jmp tst05		; fail
   457                          
   458  c1f8 a4bc               as310:  ldy length
   459  c1fa f030               	beq as500		; if only 1 byte instr skip
   460  c1fc a5b3               	lda tmp1+1		; get saved format
   461  c1fe c99d               	cmp #$9d		; a relative instr?
   462  c200 d022               	bne as400		; no-skip
   463                          
   464  c202 a5b0               	lda tmp0	  	; calculate a relative
   465  c204 e5b4               	sbc tmp2	  	; (.c=1 already)
   466  c206 aa                 	tax			; save 'diff'
   467  c207 a5b1               	lda tmp0+1
   468  c209 e5b5               	sbc tmp2+1
   469  c20b 9008               	bcc as320		; ...taken if a negative branch
   470                          
   471  c20d d063               	bne aerr		; positive branch, out of range
   472  c20f e082               	cpx #$82
   473  c211 b05f               	bcs aerr
   474  c213 9008               	bcc as340
   475                          
   476  c215 a8                 as320	tay			; negative branch
   477  c216 c8                 	iny	     		; out of range, y=$ff
   478  c217 d059               	bne aerr
   479  c219 e082               	cpx #$82
   480  c21b 9055               	bcc aerr
   481  c21d ca                 as340:  dex	     		; subtract 2 from 'diff' for instr
   482  c21e ca                 	dex
   483  c21f 8a                 	txa
   484  c220 a4bc               	ldy length		; set index to length
   485  c222 d003               	bne as420		; branch always
   486                          
   487  c224 b9af00             as400:	lda tmp0-1,y		; no-put byte out there
   488                          
   489  c227 91b4               as420:	sta (tmp2),y		; put byte
   490  c229 88                 	dey
   491  c22a d0f8               	bne as400
   492                          
   493  c22c a5a3               as500: 	lda wrap		; get good op code
   494  c22e 91b4               	sta (tmp2),y		; put byte
   495  c230 2010f0             	jsr crlf		; get ready to overstrike line
   496  c233 a991               	lda #$91		; cursor up
   497  c235 20d2ff             	jsr bsout
   498  c238 a941               	lda #'a'
   499  c23a 20d2ff             	jsr bsout
   500  c23d 200af0             	jsr space	
   501  c240 20d1c2             	jsr dis400		; disassemble one line
   502                          
   503  c243 e6bc               	inc length
   504  c245 a5bc               	lda length
   505  c247 2018f3             	jsr addt2		; update address
   506                          
   507  c24a a941               	lda #'a'		; set up next line with 'a bnnnn ' for convenience
   508  c24c 8d9f03             	sta keyd		; put it in the keyboard buffer
   509  c24f a920               	lda #' '
   510  c251 8da003             	sta keyd+1
   511  c254 8da503             	sta keyd+6
   512  c257 a5b5               	lda tmp2+1		; next get mid byte of address
   513  c259 203ff3             	jsr makhex
   514  c25c 8da103             	sta keyd+2		; ..and put in buffer,
   515  c25f 8ea203             	stx keyd+3
   516  c262 a5b4               	lda tmp2		; then get the low byte of address,
   517  c264 203ff3             	jsr makhex
   518  c267 8da303             	sta keyd+4		; ..and put that in the buffer, too.
   519  c26a 8ea403             	stx keyd+5
   520  c26d a907               	lda #7			; store 7 keys in buffer
   521  c26f 85d8               	sta ndx
   522  c271 60                 	rts
   523                          
   524  c272 4c59ef             aerr:	jmp erropr		; syntax error jump
   525                          
   526                          ;  test char in .a with char in hulp
   527  c275 2078c2             tst2:	jsr tstrx		; test for '00' (do two tests)
   528                          
   529  c278 86a5               tstrx:	stx sxreg
   530  c27a ae9603             	ldx temp		; get current position
   531  c27d d56f               	cmp hulp,x		; same char
   532  c27f f009               	beq tst10		; yes-skip
   533  c281 68                 	pla	     		; pull jsr off stack
   534  c282 68                 	pla
   535                          
   536  c283 e6a3               tst05:	inc wrap		; try next trial
   537  c285 f0eb               	beq aerr		; =0 tried all,sorry
   538  c287 4c9ec1             	jmp as110
   539                          
   540  c28a ee9603             tst10:	inc temp
   541  c28d a6a5               	ldx sxreg		; restore x
   542  c28f 60                 	rts
   543                          ; -------------------------------------------------------------------------------------------------
   544                          ; Mini disassembler
   545                          ;   syntax: d ssss eeee = start end (optional)
   546                          ;           d (only) continues 
   547  c290 20e8c5             disasm:	jsr parse		; get sa
   548  c293 b008               	bcs dishpag		; use a default length from current sa
   549  c295 20d8f2             	jsr t2t2		; sa to tmp2
   550  c298 20e8c5             	jsr parse
   551  c29b 900a               	bcc disto		; got sa,ea. use 'em
   552                          
   553  c29d a917               dishpag:lda #DISDEF		; guess at 1/2 page
   554  c29f 85b0               	sta tmp0
   555  c2a1 a900               	lda #0
   556  c2a3 85b1               	sta tmp0+1
   557  c2a5 f005               	beq dislp		; always		
   558                          
   559  c2a7 20e8f2             disto:	jsr sub0m2    		; put ea-sa in tmp0
   560  c2aa 901a               	bcc diserr		; ...branch if sa > ea
   561                          
   562  c2ac 2010f0             dislp:  jsr crlf		; print <cr>
   563  c2af 20e1ff             	jsr stop
   564  c2b2 f011               	beq disx		; ...branch if user requests abort
   565  c2b4 20c9c2             	jsr dis300    		; disassemble 1 line
   566  c2b7 e6bc               	inc length
   567  c2b9 a5bc               	lda length
   568  c2bb 2018f3             	jsr addt2
   569  c2be a5bc               	lda length
   570  c2c0 20f8f2             	jsr subt0
   571  c2c3 b0e7               	bcs dislp
   572                          
   573  c2c5 60                 disx:	rts
   574                          
   575  c2c6 4c59ef             diserr:	jmp erropr		; syntax error jump
   576                          
   577  c2c9 a92e               dis300:	lda #'.'
   578  c2cb 20d2ff             	jsr bsout
   579  c2ce 200af0             	jsr space
   580                          
   581  c2d1 a6b5               dis400:	ldx tmp2+1
   582  c2d3 a4b4               	ldy tmp2
   583  c2d5 2024f3             	jsr putwrd		; write start address
   584  c2d8 200af0             	jsr space
   585  c2db a000               	ldy #0
   586  c2dd b1b4               	lda (tmp2),y		; get a byte from memory
   587  c2df 2053c3             	jsr dset		; get instr & digest it
   588                          
   589  c2e2 48                 	pha			; dump (length+1) bytes
   590  c2e3 a6bc               	ldx length		; (.y=0 from 'dset' above)
   591  c2e5 e8                 	inx
   592                          
   593  c2e6 ca                 pradr0:	dex
   594  c2e7 100c               	bpl pradrl		; pad non-printers
   595  c2e9 200af0             	jsr space		; print 3 spaces
   596  c2ec 200af0             	jsr space
   597  c2ef 200af0             	jsr space
   598  c2f2 4cfac2             	jmp pradrm
   599                          
   600  c2f5 b1b4               pradrl:	lda (tmp2),y
   601  c2f7 2029f3             	jsr puthxs		; write hex byte
   602                          
   603  c2fa c8                 pradrm:	iny
   604  c2fb c003               	cpy #3
   605  c2fd 90e7               	bcc pradr0
   606  c2ff 68                 	pla
   607                          
   608  c300 a203               	ldx #3
   609  c302 2099c3             	jsr prmne		; print mnemonic
   610  c305 a206               	ldx #6	  	 	; 6 format bits
   611                          
   612  c307 e003               pradr1:	cpx #$03
   613  c309 d014               	bne pradr3     		; if x=3 print adr val
   614  c30b a4bc               	ldy length
   615  c30d f010               	beq pradr3    	 	; no print if len=0
   616                          
   617  c30f a5bb               pradr2:	lda format
   618  c311 c9e8               	cmp #$e8 		; relative addressing mode?
   619  c313 08                 	php			; save carry
   620  c314 b1b4               	lda (tmp2),y
   621  c316 28                 	plp
   622  c317 b01c               	bcs reladr
   623  c319 2031f3             	jsr puthex		; write hex byte
   624  c31c 88                 	dey
   625  c31d d0f0               	bne pradr2
   626                          
   627  c31f 06bb               pradr3:	asl format		; test next format bit
   628  c321 900e               	bcc pradr4		; no print if=0
   629  c323 bd0cc4             	lda char1-1,x
   630  c326 20d2ff             	jsr bsout
   631  c329 bd12c4             	lda char2-1,x
   632  c32c f003               	beq pradr4
   633  c32e 20d2ff             	jsr bsout
   634                          
   635  c331 ca                 pradr4:	dex
   636  c332 d0d3               	bne pradr1
   637  c334 60                 	rts
   638                          
   639  c335 2047c3             reladr: jsr pcadj3		; pcl,h + disp + 1 into a,x
   640  c338 18                 	clc	     	 	; add 1
   641  c339 6901               	adc #1
   642  c33b d001               	bne relad2
   643  c33d e8                 	inx
   644                          
   645  c33e 48                 relad2:	pha
   646  c33f 8a                 	txa
   647  c340 2031f3             	jsr puthex		; print byte in .a as two hex digits
   648  c343 68                 	pla
   649  c344 2029f3             	jsr puthxs
   650                          
   651  c347 a6b5               pcadj3:	ldx tmp2+1
   652  c349 a8                 	tay
   653  c34a 1001               	bpl pcadj4
   654  c34c ca                 	dex
   655                          
   656  c34d 65b4               pcadj4:	adc tmp2
   657  c34f 9001               	bcc pcrts
   658  c351 e8                 	inx
   659                          
   660  c352 60                 pcrts:	rts
   661                          
   662                          ; disassembler digest routine
   663  c353 a8                 dset:	tay
   664  c354 4a                 	lsr			; even/odd test
   665  c355 900b               	bcc ieven
   666  c357 4a                 	lsr			; test b1
   667  c358 b017               	bcs err			; xxxxxx11 instr bad
   668  c35a c922               	cmp #$22
   669  c35c f013               	beq err			; 10001001 instr bad
   670  c35e 2907               	and #$07		; mask 3 bits for adr mode
   671  c360 0980               	ora #$80 		; add indexing offset
   672                          
   673  c362 4a                 ieven:	lsr			; left/right test
   674  c363 aa                 	tax
   675  c364 bdbbc3             	lda nmode,x		; index into mode table
   676  c367 b004               	bcs rtmode		; if carry set use lsb for
   677  c369 4a                 	lsr			; print format index
   678  c36a 4a                 	lsr
   679  c36b 4a                 	lsr			; if carry clr use msb
   680  c36c 4a                 	lsr
   681                          
   682  c36d 290f               rtmode:	and #$0f		; mask for 4-bit index
   683  c36f d004               	bne getfmt		; $0 for bad opcodes
   684                          
   685  c371 a080               err:	ldy #$80		; sub $80 for bad opcode
   686  c373 a900               	lda #0			; set format index to zero
   687                          
   688  c375 aa                 getfmt:	tax
   689  c376 bdffc3             	lda nmode2,x		; index into prt format tab
   690  c379 85bb               	sta format		; save for adr field format
   691  c37b 2903               	and #3			; mask 2-bit length. 0=1byte
   692  c37d 85bc               	sta length		; 1=2byte,2=3byte
   693  c37f 98                 	tya			; op code
   694  c380 298f               	and #$8f		; mask for 1xxx1010 test
   695  c382 aa                 	tax			; save in x
   696  c383 98                 	tya			; op code again
   697  c384 a003               	ldy #3
   698  c386 e08a               	cpx #$8a
   699  c388 f00b               	beq mnndx3
   700                          
   701  c38a 4a                 mnndx1:	lsr
   702  c38b 9008               	bcc mnndx3		; form index into mnemonic tab
   703  c38d 4a                 	lsr
   704                          
   705  c38e 4a                 mnndx2:	lsr			; 1xxx1010->00101xxx
   706  c38f 0920               	ora #$20		; xxxyyy01->00111xxx
   707  c391 88                 	dey			; xxxyyy10->00110xxx
   708  c392 d0fa               	bne mnndx2		; xxxyy100->00100xxx
   709  c394 c8                 	iny			; xxxxx000->000xxxxx
   710                          
   711  c395 88                 mnndx3:	dey
   712  c396 d0f2               	bne mnndx1
   713  c398 60                 	rts			; (.y=0 is assumed!)
   714                          
   715                          ; print mnemonic
   716                          ; enter x=3 characters
   717  c399 a8                 prmne:	tay
   718  c39a b919c4             	lda mneml,y		; fetch 3 char mnemonic
   719  c39d 85b2               	sta tmp1
   720  c39f b959c4             	lda mnemr,y
   721  c3a2 85b3               	sta tmp1+1
   722                          
   723  c3a4 a900               prmn1:	lda #0
   724  c3a6 a005               	ldy #5
   725                          
   726  c3a8 06b3               prmn2:	asl tmp1+1		; shift 5 bits of char
   727  c3aa 26b2               	rol tmp1		; into a
   728  c3ac 2a                 	rol			; clear carry
   729  c3ad 88                 	dey
   730  c3ae d0f8               	bne prmn2
   731  c3b0 693f               	adc #$3f		; add '?' offset
   732  c3b2 20d2ff             	jsr bsout
   733  c3b5 ca                 	dex
   734  c3b6 d0ec               	bne prmn1
   735  c3b8 4c0af0             	jmp space		; finish with space
   736                          
   737                          ; assembler - disassembler decoding tables
   738  c3bb 40024503           nmode:	!byte $40,2,$45,3
   739  c3bf d0084009           	!byte $d0,8,$40,9
   740  c3c3 30224533           	!byte $30,$22,$45,$33
   741  c3c7 d0084009           	!byte $d0,8,$40,9
   742  c3cb 40024533           	!byte $40,2,$45,$33
   743  c3cf d0084009           	!byte $d0,8,$40,9
   744  c3d3 400245b3           	!byte $40,$02,$45,$b3
   745  c3d7 d0084009           	!byte $d0,$08,$40,$09
   746  c3db 00224433           	!byte 0,$22,$44,$33
   747  c3df d08c4400           	!byte $d0,$8c,$44,0
   748  c3e3 11224433           	!byte $11,$22,$44,$33
   749  c3e7 d08c449a           	!byte $d0,$8c,$44,$9a
   750  c3eb 10224433           	!byte $10,$22,$44,$33
   751  c3ef d0084009           	!byte $d0,8,$40,9
   752  c3f3 10224433           	!byte $10,$22,$44,$33
   753  c3f7 d0084009           	!byte $d0,8,$40,9
   754  c3fb 621378a9           	!byte $62,$13,$78,$a9
   755                          
   756  c3ff 00218182           nmode2:	!byte 0,$21,$81,$82
   757  c403 0000594d           	!byte 0,0,$59,$4d
   758  c407 9192864a           	!byte $91,$92,$86,$4a
   759  c40b 859d               	!byte $85,$9d
   760                          
   761  c40d 2c292c232824       char1:	!pet ",),#($"
   762                          
   763  c413 590058242400       char2:	!pet "y",0,"x$$",0
   764                          
   765  c419 1c8a1c23           mneml:	!byte $1c,$8a,$1c,$23
   766  c41d 5d8b1ba1           	!byte $5d,$8b,$1b,$a1
   767  c421 9d8a1d23           	!byte $9d,$8a,$1d,$23
   768  c425 9d8b1da1           	!byte $9d,$8b,$1d,$a1
   769  c429 002919ae           	!byte 0,$29,$19,$ae
   770  c42d 69a81923           	!byte $69,$a8,$19,$23
   771  c431 24531b23           	!byte $24,$53,$1b,$23
   772  c435 245319a1           	!byte $24,$53,$19,$a1
   773  c439 001a5b5b           	!byte 0,$1a,$5b,$5b
   774  c43d a5692424           	!byte $a5,$69,$24,$24
   775  c441 aeaea8ad           	!byte $ae,$ae,$a8,$ad
   776  c445 29007c00           	!byte $29,0,$7c,0
   777  c449 159c6d9c           	!byte $15,$9c,$6d,$9c
   778  c44d a5692953           	!byte $a5,$69,$29,$53
   779  c451 84133411           	!byte $84,$13,$34,$11
   780  c455 a56923a0           	!byte $a5,$69,$23,$a0
   781                          
   782  c459 d8625a48           mnemr:	!byte $d8,$62,$5a,$48
   783  c45d 26629488           	!byte $26,$62,$94,$88
   784  c461 5444c854           	!byte $54,$44,$c8,$54
   785  c465 6844e894           	!byte $68,$44,$e8,$94
   786  c469 00b40884           	!byte 0,$b4,8,$84
   787  c46d 74b4286e           	!byte $74,$b4,$28,$6e
   788  c471 74f4cc4a           	!byte $74,$f4,$cc,$4a
   789  c475 72f2a48a           	!byte $72,$f2,$a4,$8a
   790  c479 00aaa2a2           	!byte 0,$aa,$a2,$a2
   791  c47d 74747472           	!byte $74,$74,$74,$72
   792  c481 4468b232           	!byte $44,$68,$b2,$32
   793  c485 b2002200           	!byte $b2,0,$22,0
   794  c489 1a1a2626           	!byte $1a,$1a,$26,$26
   795  c48d 727288c8           	!byte $72,$72,$88,$c8
   796  c491 c4ca2648           	!byte $c4,$ca,$26,$48
   797  c495 4444a2c8           	!byte $44,$44,$a2,$c8
   798                          ; -------------------------------------------------------------------------------------------------
   799                          ; transfer memory
   800                          ;   syntax: t ssss eeee tttt = start end target
   801  c499 a900               compar:	lda #0		   	; flag 'compare'
   802  c49b 859c               	sta fnlen		; diff flag
   803  c49d 2c                 	!byte $2c		; skip next
   804                          
   805  c49e a980               trnsfr:	lda #$80		; flag 'transfer'
   806  c4a0 8d5b03             	sta verck
   807  c4a3 20c4c5             	jsr range		; get sa in tmp2, calculate length, put in tmp1
   808  c4a6 b049               	bcs errl		; ...none=error
   809  c4a8 20e8c5             	jsr parse		; target in tmp0
   810  c4ab b044               	bcs errl		; ...none=error
   811  c4ad 2c5b03             	bit verck
   812  c4b0 3003               	bmi trnok		; -> transfer
   813                          ; compare
   814  c4b2 2010f0             	jsr crlf	
   815                          
   816  c4b5 a000               trnok:	ldy #0
   817  c4b7 b1b4               trnlp:	lda (tmp2),y		; get source byte
   818  c4b9 2c5b03             	bit verck
   819  c4bc 1005               	bpl trncmp		; -> compare
   820                          ; transfer
   821  c4be 91b0               	sta (tmp0),y		; transfer: store target
   822  c4c0 4cd2c4             	jmp trninc		; next
   823                          ; compare
   824  c4c3 d1b0               trncmp: cmp (tmp0),y		; equal?
   825  c4c5 f00b               	beq trninc		; yes -> skip
   826                          ; report diffs
   827  c4c7 a6b5               	ldx tmp2+1
   828  c4c9 a4b4               	ldy tmp2
   829  c4cb 2024f3             	jsr putwrd		; write diff address source
   830  c4ce 859c               	sta fnlen
   831  c4d0 a000               	ldy #0
   832                          
   833  c4d2 e6b0               trninc:	inc tmp0
   834  c4d4 d007               	bne trnnxt
   835  c4d6 e6b1               	inc tmp0+1
   836  c4d8 d003               	bne trnnxt
   837  c4da 4cf1c4             	jmp errl		; disallow wrapping around operations
   838                          
   839  c4dd 2016f3             trnnxt:	jsr inct2
   840  c4e0 2008f3             	jsr dect1
   841  c4e3 b0d2               	bcs trnlp
   842                          
   843  c4e5 2c5b03             	bit verck
   844  c4e8 3073               	bmi hunx		; transfer -> exit
   845                          ; compare result
   846  c4ea a59c               	lda fnlen
   847  c4ec d06f               	bne hunx		; diffs
   848                          ; ok
   849  c4ee 4c71f3             	jmp printok		; output ok
   850                          
   851  c4f1 4c59ef             errl:	jmp erropr
   852                          ; -------------------------------------------------------------------------------------------------
   853                          ; hunt for bytes or string in memory
   854                          ;   syntax: h ssss eeee "ascii... <or> h ssss eeee 11 22 33 ...   s=start, e=end
   855  c4f4 20c4c5             hunt:	jsr range		; get sa in tmp2, calculate length, put in tmp1
   856  c4f7 b0f8               	bcs errl		; ...none=error
   857  c4f9 a000               	ldy #0
   858  c4fb 205bf3             huntspc:jsr gnc			; get first char
   859  c4fe f0f1               	beq errl		; ...branch if true eol (error)
   860  c500 c920               	cmp #' '		; blank?
   861  c502 f0f7               	beq huntspc		; span blanks...
   862  c504 c922               	cmp #$22 ; "		; is it an <">
   863  c506 d016               	bne hunhex		; no..  must be hex
   864  c508 205bf3             	jsr gnc			; yes.. get first string chr
   865  c50b c900               	cmp #0
   866  c50d f0e2               	beq errl		; ...branch if true eol (error)
   867                          ; search string
   868  c50f 996103             hunnxch:sta xcnt,y
   869  c512 c8                 	iny
   870  c513 205bf3             	jsr gnc			; get next
   871  c516 f01c               	beq hunstrt		; yes-end of string
   872  c518 c020               	cpy #32			; no-32 char yet?
   873  c51a d0f3               	bne hunnxch		; no-get more
   874  c51c f016               	beq hunstrt		; yes-go look for it
   875                          ; search bytes
   876  c51e 20e2c5             hunhex:	jsr pargot
   877                          
   878  c521 c903               hunnxhx:cmp #2+1
   879  c523 b0cc               	bcs errl		; > 2 digits
   880  c525 a5b0               	lda tmp0
   881  c527 996103             	sta xcnt,y
   882  c52a c8                 	iny
   883  c52b 20e8c5             	jsr parse		; get next byte
   884  c52e b004               	bcs hunstrt		; no more -go look for bytes
   885  c530 c020               	cpy #32			; 32 bytes yet?
   886  c532 d0ed               	bne hunnxhx		; no-get more
   887                          
   888  c534 8c5b03             hunstrt:sty verck		; yes-start search
   889  c537 2010f0             	jsr crlf		; next line
   890                          
   891  c53a a000               hunlp:	ldy #0
   892                          
   893  c53c b1b4               hunstlp:lda (tmp2),y		; get a byte from memory
   894  c53e d96103             	cmp xcnt,y
   895  c541 d00d               	bne hundiff		; ...branch if no match
   896  c543 c8                 	iny
   897  c544 cc5b03             	cpy verck		; checked full string?
   898  c547 d0f3               	bne hunstlp		; no-check on
   899                          ; report found
   900  c549 a6b5               	ldx tmp2+1
   901  c54b a4b4               	ldy tmp2
   902  c54d 2024f3             	jsr putwrd		; print address found
   903                          
   904  c550 20e1ff             hundiff:jsr stop
   905  c553 f008               	beq hunx		; ...branch if user requests abort
   906  c555 2016f3             	jsr inct2
   907  c558 2008f3             	jsr dect1
   908  c55b b0dd               	bcs hunlp		; loop if not done
   909                          
   910  c55d 60                 hunx:	rts
   911                          ; -------------------------------------------------------------------------------------------------
   912                          ; read & display the disk directory
   913  c55e a924               diskdir:lda #'$'
   914  c560 c010               dirchlp:cpy #16			; max string length
   915  c562 f08d               	beq errl		; string too long
   916  c564 9190               	sta (fnadr),y		; store string
   917  c566 e69c               	inc fnlen
   918  c568 c8                 	iny
   919  c569 205bf3             	jsr gnc			; get character of string
   920  c56c d0f2               	bne dirchlp		; no eol -> next char
   921                          
   922  c56e a900               dirstr:	lda #0			; set logical index
   923  c570 a060               	ldy #$60		; sa for directory
   924  c572 209afe             	jsr setlfs
   925  c575 18                 	clc
   926  c576 20c0ff             	jsr open		; open directory channel
   927  c579 b03f               	bcs dirdone		; ...branch on error
   928  c57b a200               	ldx #0
   929  c57d 20c6ff             	jsr chkin		; make it an input channel
   930                          
   931  c580 a003               	ldy #3			; first pass only- trash first two bytes read
   932                          
   933  c582 84b2               dirlp:  sty tmp1		; loop counter
   934  c584 20cfff             dirbklp:jsr basin
   935  c587 85b0               	sta tmp0		; get # blocks low
   936  c589 a59b               	lda status
   937  c58b d02d               	bne dirdone		; ...branch if error, possibly no device?
   938  c58d 20cfff             	jsr basin
   939  c590 85b1               	sta tmp0+1		; get # blocks high
   940  c592 a59b               	lda status
   941  c594 d024               	bne dirdone		; ...branch if error, possibly no device?
   942  c596 c6b2               	dec tmp1
   943  c598 d0ea               	bne dirbklp		; ...loop until done
   944  c59a 2010f0             	jsr crlf		; start a new line
   945  c59d 2078c6             	jsr prtblks		; convert # blocks to decimal and print it
   946  c5a0 200af0             	jsr space		; print space  (to match loaded directory display)
   947                          
   948  c5a3 20cfff             dirfnlp:jsr basin		; read & print filename & filetype
   949  c5a6 f009               	beq direol		; ...branch if eol
   950  c5a8 a69b               	ldx status
   951  c5aa d00e               	bne dirdone		; ...branch if error
   952  c5ac 20d2ff             	jsr bsout
   953  c5af 90f2               	bcc dirfnlp		; ...loop always
   954                          
   955                          direol:
   956  c5b1 20e1ff             	jsr stop
   957  c5b4 f008               	beq dirend		; ...branch if user hit STOP
   958  c5b6 a002               	ldy #2
   959  c5b8 d0c8               	bne dirlp		; ...loop always
   960                          
   961  c5ba c003               dirdone:cpy #3			; checks if first dir byte is cr -> no device
   962  c5bc f003               	beq direrr		; no device?
   963  c5be 4ccff2             dirend: jmp disk30		; close
   964  c5c1 4cccf2             direrr:	jmp disk29		; -> error
   965                          ; -------------------------------------------------------------------------------------------------
   966                          ; read a range - put sa in t2, count in t1   (save ea in 'temps')
   967                          ; returns .c=0 if okay, .c=1 if error (missing parameter or sa < ea)
   968  c5c4 20e8c5             range:  jsr parse
   969  c5c7 b017               	bcs rangex		; ...branch if missing sa
   970  c5c9 20d8f2             	jsr t2t2		; move sa from t0 to t2
   971  c5cc 20e8c5             	jsr parse		; get ea
   972  c5cf b00f               	bcs rangex		; ...branch if missing ea
   973                          
   974  c5d1 20e8f2             	jsr sub0m2		; calculate length = ea - sa  (.c=0 if ea<sa)
   975                          
   976  c5d4 a5b0               	lda tmp0	   	; move length from t0 to t1
   977  c5d6 85b2               	sta tmp1
   978  c5d8 a5b1               	lda tmp0+1
   979  c5da 85b3               	sta tmp1+1
   980  c5dc 9002               	bcc rangex		; invert .c from subtraction above
   981  c5de 18                 	clc			; good stuff exits here
   982  c5df 24                 	!byte $24		; skip next
   983  c5e0 38                 rangex:	sec			; bad  stuff exits here
   984  c5e1 60                 	rts
   985                          ; -------------------------------------------------------------------------------------------------
   986                          ;  parse entry when 1st character has already been read
   987  c5e2 2011c6             pargot:	jsr evalgot
   988  c5e5 4cf1c5             	jmp parse1
   989                          ;  parse next item & put its value into  tmp0, tmp0+1
   990                          ;    .z=0 valid number
   991                          ;    .z=1 if no value found (only delimiter)
   992                          ;    .c=1 if eol & no value found!
   993                          ;    .x & .y are preserved, .a contains # digits read.
   994                          ;    if error, call is popped & 'jmp error' performed.
   995  c5e8 a5a4               parse:  lda lastchr
   996  c5ea c90d               	cmp #cr			; last char was EOL?
   997  c5ec f01d               	beq pareol		; ...yes
   998  c5ee 2023c6             	jsr eval		; evaluate ascii input as a number
   999  c5f1 b013               parse1:	bcs parserr		; ...branch if error
  1000  c5f3 2054f3             	jsr glc
  1001  c5f6 d006               	bne parckdl		; ...branch if not eol
  1002  c5f8 a5a6               	lda count
  1003  c5fa d011               	bne parok		; ...valid number input, treat eol as a delimiter
  1004  c5fc f00d               	beq pareol		; ...the well is very dry
  1005                          
  1006  c5fe c920               parckdl	cmp #' '		; parse delimiters (only allow <space> or <comma>)
  1007  c600 f00b               	beq parok
  1008  c602 c92c               	cmp #','
  1009  c604 f007               	beq parok		; ...fall into error if bad delimiter
  1010                          
  1011  c606 68                 parserr:pla			; pop this call
  1012  c607 68                 	pla
  1013  c608 4c59ef             	jmp erropr
  1014                          
  1015  c60b 38                 pareol:	sec			; set .c=1 for eol
  1016  c60c 24                 	!byte $24		; skip next
  1017                          
  1018  c60d 18                 parok:	clc			; clear .c for not-eol
  1019  c60e a5a6               	lda count		; set .z=0 for valid number
  1020  c610 60                 	rts
  1021                          ; -------------------------------------------------------------------------------------------------
  1022                          ;  evaluate when 1st character has already been read
  1023  c611 a900               evalgot:lda #0
  1024  c613 85b0               	sta tmp0		; clear value
  1025  c615 85b1               	sta tmp0+1
  1026  c617 85a6               	sta count		; reset digit counter (flags valid number vs. null input)
  1027  c619 8a                 	txa
  1028  c61a 48                 	pha			; preserve .x & .y
  1029  c61b 98                 	tya
  1030  c61c 48                 	pha
  1031  c61d 2054f3             	jsr glc
  1032  c620 4c32c6             	jmp eval1 
  1033                          ;  evaluate next item in buffer & put its value into  tmp0, tmp0+1
  1034                          ;	.c=0  normal return
  1035                          ;	.c=1  error  return
  1036                          ;	.z=1  null input or EOL
  1037                          ;	.x & .y are preserved.
  1038                          ; returns last character
  1039  c623 a900               eval:	lda #0
  1040  c625 85b0               	sta tmp0		; clear value
  1041  c627 85b1               	sta tmp0+1
  1042  c629 85a6               	sta count		; reset digit counter (flags valid number vs. null input)
  1043  c62b 8a                 	txa
  1044  c62c 48                 	pha			; preserve .x & .y
  1045  c62d 98                 	tya
  1046  c62e 48                 	pha
  1047                          
  1048  c62f 205bf3             evlspc:	jsr gnc			; get next character
  1049  c632 d003               eval1:	bne evnoeol
  1050  c634 4c70c6             	jmp eval_ok		; ...branch if end of line
  1051  c637 c920               evnoeol:cmp #' '
  1052  c639 f0f4               	beq evlspc		; ...branch & ignore leading spaces
  1053  c63b c924               	cmp #'$'
  1054  c63d f0f0               	beq evlspc		; ignore leading $
  1055  c63f d003               	bne evnxch1
  1056                          
  1057  c641 205bf3             evnxchr:jsr gnc			; get next character
  1058  c644 f02a               evnxch1:beq eval_ok		; ...branch if eol
  1059  c646 38                 	sec
  1060  c647 e930               	sbc #'0'		; convert ascii digit to binary value
  1061  c649 9025               	bcc eval_ok		; ...branch if not a number (<$30) (assume delimiter)
  1062  c64b c90a               	cmp #10
  1063  c64d 9006               	bcc evnumbr		; ...number 0-9
  1064  c64f e907               	sbc #7
  1065  c651 c910               	cmp #16			; ...number a-f
  1066  c653 b019               	bcs eval_ng		; >$46 ('f') -> error
  1067                          
  1068  c655 a8                 evnumbr:tay			; remember value of current digit
  1069  c656 e6a6               	inc count		; flag valid digit
  1070                          
  1071  c658 a204               	ldx #4			; 4bit hex number
  1072  c65a 06b0               evshflp:asl tmp0		; shift digit up
  1073  c65c 26b1               	rol tmp0+1
  1074  c65e b00e               	bcs eval_ng		; ...branch if overflow error
  1075  c660 ca                 	dex
  1076  c661 d0f7               	bne evshflp		; ...next shift
  1077                          
  1078  c663 98                 evaddig:tya			; get current digit
  1079  c664 05b0               	ora tmp0		; ..and add
  1080  c666 85b0               	sta tmp0
  1081  c668 a904               	lda #4			; max 4 digits allowed
  1082  c66a c5a6               	cmp count
  1083  c66c b0d3               	bcs evnxchr		; <=4 ...next character
  1084                          ; count >4 = error
  1085  c66e 38                 eval_ng:sec
  1086  c66f 24                 	!byte $24		; skip next
  1087                          
  1088  c670 18                 eval_ok:clc
  1089  c671 68                 	pla
  1090  c672 a8                 	tay			; restore .x & .y
  1091  c673 68                 	pla
  1092  c674 aa                 	tax
  1093  c675 a5a6               	lda count
  1094  c677 60                 	rts
  1095                          ; -------------------------------------------------------------------------------------------------
  1096                          ; convert blocks from binary to decimal (BCD) and print it
  1097                          ;   input : binary value (2 bytes) in tmp0
  1098                          ;   output: decimal value (3 bytes) in HULP as packed BCD
  1099  c678 a900               prtblks:lda #0
  1100  c67a a205               	ldx #5
  1101  c67c 956f               bindlp: sta hulp,x		; initialize working registers
  1102  c67e ca                 	dex
  1103  c67f 10fb               	bpl bindlp
  1104  c681 e674               	inc hulp+5		; seed value_of_bit with 1
  1105                          
  1106  c683 a00f               	ldy #15			; loop index (2 bytes = 16 bits)
  1107  c685 08                 	php			; save caller's processor mode
  1108  c686 78                 	sei			; disable IRQ's (but beware NMI's!)
  1109  c687 f8                 	sed			; put processor into decimal mode (for ADC's & SBC's)
  1110                          ; main loop. rotate bits right 1 at a time, and if set add the current value_of_bit to the sum.
  1111  c688 46b1               binmlp:	lsr tmp0+1		; hi
  1112  c68a 66b0               	ror tmp0		; lo
  1113  c68c 900c               	bcc binbit0		; ...branch if bit not set (its value is 0)
  1114                          
  1115  c68e 18                 	clc
  1116  c68f a202               	ldx #2
  1117  c691 b572               binbtlp:lda hulp+3,x		; add current value_of_bit (decimal arithmetic)
  1118  c693 756f               	adc hulp,x
  1119  c695 956f               	sta hulp,x
  1120  c697 ca                 	dex
  1121  c698 10f7               	bpl binbtlp
  1122                          
  1123  c69a 18                 binbit0:clc
  1124  c69b a202               	ldx #2
  1125  c69d b572               bincalp:lda hulp+3,x		; calculate value of next bit (decimal arithmetic)
  1126  c69f 7572               	adc hulp+3,x
  1127  c6a1 9572               	sta hulp+3,x
  1128  c6a3 ca                 	dex
  1129  c6a4 10f7               	bpl bincalp
  1130  c6a6 88                 	dey
  1131  c6a7 10df               	bpl binmlp		; loop until done conversion
  1132                          
  1133  c6a9 28                 	plp			; restore processor mode (clear decimal mode, clear irq flag)
  1134                          ; unpack BCD encoded number in hulp, convert it to ascii & print it.
  1135  c6aa a900               	lda #0			; no leading zeros
  1136  c6ac 85a6               	sta count
  1137  c6ae a206               	ldx #6			; max digits
  1138                          ; shift a nibble (BCD digit) to a
  1139  c6b0 a003               unplp:	ldy #4-1		; # bits per digit, .x is digit counter
  1140  c6b2 a900               	lda #0
  1141  c6b4 0671               unpshlp:asl hulp+2		; lo
  1142  c6b6 2670               	rol hulp+1		; mid
  1143  c6b8 266f               	rol hulp		; hi
  1144  c6ba 2a                 	rol			; shift a digit into .a
  1145  c6bb 88                 	dey
  1146  c6bc 10f6               	bpl unpshlp
  1147                          
  1148  c6be a8                 	tay			; set flags for .a
  1149  c6bf d008               	bne binzero
  1150  c6c1 e001               	cpx #1
  1151  c6c3 f004               	beq binzero		; ...print zero if it's the last digit
  1152  c6c5 a4a6               	ldy count		; check flag if a non-zero value was already printed?
  1153  c6c7 f007               	beq binskzr		; no...skip leading zeros
  1154                          
  1155  c6c9 e6a6               binzero:inc count		; flag a non-zero digit
  1156  c6cb 0930               	ora #'0'		; make it ascii
  1157  c6cd 20d2ff             	jsr bsout		; print it
  1158                          
  1159  c6d0 ca                 binskzr:dex
  1160  c6d1 d0dd               	bne unplp		; ...loop until all digits printed
  1161  c6d3 60                 	rts
  1162                          ; ******************************************* BASIC ***********************************************
  1163                          ; BASIC DOS command
  1164                          !zone basic
  1165                          ; Send disk command, print directory (@$) or read status '@'
  1166  c6d4 a9c0               bdoscmd:lda #$40+$80
  1167  c6d6 8d5d03             	sta msgflg		; i/o messages to screen
  1168  c6d9 a000               	ldy #0			; .y=0 to count string length
  1169  c6db 849b               	sty status		; clear status @ i/o begin
  1170  c6dd 849c               	sty fnlen		; filename length of zero...
  1171  c6df a6b7               	ldx ddisk		; drive id
  1172                          
  1173  c6e1 2045c7             	jsr chget		; get basic char
  1174  c6e4 c924               	cmp #'$'
  1175  c6e6 d003               	bne doscmd
  1176  c6e8 4c5ec7             	jmp dosdir		; ...branch if directory read
  1177                          
  1178  c6eb 98                 doscmd:	tya			; la=0
  1179  c6ec a00f               	ldy #15			; open command channel
  1180  c6ee 209afe             	jsr setlfs		; .a-0 temporary channel #
  1181  c6f1 18                 	clc
  1182  c6f2 20c0ff             	jsr open		; open a real channel
  1183  c6f5 b045               	bcs dos30		; exit if bad return
  1184                          
  1185  c6f7 204bc7             	jsr chgot		; see if status check
  1186  c6fa f01b               	beq dos20		; yes
  1187                          
  1188  c6fc 48                 	pha
  1189  c6fd a200               	ldx #0
  1190  c6ff 20c9ff             	jsr ckout		; set up as output
  1191  c702 68                 	pla
  1192  c703 b037               	bcs dos30		; bad status return
  1193  c705 9003               	bcc dos15		; no...ok
  1194                          ; command
  1195  c707 2045c7             dos10:	jsr chget		; get basic char
  1196  c70a 08                 dos15:	php			; save for later
  1197  c70b 20d2ff             	jsr bsout		; out to floppy
  1198  c70e a59b               	lda status
  1199  c710 d026               	bne dos28		; bad status returned
  1200  c712 28                 	plp			; end?
  1201  c713 d0f2               	bne dos10		; no...continue
  1202  c715 f025               	beq dos30		; yes...floppy done
  1203                          ; status
  1204  c717 20ccff             dos20:	jsr clrch		; clear channel
  1205  c71a 2010f0             	jsr crlf
  1206  c71d a200               	ldx #0
  1207  c71f 20c6ff             	jsr chkin		; tell floppy to speak
  1208  c722 b018               	bcs dos30		; bad device
  1209                          
  1210  c724 20cfff             dos25:	jsr basin		; get char
  1211  c727 c90d               	cmp #cr
  1212  c729 08                 	php			; save test for later
  1213  c72a 20d2ff             	jsr bsout		; out to screen
  1214  c72d a59b               	lda status		; check for bad basin
  1215  c72f 29bf               	and #$ff-$40		; remove eoi bit
  1216  c731 d005               	bne dos28		; report bad status
  1217  c733 28                 	plp			; end?
  1218  c734 d0ee               	bne dos25		; no...
  1219  c736 f004               	beq dos30		; yes...floppy done
  1220                          
  1221  c738 68                 dos28:	pla			; clean up...
  1222  c739 207cfc             dos29:	jsr error5		; report error #5 device not present
  1223  c73c 20ccff             dos30:	jsr clrch		; clean up
  1224  c73f a900               	lda #0
  1225  c741 38                 	sec			; close device (c=1)
  1226  c742 4cc3ff             	jmp close
  1227                          ; get basic char
  1228  c745 e683               chget:	inc txtptr		; increment text pointer
  1229  c747 d002               	bne chgot		; if no carry into msb
  1230  c749 e684               	inc txtptr+1
  1231                          
  1232  c74b 98                 chgot:	tya
  1233  c74c 48                 	pha
  1234  c74d a000               	ldy #0
  1235  c74f b183               	lda (txtptr),y
  1236  c751 8d9603             	sta temp
  1237  c754 68                 	pla
  1238  c755 a8                 	tay
  1239  c756 ad9603             	lda temp
  1240  c759 60                 	rts
  1241  c75a 200df0             doserr:	jsr outqst
  1242  c75d 60                 	rts
  1243                          ; read & display the disk directory
  1244  c75e a924               dosdir:	lda #'$'
  1245  c760 c010               ddirclp:cpy #16			; max string length
  1246  c762 f0f6               	beq doserr		; string too long
  1247  c764 9190               	sta (fnadr),y		; store string
  1248  c766 e69c               	inc fnlen
  1249  c768 c8                 	iny
  1250  c769 2045c7             	jsr chget		; get character of string
  1251  c76c d0f2               	bne ddirclp		; no eol -> next char
  1252                          
  1253  c76e a900               ddirstr:lda #0			; set logical index
  1254  c770 a060               	ldy #$60		; sa for directory
  1255  c772 209afe             	jsr setlfs
  1256  c775 18                 	clc
  1257  c776 20c0ff             	jsr open		; open directory channel
  1258  c779 b03f               	bcs ddirdon		; ...branch on error
  1259  c77b a200               	ldx #0
  1260  c77d 20c6ff             	jsr chkin		; make it an input channel
  1261                          
  1262  c780 a003               	ldy #3			; first pass only- trash first two bytes read
  1263                          
  1264  c782 84b2               ddirlp:	sty tmp1		; loop counter
  1265  c784 20cfff             ddirblp:jsr basin
  1266  c787 85b0               	sta tmp0		; get # blocks low
  1267  c789 a59b               	lda status
  1268  c78b d02d               	bne ddirdon		; ...branch if error, possibly no device?
  1269  c78d 20cfff             	jsr basin
  1270  c790 85b1               	sta tmp0+1		; get # blocks high
  1271  c792 a59b               	lda status
  1272  c794 d024               	bne ddirdon		; ...branch if error, possibly no device?
  1273  c796 c6b2               	dec tmp1
  1274  c798 d0ea               	bne ddirblp		; ...loop until done
  1275  c79a 2010f0             	jsr crlf		; start a new line
  1276  c79d 2078c6             	jsr prtblks		; convert # blocks to decimal and print it
  1277  c7a0 200af0             	jsr space		; print space  (to match loaded directory display)
  1278                          
  1279  c7a3 20cfff             ddirflp:jsr basin		; read & print filename & filetype
  1280  c7a6 f009               	beq ddireol		; ...branch if eol
  1281  c7a8 a69b               	ldx status
  1282  c7aa d00e               	bne ddirdon		; ...branch if error
  1283  c7ac 20d2ff             	jsr bsout
  1284  c7af 90f2               	bcc ddirflp		; ...loop always
  1285                          
  1286  c7b1 20e1ff             ddireol:jsr stop
  1287  c7b4 f008               	beq ddirend		; ...branch if user hit STOP
  1288  c7b6 a002               	ldy #2
  1289  c7b8 d0c8               	bne ddirlp		; ...loop always
  1290                          
  1291  c7ba c003               ddirdon:cpy #3			; checks if first dir byte is cr -> no device
  1292  c7bc f003               	beq ddirerr		; no device?
  1293  c7be 4c3cc7             ddirend:jmp dos30		; close
  1294  c7c1 4c39c7             ddirerr:jmp dos29		; -> error
  1295                          ; ******************************************** FONT ***********************************************
  1296                          ; font 256 chars
  1297                          !zone font
  1298                          *= font6x8
  1299                          font:
  1300  c800 1824545458201c00...!binary "c64-6x8.fon"
  1301                          ; **************************************** COLD START *********************************************
  1302                          !zone cold
  1303                          *= kernal
  1304  e000 4c09ef             jmoncld:jmp monoff		; Monitor cold start
  1305  e003 ea                 	nop
  1306                          ; ****************************************** EDITOR ***********************************************
  1307                          ;***************************************
  1308                          ;*                                     *
  1309                          ;* EEEEE DDD   IIIII TTTTT  OOO  RRRR  *
  1310                          ;* E     D  D    I     T   O   O R   R *
  1311                          ;* E     D   D   I     T   O   O R   R *
  1312                          ;* EEE   D   D   I     T   O   O RRRR  *
  1313                          ;* E     D   D   I     T   O   O R R   *
  1314                          ;* E     D  D    I     T   O   O R  R  *
  1315                          ;* EEEE  DDD   IIIII   T    OOO  R   R *
  1316                          ;*                                     *
  1317                          ;***************************************
  1318                          ;***************************************
  1319                          ;*   CBM EDITOR FOR P-SERIES SYSTEMS   *
  1320                          ;*   KEYBOARD AND SCREEN EDIT ROUTINES *
  1321                          ;* DRIVING THE HARDWARE OF THE         *
  1322                          ;* FOLLOWING MODEL : LC256             *
  1323                          ;* COPYRIGHT (C) 1983 BY CBM           *
  1324                          ;* COPYRIGHT (C) 2024 Vossi, Baleares  *
  1325                          ;***************************************
  1326                          !zone editor
  1327                          *= kernal+4
  1328                          ;****************************************
  1329                          ;  40/80 column LC256 screen editor
  1330                          ;    with unlimited screen line wrap
  1331                          ;****************************************
  1332                          ; Jump vector table
  1333  e004 4c39e0             jcint:  jmp cint		; Init Screen editor, VIC, F-keys
  1334  e007 4cd8e0             jlp2:	jmp lp2			; Read a key from keyboard to A
  1335  e00a 4c51e1             jloop5:	jmp loop5		; Read character from screen to A
  1336  e00d 4c4de3             jprt:	jmp prt			; Print character from A on screen
  1337  e010 4c34e0             jscror:	jmp scrorg		; Return screen dimensions to X, Y
  1338  e013 4c1ce9             jkey:	jmp scnkey		; Keyboard scan
  1339  e016 4c33e0             jmvcur: jmp nofunc		; not used in LC256/P500 - only for CRTC hardware cursor in b-series
  1340  e019 4c25e0             jplot:  jmp plot		; Get/set the cursor position to/from X, Y
  1341  e01c 4c33e0             jiobas:	jmp nofunc		; not used in LC256 - Return CIA base address to X, Y
  1342  e01f 4c33e0             jescrt:	jmp nofunc		; not used in LC256 - Handle an escape sequence
  1343  e022 4cd9e7             jfunky:	jmp keyfun		; Get/set/list function keys
  1344                          ; -------------------------------------------------------------------------------------------------
  1345                          ; Get/set the cursor position
  1346  e025 b008               plot:   bcs rdplt		; if C=1 get cursor position
  1347                          ; set cursor
  1348  e027 86d1               	stx tblx		; store line, last line 
  1349  e029 86d6               	stx lsxp
  1350  e02b 84d2               	sty pntr		; store column, last column
  1351  e02d 84d5               	sty lstp
  1352                          ;	jsr stupt		; Change pointer to this new line
  1353  e02f a6d1               rdplt:  ldx tblx
  1354  e031 a4d2               	ldy pntr		; load column, row
  1355  e033 60                 nofunc: rts
  1356                          ; -------------------------------------------------------------------------------------------------
  1357                          ; Return screen dimensions
  1358  e034 a6ec               scrorg: ldx columns		; columns
  1359  e036 a019               	ldy #nrows		; rows
  1360  e038 60                 	rts
  1361                          ; -------------------------------------------------------------------------------------------------
  1362                          ; Screen editor init (editor, VDP)
  1363                          ; Clear editor variables
  1364  e039 a900               cint:   lda #0
  1365  e03b a23e               	ldx #stack-keypnt-3	; $b8-$fd (prevents clearing $fe = allocated sprite_colors pointer)
  1366  e03d 95bf               cloop1: sta keypnt,x		; clear page 0 variables (above $f6 = allocated pgmkey buffer pt.)
  1367  e03f ca                 	dex
  1368  e040 10fb               	bpl cloop1
  1369                          
  1370  e042 a260               	ldx #evect-rvs-1	; $397-$3f7
  1371  e044 9d9703             cloop2: sta rvs,x		; clear absolute variables
  1372  e047 ca                 	dex
  1373  e048 10fa               	bpl cloop2
  1374                          ; init some variables
  1375  e04a a904               	lda #4
  1376  e04c 85de               	sta kount		; delay between key repeats
  1377  e04e a910               	lda #16
  1378  e050 85df               	sta delay		; initial key repeat delay
  1379  e052 86e3               	stx crson		; cursor off <> 0
  1380                          ; init sprite colors vector
  1381  e054 a5fe               	lda sprite_colors	; check if buffers are allocated
  1382  e056 05ff               	ora sprite_colors+1
  1383  e058 d011               	bne keybuf		; yes... skip
  1384  e05a a200               	ldx #0	
  1385  e05c a002               	ldy #2			; 2 pages
  1386  e05e 2045f8             	jsr alocat		; get 512 bytes at end of system memory
  1387  e061 b040               	bcs noroom		; no room found...just reset the screen
  1388  e063 e8                 	inx
  1389  e064 86fe               	stx sprite_colors	; save start address (returned .x+1)
  1390  e066 d001               	bne room00
  1391  e068 c8                 	iny
  1392  e069 84ff               room00:	sty sprite_colors+1
  1393                          ; init F-keys
  1394  e06b a5bd               keybuf:	lda pkybuf		; check if buffers are allocated
  1395  e06d 05be               	ora pkybuf+1
  1396  e06f d01d               	bne keycpy		; yes..just copy f-keys (erased with absolute vars)
  1397  e071 ad5403             	lda hiadr		; get end of key area
  1398  e074 8d8103             	sta pkyend
  1399  e077 ad5503             	lda hiadr+1
  1400  e07a 8d8203             	sta pkyend+1
  1401  e07d a200               	ldx #0	
  1402  e07f a001               	ldy #1			; 1 page
  1403  e081 2045f8             	jsr alocat		; get 256 bytes at end of system memory
  1404  e084 b01d               	bcs noroom		; no room found...just reset the screen
  1405  e086 e8                 	inx
  1406  e087 86bd               	stx pkybuf		; save start address (returned .x+1)
  1407  e089 d001               	bne room10
  1408  e08b c8                 	iny
  1409  e08c 84be               room10: sty pkybuf+1		; save start address
  1410  e08e a03a               keycpy: ldy #keyend-keydef	; load size of F-key texts
  1411  e090 b9d8eb             kyset1: lda keydef-1,y
  1412  e093 88                 	dey
  1413  e094 91bd               	sta (pkybuf),y		; copy key texts to buffer
  1414  e096 d0f8               	bne kyset1
  1415                          
  1416  e098 a008               	ldy #keydef-keylen	; 10 F-key length bytes
  1417  e09a b9d0eb             kyset2: lda keylen-1,y
  1418  e09d 998203             	sta keysiz-1,y		; copy F-key text length to $38d
  1419  e0a0 88                 	dey
  1420  e0a1 d0f7               	bne kyset2
  1421                          ; init VDP, screen
  1422                          noroom:
  1423  e0a3 203bec             	jsr vinit
  1424                          
  1425  e0a6 a918               	lda #<dokeyf		; copy function key vector
  1426  e0a8 8da803             	sta funvec
  1427  e0ab a9ea               	lda #>dokeyf+1
  1428  e0ad 8da903             	sta funvec+1
  1429                          
  1430  e0b0 a9e7               	lda #TEXTCOL
  1431  e0b2 85cf               	sta color		; init color
  1432                          ; Clear screen, cursor home
  1433  e0b4 205ced             clsr:	jsr vclear		; clear VDP screen and screen+color ram
  1434                          ; Cursor home
  1435  e0b7 a200               nxtd:   ldx #0			; move to top left
  1436  e0b9 86d1               	stx tblx
  1437  e0bb 86d2               	stx pntr
  1438  e0bd 86d6               	stx lsxp		; for input after home or clear
  1439  e0bf 86d5               	stx lstp
  1440                          ; Reset screen ptr to line begin
  1441  e0c1 a6d1               stupt:	ldx tblx		; get curent line index
  1442                          ; Set screen ptr to line X 
  1443  e0c3 bdc303             scrset: lda ldtb2,x		; load start of screen line low
  1444  e0c6 85c5               	sta pnt			; and store to screen, color RAM ptr
  1445  e0c8 bd5feb             	lda cldtb2,x		; load start of color line low
  1446  e0cb 85cb               	sta user
  1447  e0cd bdaa03             	lda ldtb1,x		; load high
  1448  e0d0 85c6               	sta pnt+1		; and store to char pointer
  1449  e0d2 bd78eb             	lda cldtb1,x		; load high
  1450  e0d5 85cc               	sta user+1		; and store to color pointer
  1451  e0d7 60                 	rts
  1452                          ; -------------------------------------------------------------------------------------------------
  1453                          ; *** Input routines ***
  1454                          ; Remove character from queue
  1455  e0d8 a6dd               lp2:  	ldx kyndx		; are there any pgm keys
  1456  e0da f00c               	beq lp3			; branch if not
  1457  e0dc ac9d03             	ldy keyidx		; get index to current char
  1458  e0df b1bf               	lda (keypnt),y		; get current byte
  1459  e0e1 c6dd               	dec kyndx		; 1 byte down
  1460  e0e3 ee9d03             	inc keyidx		; bump index to next char
  1461  e0e6 58                 	cli
  1462  e0e7 60                 	rts
  1463                          ; No F-key
  1464  e0e8 ac9f03             lp3: 	ldy keyd		; get key from irq buffer
  1465  e0eb a200               	ldx #0
  1466  e0ed bda003             lp1:  	lda keyd+1,x		; shift key buffer
  1467  e0f0 9d9f03             	sta keyd,x
  1468  e0f3 e8                 	inx
  1469  e0f4 e4d8               	cpx ndx			; shift till last key in buffer
  1470  e0f6 d0f5               	bne lp1
  1471  e0f8 c6d8               	dec ndx			; decrease key index
  1472  e0fa 98                 	tya			; return char in A
  1473  e0fb 58                 	cli
  1474  e0fc 60                 	rts
  1475                          ; -------------------------------------------------------------------------------------------------
  1476                          ; Screen input - Main loop
  1477  e0fd 204de3             loop4:	jsr prt			; print the character
  1478  e100 4c03e1             	jmp loop3
  1479                          ; wait for key input
  1480  e103 a5d8               loop3:  lda ndx			; check key and pgm-key index
  1481  e105 05dd               	ora kyndx
  1482  e107 85e3               	sta crson		; 0 = cursor on, off if index > 0
  1483  e109 f0f8               	beq loop3		; loop - wait for key input
  1484                          ; key available
  1485  e10b 78                 	sei			; disable interrupts
  1486  e10c a5ce               	lda crssw
  1487  e10e f00b               	beq lp21		; skip if cursor already switched off
  1488  e110 a5db               	lda config		; load char behind cursor
  1489  e112 a000               	ldy #0
  1490  e114 84ce               	sty crssw		; switch off cursor
  1491  e116 a6d0               	ldx gdcol		; load color behind cursor
  1492  e118 20eae1             	jsr dspp		; write char before cursor
  1493                          ; check key
  1494  e11b 20d8e0             lp21:	jsr lp2			; get key input
  1495  e11e c90d               	cmp #cr
  1496  e120 d0db               	bne loop4		; print char if not cr
  1497                          ; return recognized
  1498  e122 85d7               	sta crsw		; set cr flag - we pass chars now
  1499  e124 2099e6             	jsr fndend		; check nxt line for cont (double line?)
  1500  e127 8e9803             	stx lintmp		; save last line number of sentence
  1501  e12a 208be6             	jsr fistrt		; find begining of line
  1502  e12d a900               	lda #0
  1503  e12f 85da               	sta insrt		; clear insert flag *****
  1504  e131 85d9               	sta qtsw		; clear quote mode
  1505  e133 a000               	ldy #0			; retrieve from line start if left it
  1506  e135 a5d6               	lda lsxp		; input started row
  1507  e137 3013               	bmi lp80		; flag we left start line
  1508  e139 c5d1               	cmp tblx
  1509  e13b 900f               	bcc lp80
  1510  e13d a4d5               	ldy lstp		; input started column
  1511  e13f cd9803             	cmp lintmp		; on start line
  1512  e142 d004               	bne lp70
  1513  e144 c4dc               	cpy indx		; past start column
  1514  e146 f002               	beq lp75		; ok if the same
  1515  e148 b011               lp70:	bcs clp2		; yes - null input
  1516  e14a 85d1               lp75:	sta tblx		; start from here on input
  1517  e14c 84d2               lp80:	sty pntr
  1518  e14e 4c63e1             	jmp lop5		; input a line
  1519                          ; -------------------------------------------------------------------------------------------------
  1520                          ; Read character from screen
  1521  e151 98                 loop5:	tya
  1522  e152 48                 	pha
  1523  e153 8a                 	txa
  1524  e154 48                 	pha
  1525  e155 a5d7               	lda crsw		; passing chars to input
  1526  e157 f0aa               	beq loop3		; no - buffer on screen
  1527  e159 1008               	bpl lop5		; not done - get next char
  1528  e15b a900               clp2:	lda #0			; input done clear flag
  1529  e15d 85d7               	sta crsw
  1530  e15f a90d               	lda #cr			; pass a return
  1531  e161 d039               	bne clp7
  1532  e163 20c1e0             lop5:	jsr stupt		; set pnt and user
  1533  e166 2021e3             	jsr get1ch		; get a screen char
  1534                          ; convert screencode to petscii
  1535  e169 85e2               	sta data		; store screen code for bit#5,6,7 check temporary
  1536  e16b 293f               	and #$3f		; clear bit#6,7 in A
  1537  e16d 06e2               	asl data		; check: scrcode bit#7->C
  1538  e16f 24e2               	bit data		; check: scrcode bit#6->N, #5->V (shiftet to left)
  1539  e171 1002               	bpl lop54		; skip if scrcode #6=0 x0x -> 00x
  1540  e173 0980               	ora #$80		; x1x -> 10x
  1541  e175 9004               lop54:	bcc lop52		; skip if scrcode #7=0 (not reverse)
  1542  e177 a6d9               	ldx qtsw
  1543  e179 d004               	bne lop53		; skip if bit#7=1 & quote on: 10x -> 00x, 11x -> 10x
  1544                          				; if quote off or bit#7=0:
  1545  e17b 7002               lop52:	bvs lop53		; skip if scrcode #5=1: 001 -> 001, 011 -> 101
  1546  e17d 0940               	ora #$40		; 000 -> 010, 100 -> 110
  1547  e17f 20a5e1             lop53:	jsr qtswc
  1548  e182 a4d1               	ldy tblx		; on input end line ?
  1549  e184 cc9803             	cpy lintmp
  1550  e187 900a               	bcc clp00		; no
  1551  e189 a4d2               	ldy pntr		; on input end column ?
  1552  e18b c4dc               	cpy indx
  1553  e18d 9004               	bcc clp00		; no
  1554  e18f 66d7               	ror crsw		; c=1 minus flags last char sent
  1555  e191 3003               	bmi clp1		; always
  1556                          
  1557  e193 20c3e6             clp00:	jsr nxtchr		; at next char
  1558  e196 c9de               clp1:	cmp #$de		; a pi ?
  1559  e198 d002               	bne clp7		; no
  1560  e19a a999               	lda #PI			; translate
  1561  e19c 85e2               clp7:	sta data
  1562  e19e 68                 	pla
  1563  e19f aa                 	tax
  1564  e1a0 68                 	pla
  1565  e1a1 a8                 	tay
  1566  e1a2 a5e2               	lda data		; return petscii char in A
  1567  e1a4 60                 	rts
  1568                          ; -------------------------------------------------------------------------------------------------
  1569                          ; *** Test for quote mode ***
  1570                          ; Switch quote mode depending on in A
  1571  e1a5 c922               qtswc:	cmp #$22 ; "
  1572  e1a7 d008               	bne qtswl		; skip if no quote-char
  1573  e1a9 a5d9               	lda qtsw
  1574  e1ab 4901               	eor #$1			; toggle quoteswitch
  1575  e1ad 85d9               	sta qtsw
  1576  e1af a922               	lda #$22 ; "		; restore quote in A
  1577  e1b1 60                 qtswl:	rts
  1578                          ; -------------------------------------------------------------------------------------------------
  1579                          ; *** Output chars ***
  1580  e1b2 2c9703             nxt3:	bit rvs
  1581  e1b5 1002               	bpl nvs
  1582  e1b7 0980               	ora #$80
  1583  e1b9 a6da               nvs:	ldx insrt
  1584  e1bb f002               	beq nvsa
  1585  e1bd c6da               	dec insrt
  1586  e1bf 2c9a03             nvsa:	bit insflg		; are we in auto insert mode?
  1587  e1c2 1006               	bpl nvs1		; branch if not
  1588  e1c4 48                 	pha			; save the char
  1589                          ;	jsr insert		; make room for this char
  1590  e1c5 a200               	ldx #0
  1591  e1c7 86da               	stx insrt		; make sure we turn off insert mode.
  1592  e1c9 68                 	pla			; restore char
  1593  e1ca 20e3e1             nvs1:	jsr dsppcc		; display the character
  1594  e1cd 207de7             	jsr movchr		; move to next char pos
  1595                          ; -------------------------------------------------------------------------------------------------
  1596                          ; ********* exit from prt *********
  1597  e1d0 a5e2               loop2:	lda data		; copy last char
  1598  e1d2 8d9903             	sta lstchr
  1599  e1d5 68                 	pla
  1600  e1d6 a8                 	tay
  1601  e1d7 a5da               	lda insrt
  1602  e1d9 f002               	beq lop2
  1603  e1db 46d9               	lsr qtsw		; clear quote switch if in insert mode
  1604  e1dd 68                 lop2:	pla
  1605  e1de aa                 	tax
  1606  e1df 68                 	pla
  1607  e1e0 60                 	rts
  1608                          ; -------------------------------------------------------------------------------------------------
  1609                          ;********************************
  1610                          ; Display a character
  1611                          ;********************************
  1612                          ; Write blank ($20) at cusor position
  1613  e1e1 a920               doblnk: lda #' '		; load blank
  1614                          ; Write char A with color or tcolor if color bit#7=1
  1615  e1e3 a6cf               dsppcc: ldx color		; load char color
  1616  e1e5 4ceae1             	jmp dspp
  1617                          ; Write char A with tcolor
  1618  e1e8 a6cd               dsptco: ldx tcolor
  1619                          ; Write char A with color X
  1620  e1ea a4d2               dspp:   ldy pntr		; get char index
  1621  e1ec 91c5               	sta (pnt),y		; store byte to screen line pointer + column x
  1622  e1ee 48                 	pha
  1623  e1ef 24ea               	bit mode
  1624  e1f1 100a               	bpl dspmod6		; -> mode 6, 16 colors
  1625                          ; mode7
  1626  e1f3 8a                 	txa			; move color to A
  1627  e1f4 91cb               	sta (user),y		; store to color RAM
  1628  e1f6 68                 	pla
  1629  e1f7 20d1ed             	jsr vchar		; print char on VDP
  1630  e1fa a4d2               	ldy pntr		; restore y
  1631  e1fc 60                 	rts
  1632                          ; mode6
  1633  e1fd 98                 dspmod6:tya			; column in y
  1634  e1fe 4a                 	lsr			; bit #0 in c, column / 2
  1635  e1ff b017               	bcs dspodd		; -> odd char
  1636                          ; even char - color in high nibble
  1637  e201 a8                 	tay
  1638  e202 8a                 	txa			; get color
  1639  e203 0a                 	asl			; shift to high nibble
  1640  e204 0a                 	asl
  1641  e205 0a                 	asl
  1642  e206 0a                 	asl
  1643  e207 85f0               	sta temp1		; remember color
  1644  e209 a90f               	lda #$0f
  1645  e20b 31cb               	and (user),y		; get color low nibble
  1646  e20d 05f0               	ora temp1		; add color high nibble
  1647  e20f 91cb               	sta (user),y
  1648  e211 68                 	pla
  1649  e212 20d1ed             	jsr vchar		; print char on VDP
  1650  e215 a4d2               	ldy pntr		; restore y
  1651  e217 60                 	rts
  1652                          ; odd  char - color in low nibble
  1653  e218 86f0               dspodd:	stx temp1		; remember color
  1654  e21a a8                 	tay
  1655  e21b a9f0               	lda #$f0
  1656  e21d 31cb               	and (user),y		; get color high nibble
  1657  e21f 05f0               	ora temp1		; add color low nibble
  1658  e221 91cb               	sta (user),y
  1659  e223 68                 	pla
  1660  e224 20d1ed             	jsr vchar		; print char on VDP
  1661  e227 a4d2               	ldy pntr		; restore y
  1662  e229 60                 	rts
  1663                          ; -------------------------------------------------------------------------------------------------
  1664                          ; Subroutine to clear line
  1665                          ;   entry: line in x, screen pointer to line
  1666  e22a 2058e6             clrln:	jsr clrbit		; make sure non-continued line
  1667                          
  1668  e22d 8a                 	txa			; line to a
  1669  e22e 0a                 	asl			; *8 (FONTH) for y-position
  1670  e22f 0a                 	asl
  1671  e230 0a                 	asl
  1672  e231 85f5               	sta dy			; y position
  1673  e233 a908               	lda #FONTH
  1674  e235 85f0               	sta temp1		; line height
  1675                          ;	lda sizex		; screen width
  1676                          ;	sta dx
  1677                          ;	lda sizex+1
  1678                          ;	sta dx+1
  1679  e237 24ea               	bit mode
  1680  e239 300a               	bmi clrm7
  1681  e23b a901               	lda #>(FONTW*COLUMNS6)
  1682  e23d 85fd               	sta dx+1
  1683  e23f a9e0               	lda #<(FONTW*COLUMNS6)	; text area width in pixels
  1684  e241 85fc               	sta dx
  1685  e243 d008               	bne clr00
  1686  e245 a900               clrm7:	lda #>(FONTW*COLUMNS7)	; text area width in pixels
  1687  e247 85fd               	sta dx+1
  1688  e249 a9f0               	lda #<(FONTW*COLUMNS7)
  1689  e24b 85fc               	sta dx
  1690                          
  1691  e24d a9208d01dca9918d...clr00:	+VdpCommand zero, zero, zero, zero, zero, dy, dx, dx+1, temp1, bgcolor_del, zero, HMMV
  1692                          
  1693  e2b8 a920               	lda #' '		; load blank
  1694  e2ba a4ed               	ldy scxmax		; last column
  1695  e2bc 91c5               clr10:	sta (pnt),y		; store byte to screen line pointer + column x
  1696  e2be 88                 	dey
  1697  e2bf 10fb               	bpl clr10		; next char till whole line done
  1698                          
  1699  e2c1 a5cf               	lda color		; load char color
  1700  e2c3 24ea               	bit mode
  1701  e2c5 3008               	bmi clr20		; -> skip mode7
  1702                          ; mode 6
  1703  e2c7 0a                 	asl			; shift color to left nibble
  1704  e2c8 0a                 	asl
  1705  e2c9 0a                 	asl
  1706  e2ca 0a                 	asl
  1707  e2cb 05cf               	ora color		; and add color to low nibble
  1708                          
  1709  e2cd a027               	ldy #collen-1		; color line end
  1710  e2cf 91cb               clr20:	sta (user),y		; store color
  1711  e2d1 88                 	dey
  1712  e2d2 10fb               	bpl clr20		; next char till whole line done
  1713                          
  1714  e2d4 4c8bee             	jmp waitcmd		; wait for command execution
  1715                          ; -------------------------------------------------------------------------------------------------
  1716                          ; Clear screen ram
  1717  e2d7 a218               clrscr:	ldx #scymax
  1718  e2d9 2058e6             clsbtlp:jsr clrbit		; make sure non-continued line
  1719  e2dc ca                 	dex
  1720  e2dd 10fa               	bpl clsbtlp
  1721                          
  1722  e2df a920               	lda #' '
  1723  e2e1 a200               	ldx #0
  1724  e2e3 9d00d0             clsr6lp:sta scnram,x
  1725  e2e6 9d00d1             	sta scnram+$100,x
  1726  e2e9 9d00d2             	sta scnram+$200,x
  1727  e2ec 9d00d3             	sta scnram+$300,x
  1728  e2ef e8                 	inx
  1729  e2f0 d0f1               	bne clsr6lp
  1730                          
  1731  e2f2 24ea               	bit mode
  1732  e2f4 300f               	bmi clsmod7		; -> skip mode7
  1733  e2f6 9d00d4             clsr7lp:sta scnram+$400,x
  1734  e2f9 9d00d5             	sta scnram+$500,x
  1735  e2fc 9d00d6             	sta scnram+$600,x
  1736  e2ff 9d00d7             	sta scnram+$700,x
  1737  e302 e8                 	inx
  1738  e303 d0f1               	bne clsr7lp
  1739                          
  1740  e305 a5cf               clsmod7:lda color		; load char color
  1741  e307 24ea               	bit mode
  1742  e309 3006               	bmi clscolp		; -> skip mode7
  1743                          ; mode 6
  1744  e30b 0a                 	asl			; shift color to left nibble
  1745  e30c 0a                 	asl
  1746  e30d 0a                 	asl
  1747  e30e 0a                 	asl
  1748  e30f 05cf               	ora color		; and add color to low nibble
  1749                          
  1750  e311 9d00d8             clscolp:sta clrram,x
  1751  e314 9d00d9             	sta clrram+$100,x
  1752  e317 9d00da             	sta clrram+$200,x
  1753  e31a 9d00db             	sta clrram+$300,x
  1754  e31d e8                 	inx
  1755  e31e d0f1               	bne clscolp
  1756  e320 60                 	rts
  1757                          ; -------------------------------------------------------------------------------------------------
  1758                          ; Grab a character from screen
  1759  e321 a4d2               get1ch: ldy pntr		; get char/color index
  1760                          ; Get char from column Y
  1761  e323 b1c5               getych: lda (pnt),y		; get the character
  1762  e325 48                 	pha
  1763  e326 24ea               	bit mode
  1764  e328 1006               	bpl getmod6		; -> mode 6, 16 colors
  1765                          ; mode7
  1766  e32a b1cb               	lda (user),y		; get color
  1767  e32c 85cd               	sta tcolor		; and store it to tcolor
  1768  e32e 68                 	pla
  1769  e32f 60                 	rts
  1770                          ; mode6
  1771  e330 98                 getmod6:tya
  1772  e331 48                 	pha
  1773  e332 4a                 	lsr			; column/2, bit #0 in c
  1774  e333 b00d               	bcs getodd		; -> odd char
  1775                          ; even char - color in high nibble
  1776  e335 a8                 	tay
  1777  e336 b1cb               	lda (user),y		; get color
  1778  e338 4a                 	lsr			; shift to low nibble
  1779  e339 4a                 	lsr
  1780  e33a 4a                 	lsr
  1781  e33b 4a                 	lsr
  1782  e33c 85cd               	sta tcolor
  1783  e33e 68                 	pla
  1784  e33f a8                 	tay
  1785  e340 68                 	pla
  1786  e341 60                 	rts
  1787                          ; odd  char - color in low nibble
  1788  e342 a8                 getodd:	tay
  1789  e343 b1cb               	lda (user),y		; get color
  1790  e345 290f               	and #$0f		; isolate high nibble
  1791  e347 85cd               	sta tcolor
  1792  e349 68                 	pla
  1793  e34a a8                 	tay
  1794  e34b 68                 	pla
  1795  e34c 60                 	rts
  1796                          ; -------------------------------------------------------------------------------------------------
  1797                          ; *** Print a char ***
  1798  e34d 48                 prt:	pha
  1799  e34e 85e2               prt10:	sta data		; save char
  1800  e350 8a                 	txa			; save regs
  1801  e351 48                 	pha
  1802  e352 98                 	tya
  1803  e353 48                 	pha
  1804  e354 a900               	lda #0			; clear cr flag
  1805  e356 85d7               	sta crsw
  1806  e358 a4d2               	ldy pntr		; column we are in
  1807  e35a a5e2               	lda data
  1808  e35c 297f               	and #$7f
  1809  e35e c920               	cmp #$20		; test if control character (< $20)
  1810  e360 900e               	bcc ntcn		; yes
  1811  e362 293f               njt2:	and #$3f		; no - make a screen char
  1812  e364 24e2               njt20:	bit data
  1813  e366 1002               	bpl njt30		; skip ahead if normal set - 00 - 3f
  1814  e368 0940               	ora #$40		; convert a0 - bf to 60 - 7f & c0 - df to 40 - 5f
  1815  e36a 20a5e1             njt30:	jsr qtswc		; test for quote
  1816  e36d 4cb2e1             	jmp nxt3		; put on screen
  1817                          ; ********* Control keys *********
  1818  e370 c90d               ntcn:	cmp #$0d		; test if a return
  1819  e372 f029               	beq ntcn20		; no inverse if yes
  1820  e374 c914               	cmp #$14		; test if insert or delete
  1821  e376 f025               	beq ntcn20		; allow in insert or quote mode
  1822  e378 c91b               	cmp #$1b		; test if escape key
  1823  e37a d011               	bne ntcn1
  1824  e37c 24e2               	bit data
  1825  e37e 300d               	bmi ntcn1		; its a $9b
  1826  e380 a5d9               	lda qtsw		; test if in quote mode...
  1827  e382 05da               	ora insrt		; ...or insert mode
  1828  e384 f017               	beq ntcn20		; if not, go execute remaining code
  1829  e386 20c8e7             	jsr toqm		; else go turn off all modes
  1830  e389 85e2               	sta data		; and forget about this character
  1831  e38b f010               	beq ntcn20		; always
  1832  e38d c903               ntcn1	cmp #$03		; test if a run/load or stop
  1833  e38f f00c               	beq ntcn20		; no inverse if yes
  1834  e391 a4da               	ldy insrt		; test if in insert mode
  1835  e393 d004               	bne ntcn10		; go reverse - if yes
  1836  e395 a4d9               	ldy qtsw		; check for quote mode
  1837  e397 f004               	beq ntcn20		; do not reverse if not
  1838  e399 0980               ntcn10:	ora #$80		; make reverse
  1839  e39b d0c7               	bne njt20
  1840  e39d a5e2               ntcn20:	lda data
  1841  e39f 0a                 	asl			; set carry if shifted ctrl
  1842  e3a0 aa                 	tax
  1843  e3a1 20a7e3             	jsr ctdsp		; indirect jsr
  1844  e3a4 4cd0e1             	jmp loop2
  1845                          ; Control code dispatcher
  1846  e3a7 bd92eb             ctdsp:	lda ctable+1,x		; hi byte
  1847  e3aa 48                 	pha
  1848  e3ab bd91eb             	lda ctable,x		; low byte
  1849  e3ae 48                 	pha
  1850  e3af a5e2               	lda data
  1851  e3b1 60                 	rts			; indirect jmp
  1852                          ; -------------------------------------------------------------------------------------------------
  1853                          ; User control code jump vector
  1854  e3b2 6c2203             cuser:	jmp (ctlvec)
  1855                          ; -------------------------------------------------------------------------------------------------
  1856                          ; Cursor down/up
  1857  e3b5 b00d               cdnup:  bcs cup			; cursor up
  1858                          ; cursor down
  1859  e3b7 20f8e3             cdwn:	jsr nxln
  1860  e3ba 2048e6             cdn10:	jsr getbit		; a wrapped line ?
  1861  e3bd b003               	bcs cdrts		; skip if yes
  1862  e3bf 38                 	sec			; flag we left line
  1863  e3c0 66d6               	ror lsxp
  1864                          
  1865  e3c2 18                 cdrts:  clc
  1866  e3c3 60                 	rts
  1867                          ; Cursor up
  1868  e3c4 a200               cup:	ldx #0			; cursor up
  1869  e3c6 e4d1               	cpx tblx		; at top of window ?
  1870  e3c8 b00f               	bcs critgo		; yes - do nothing
  1871  e3ca 20bae3             cup10:	jsr cdn10		; about to wrap to a new line ?
  1872  e3cd c6d1               	dec tblx		; up a line
  1873  e3cf 4cc1e0             	jmp stupt
  1874                          ; -------------------------------------------------------------------------------------------------
  1875                          ; Cursor right/left
  1876  e3d2 b006               crtlf:  bcs cleft		; cursor left
  1877                          ; cursor right
  1878  e3d4 20c3e6             crit:	jsr nxtchr		; cursor right
  1879  e3d7 b0e1               	bcs cdn10		; yes - test for wrap
  1880                          
  1881  e3d9 60                 critgo: rts
  1882                          ; Cursor left
  1883  e3da 20d6e6             cleft:  jsr bakchr		; move back
  1884  e3dd b0fa               	bcs critgo		; abort if at top left
  1885  e3df d0e1               	bne cdrts		; no - exit
  1886  e3e1 e6d1               	inc tblx
  1887  e3e3 d0e5               	bne cup10		; go set flag if needed
  1888                          ; -------------------------------------------------------------------------------------------------
  1889                          ; RVS on/off
  1890  e3e5 4980               rvsf:   eor #$80
  1891  e3e7 8d9703             	sta rvs
  1892  e3ea 60                 	rts
  1893                          ; -------------------------------------------------------------------------------------------------
  1894                          ; Home/clear
  1895  e3eb 9003               homclr:	bcc homes		; if C=0 home
  1896  e3ed 4cb4e0             	jmp clsr		; Clear screen, cursor home
  1897                          ; Cursor home
  1898  e3f0 cd9903             homes:	cmp lstchr		; last char a home ?
  1899  e3f3 d000               	bne hm110		; no
  1900  e3f5 4cb7e0             hm110:  jmp nxtd		; set to top left
  1901                          ; -------------------------------------------------------------------------------------------------
  1902                          ; Skip to next line
  1903                          ;   wrap to top if scroll disabled
  1904  e3f8 a6d1               nxln:	ldx tblx
  1905  e3fa e018               	cpx #scymax		; of the bottom of window ?
  1906  e3fc 9012               	bcc nxln1		; no
  1907  e3fe 2c9b03             	bit scrdis		; what if scrolling is disabled?
  1908  e401 1009               	bpl doscrl		; branch if scroll is enabled
  1909  e403 a900               	lda #0			; wrap to top
  1910  e405 85d1               	sta tblx
  1911  e407 2018e6             	jsr scrkey		; check commodore and stop key
  1912  e40a b006               	bcs nowhop		; always
  1913                          
  1914  e40c 20cce5             doscrl:	jsr scrup		; scroll it all
  1915  e40f 18                 	clc			; indicate scroll ok
  1916  e410 e6d1               nxln1:	inc tblx
  1917  e412 4cc1e0             nowhop:	jmp stupt		; set line base adr
  1918                          ; -------------------------------------------------------------------------------------------------
  1919                          ; A return or shift return
  1920  e415 2099e6             nxt1:   jsr fndend		; find the end of the current line
  1921  e418 e8                 	inx
  1922  e419 2058e6             	jsr clrbit		; set next line as non-continued
  1923  e41c a000               	ldy #0			; else point to start of next line
  1924  e41e 84d2               	sty pntr
  1925  e420 20f8e3             	jsr nxln		; set up next line
  1926  e423 4cc8e7             	jmp toqm		; turn off all modes
  1927                          ; -------------------------------------------------------------------------------------------------
  1928                          ; ****** scroll routines ******
  1929                          ; Move one line (only used space and clears the rest of target line) - line x to pnt (y for VDP)
  1930                          ;   preserves x
  1931  e426 8a                 movlin:	txa			; source line to a
  1932  e427 0a                 	asl			; *8 (FONTH) for y-position
  1933  e428 0a                 	asl
  1934  e429 0a                 	asl
  1935  e42a 85f0               	sta temp1		; source start
  1936  e42c 98                 	tya			; target line to a
  1937  e42d 0a                 	asl			; *8 (FONTH) for y-position
  1938  e42e 0a                 	asl
  1939  e42f 0a                 	asl
  1940  e430 85f1               	sta temp2		; target start
  1941  e432 a908               	lda #FONTH
  1942  e434 85f5               	sta dy			; line height
  1943                          
  1944  e436 bdc303             	lda ldtb2,x		; set pointer to source line address lo
  1945  e439 85c1               	sta sedsal
  1946  e43b bdaa03             	lda ldtb1,x
  1947  e43e 85c2               	sta sedsal+1		; set pointer hi to vram
  1948                          
  1949                          ; search last used char in source line
  1950  e440 a4ed               	ldy scxmax		; start at right		
  1951  e442 b1c1               movls0:	lda (sedsal),y
  1952  e444 c920               	cmp #' '		; space ?
  1953  e446 d00c               	bne movls1		; no... -> copy line
  1954  e448 88                 	dey
  1955  e449 10f7               	bpl movls0		; test next char
  1956  e44b a900               	lda #0
  1957  e44d 85fa               	sta x1
  1958  e44f 85fb               	sta x1+1
  1959  e451 4cdde4             	jmp movlt		; empty line -> nothing to copy
  1960                          ; y holds last used char in source line
  1961  e454 c8                 movls1:	iny			; include last used char
  1962  e455 a900               	lda #0
  1963  e457 85fb               	sta x1+1
  1964                          ; calc column *6 for pixel pos
  1965  e459 98                 	tya
  1966  e45a 0a                 	asl			; *4
  1967  e45b 0a                 	asl
  1968  e45c 26fb               	rol x1+1
  1969  e45e 85fa               	sta x1
  1970  e460 98                 	tya
  1971  e461 0a                 	asl			; *2
  1972  e462 18                 	clc
  1973  e463 65fa               	adc x1			; add to get *6
  1974  e465 85fa               	sta x1			; store source line end pixel lo
  1975  e467 a5fb               	lda x1+1
  1976  e469 6900               	adc #0
  1977  e46b 85fb               	sta x1+1
  1978                          
  1979  e46d a904               	lda #$04		; copy from the left edge to x1
  1980  e46f 8d8c03             	sta arg
  1981                          
  1982  e472 a9208d01dca9918d...	+VdpCommand zero, zero, temp1, x1, x1+1, temp2, zero, zero, dy, zero, arg, YMMM
  1983                          
  1984                          ; search last used char in target line
  1985  e4dd a4ed               movlt:	ldy scxmax		; start at right		
  1986  e4df b1c5               movlt0:	lda (pnt),y
  1987  e4e1 c920               	cmp #' '		; space ?
  1988  e4e3 d003               	bne movlt1		; no... -> found end of chars in target line
  1989  e4e5 88                 	dey
  1990  e4e6 10f7               	bpl movlt0		; test next char
  1991                          ; y holds last used char target in line
  1992  e4e8 c8                 movlt1:	iny			; include last used char
  1993  e4e9 a900               	lda #0
  1994  e4eb 85fd               	sta dx+1
  1995                          ; calc column *6 for pixel pos
  1996  e4ed 98                 	tya
  1997  e4ee 0a                 	asl			; *4
  1998  e4ef 0a                 	asl
  1999  e4f0 26fd               	rol dx+1
  2000  e4f2 85fc               	sta dx
  2001  e4f4 98                 	tya
  2002  e4f5 0a                 	asl			; *2
  2003  e4f6 18                 	clc
  2004  e4f7 65fc               	adc dx			; add to get *6
  2005  e4f9 85fc               	sta dx			; store target end pixel lo
  2006  e4fb a5fd               	lda dx+1
  2007  e4fd 6900               	adc #0
  2008  e4ff 85fd               	sta dx+1
  2009                          
  2010                          ; copy line in screen ram
  2011  e501 a4ed               	ldy scxmax		
  2012  e503 b1c1               movl10: lda (sedsal),y
  2013  e505 91c5               	sta (pnt),y		; store byte to screen line pointer + coulmn X
  2014  e507 88                 	dey
  2015  e508 10f9               	bpl movl10		; next char till whole line done
  2016                          ; color
  2017  e50a bd5feb             	lda cldtb2,x		; set pointer to line address lo
  2018  e50d 85c1               	sta sedsal
  2019  e50f bd78eb             	lda cldtb1,x
  2020  e512 85c2               	sta sedsal+1		; set pointer hi to color ram
  2021                          
  2022  e514 a027               	ldy #collen-1		
  2023  e516 b1c1               movl20: lda (sedsal),y
  2024  e518 91cb               	sta (user),y		; store to color RAM
  2025  e51a 88                 	dey
  2026  e51b 10f9               	bpl movl20		; next char till whole line done
  2027                          
  2028                          ; calc diff from source end to target end (line to overwrite)
  2029  e51d a5fc               	lda dx			; target end
  2030  e51f 38                 	sec
  2031  e520 e5fa               	sbc x1			; substract source end
  2032  e522 85fc               	sta dx			; store diff (width to delete)
  2033  e524 a5fd               	lda dx+1
  2034  e526 e5fb               	sbc x1+1
  2035  e528 85fd               	sta dx+1
  2036  e52a 3074               	bmi movlx		; target line is shorter than source line - nothing to delete there
  2037  e52c d004               	bne movlt2		; hi <> o -> clear diff
  2038  e52e a5fc               	lda dx
  2039  e530 f06e               	beq movlx		; lo = 0 -> no diff - nothing to clear
  2040                          
  2041  e532 208bee             movlt2:	jsr waitcmd
  2042                          ; delete the part from new line to old line end
  2043  e535 a9208d01dca9918d...	+VdpCommand zero, zero, zero, x1, x1+1, temp2, dx, dx+1, dy, bgcolor_del, zero, HMMV
  2044                          
  2045  e5a0 4c8bee             movlx:	jmp waitcmd		; wait for command execution
  2046                          ; -------------------------------------------------------------------------------------------------
  2047                          ; ****** Scroll down ******
  2048  e5a3 a6d6               scrdwn: ldx lsxp
  2049  e5a5 3006               	bmi scd30		; skip if new line flag already set
  2050  e5a7 e4d1               	cpx tblx
  2051  e5a9 9002               	bcc scd30		; skip if old line is below scroll area
  2052  e5ab e6d6               	inc lsxp		; else inc start line number
  2053  e5ad a218               scd30:  ldx #scymax		; scroll down, start bottom
  2054                          
  2055  e5af 20c3e0             scd10:  jsr scrset		; set pnt to line
  2056  e5b2 e4d1               	cpx tblx		; test if at destination line
  2057  e5b4 f010               	beq scd20		; done if yes
  2058  e5b6 8a                 	txa			; move target line to y
  2059  e5b7 a8                 	tay
  2060  e5b8 ca                 	dex			; point to previous line as source
  2061  e5b9 204ae6             	jsr getbt1
  2062  e5bc e8                 	inx
  2063  e5bd 2056e6             	jsr putbt1		; move continuation byte
  2064  e5c0 ca                 	dex
  2065  e5c1 2026e4             	jsr movlin		; move one line
  2066  e5c4 90e9               	bcc scd10		; always
  2067                          
  2068  e5c6 202ae2             scd20:	jsr clrln		; set line to blanks
  2069  e5c9 4c65e6             	jmp setbit		; mark as continuation line
  2070                          ; -------------------------------------------------------------------------------------------------
  2071                          ; ****** Scroll up ******
  2072  e5cc a200               scrup:  ldx #0
  2073  e5ce e8                 scru00: inx
  2074  e5cf 204ae6             	jsr getbt1		; find first non-continued line
  2075  e5d2 900a               	bcc scru15
  2076  e5d4 e018               	cpx #scymax		; is entire screen 1 line?
  2077  e5d6 90f6               	bcc scru00		; do normal scroll if not
  2078                          
  2079  e5d8 a200               	ldx #0
  2080  e5da e8                 	inx
  2081  e5db 2058e6             	jsr clrbit		; clear to only scroll 1 line
  2082                          
  2083  e5de c6d1               scru15:	dec tblx
  2084  e5e0 24d6               	bit lsxp
  2085  e5e2 3002               	bmi scru20		; no change if already new line
  2086  e5e4 c6d6               	dec lsxp		; move input up one
  2087  e5e6 a200               scru20:	ldx #0
  2088  e5e8 e4e1               	cpx sedt2
  2089  e5ea b002               	bcs scru30
  2090  e5ec c6e1               	dec sedt2		; in case doing insert
  2091  e5ee 20fee5             scru30:	jsr scr10		; scroll
  2092  e5f1 a200               	ldx #0
  2093  e5f3 204ae6             	jsr getbt1
  2094  e5f6 08                 	php
  2095  e5f7 2058e6             	jsr clrbit		; make sure top line is not continuation
  2096  e5fa 28                 	plp
  2097  e5fb 9000               	bcc scru10		; done if top line off
  2098  e5fd 60                 scru10: rts
  2099                          
  2100  e5fe 20c3e0             scr10:	jsr scrset		; point to start of line
  2101  e601 e018               	cpx #scymax		; at last line ?
  2102  e603 b010               	bcs scr40		; yes
  2103  e605 8a                 	txa			; move target line to y
  2104  e606 a8                 	tay
  2105  e607 e8                 	inx			; point to next line
  2106  e608 204ae6             	jsr getbt1
  2107  e60b ca                 	dex
  2108  e60c 2056e6             	jsr putbt1		; move continuation byte
  2109  e60f e8                 	inx
  2110  e610 2026e4             	jsr movlin		; move one line (only used space)
  2111  e613 90e9               	bcc scr10		; always
  2112  e615 202ae2             scr40:  jsr clrln		; make last line blank
  2113                          ; Scroll stop
  2114  e618 a27f               scrkey:	ldx #$7f		; allow only output line 7
  2115  e61a 2039e6             	jsr getlin		; get input lines key
  2116  e61d 2920               	and #$20		; check for the commodore key
  2117  e61f d017               	bne scr75		; exit if not - no stop scroll
  2118                          
  2119  e621 2039e6             scr90:	jsr getlin		; get input lines
  2120  e624 2920               	and #$20		; check for the commodore key
  2121  e626 f0f9               	beq scr90		; wait until com.key not depressed
  2122                          
  2123  e628 a200               scr95:	ldx #0			; allow all output lines
  2124  e62a 2039e6             	jsr getlin		; get inputs
  2125  e62d 49ff               	eor #$ff		; check for any input
  2126  e62f f0f7               	beq scr95		; wait
  2127  e631 86d8               	stx ndx
  2128  e633 a27f               	ldx #$7f		; setup pa7 default output
  2129  e635 8e0fde             	stx via1+pra		; default key row
  2130  e638 60                 scr75:	rts
  2131                          ; Keyboard check for stop
  2132  e639 08                 getlin: php			; preserve the irq flag
  2133  e63a 78                 	sei
  2134  e63b 8e0fde             	stx via1+pra		; set keyboard column output
  2135  e63e ad00de             getl10:	lda via1+prb		; get row
  2136  e641 cd00de             	cmp via1+prb		; debounce keyboard
  2137  e644 d0f8               	bne getl10
  2138  e646 28                 	plp
  2139  e647 60                 	rts
  2140                          ; -------------------------------------------------------------------------------------------------
  2141                          ; ****** wrap table subroutines *******
  2142                          ; Check for a double length line
  2143  e648 a6d1               getbit: ldx tblx		; load current line
  2144                          ; Check line X for double length
  2145  e64a 2071e6             getbt1: jsr bitpos		; get byte & bit positions
  2146  e64d 35c7               	and bitabl,x		; check if bit for line is set in table
  2147  e64f c901               	cmp #1			; make carry clear if zero
  2148  e651 4c61e6             	jmp bitout		; return 0 if not a double length line
  2149                          ; -------------------------------------------------------------------------------------------------
  2150                          ; Mark current line as double length C=1, unmark C=0
  2151                          ; putbit - set bit according to carry
  2152  e654 a6d1               putbit: ldx tblx		; load current line
  2153                          ; Mark line X
  2154  e656 b00d               putbt1: bcs setbit		; go if to mark as wrappped line
  2155                          ; clrbit - clear wrap bit
  2156  e658 2071e6             clrbit: jsr bitpos		; get byte & bit positions
  2157  e65b 49ff               	eor #$ff		; invert bit position
  2158  e65d 35c7               	and bitabl,x		; clear bit
  2159  e65f 95c7               bitsav: sta bitabl,x		; and store it to table at byte position X
  2160  e661 ae9c03             bitout: ldx bitmsk		; move byte table position to X
  2161  e664 60                 	rts
  2162                          ; setbit  -  set bit to mark as wrapped line
  2163  e665 2c9b03             setbit: bit scrdis		; auto line link disable...
  2164  e668 70e0               	bvs getbt1		; branch if scrolling is disabled
  2165  e66a 2071e6             	jsr bitpos		; get byte & bit position
  2166  e66d 15c7               	ora bitabl,x		; set wrap bit
  2167  e66f d0ee               	bne bitsav		; always
  2168                          ; Find bit table position for line X
  2169  e671 8e9c03             bitpos: stx bitmsk		; remember line
  2170  e674 8a                 	txa
  2171  e675 2907               	and #$07		; get bit position
  2172  e677 aa                 	tax
  2173  e678 bd13ec             	lda bits,x		; get bit mask
  2174  e67b 48                 	pha			; remember it
  2175  e67c ad9c03             	lda bitmsk
  2176  e67f 4a                 	lsr
  2177  e680 4a                 	lsr			; shift to get byte position (/8)
  2178  e681 4a                 	lsr
  2179  e682 aa                 	tax			; move byte pos to X
  2180  e683 68                 	pla			; return bit value in A
  2181  e684 60                 	rts
  2182                          ; -------------------------------------------------------------------------------------------------
  2183                          ; ****** Move to start of line
  2184                          ; Find line start/end
  2185  e685 9012               	bcc fndend		; if C=0 find line end - NOT USED
  2186                          ; cursor to line start
  2187  e687 a000               fndfst:	ldy #0
  2188  e689 84d2               	sty pntr		; set to leftmost column
  2189  e68b 2048e6             fistrt:	jsr getbit		; find start of current line
  2190  e68e 9006               	bcc fnd0		; branch if found
  2191  e690 c6d1               	dec tblx		; up a line
  2192  e692 10f7               	bpl fistrt		; always
  2193  e694 e6d1               	inc tblx		; whoops went too far
  2194  e696 4cc1e0             fnd0:	jmp stupt		; set line base adr
  2195                          
  2196                          ; -------------------------------------------------------------------------------------------------
  2197                          ; ****** Find last non-blank char of line
  2198                          ;   pntr= column #
  2199                          ;   tblx= line #
  2200                          ; cursor to end of line
  2201  e699 e6d1               fndend:	inc tblx
  2202  e69b 2048e6             	jsr getbit		; is this line continued
  2203  e69e b0f9               	bcs fndend		; branch if so
  2204  e6a0 c6d1               	dec tblx		; found it - compensate for inc tblx
  2205  e6a2 20c1e0             	jsr stupt		; reset screen pointer to line start
  2206  e6a5 a4ed               	ldy scxmax		; get right margin
  2207  e6a7 84d2               	sty pntr		; point to right margin
  2208  e6a9 1005               	bpl eloup2		; always
  2209  e6ab 20d6e6             eloup1:	jsr bakchr		; backup one char
  2210  e6ae b010               	bcs endbye		; if at top left get out
  2211  e6b0 2021e3             eloup2: jsr get1ch		; get char from screen
  2212  e6b3 c920               	cmp #$20
  2213  e6b5 d009               	bne endbye		; yes, space
  2214  e6b7 c000               	cpy #0			; are we at the left margin?
  2215  e6b9 d0f0               	bne eloup1		; branch if not
  2216  e6bb 2048e6             	jsr getbit		; if we're on a wraped line
  2217  e6be b0eb               	bcs eloup1		; always scan the above line
  2218                          
  2219  e6c0 84dc               endbye: sty indx		; remember this
  2220  e6c2 60                 	rts
  2221                          ; -------------------------------------------------------------------------------------------------
  2222                          ; ****** Move to next char
  2223                          ; scroll if enabled
  2224                          ; wrap to top if disabled
  2225  e6c3 48                 nxtchr:	pha
  2226  e6c4 a4d2               	ldy pntr
  2227  e6c6 c4ed               	cpy scxmax		; are we at the right margin?
  2228  e6c8 9007               	bcc bumpnt		; branch if not
  2229                          
  2230  e6ca 20f8e3             	jsr nxln		; point to nextline
  2231  e6cd a000               	ldy #0			; point to first char of 1st line
  2232  e6cf 88                 	dey
  2233  e6d0 38                 	sec			; set to show moved to new line
  2234  e6d1 c8                 bumpnt:	iny			; increment char index
  2235  e6d2 84d2               	sty pntr
  2236  e6d4 68                 	pla
  2237  e6d5 60                 	rts
  2238                          ; -------------------------------------------------------------------------------------------------
  2239                          ; Backup one char - Move one char left
  2240                          ; wrap up and stop a top left
  2241  e6d6 a4d2               bakchr:	ldy pntr
  2242  e6d8 88                 	dey
  2243  e6d9 3004               	bmi bakot1
  2244  e6db c000               	cpy #0			; are we at the left margin
  2245  e6dd b00f               	bcs bakout		; no - past it
  2246  e6df a000               bakot1:	ldy #0
  2247  e6e1 c4d1               	cpy tblx		; are we at top line last character?
  2248  e6e3 b00e               	bcs bakot2		; leave with carry set
  2249  e6e5 c6d1               	dec tblx		; else backup a line
  2250  e6e7 48                 	pha
  2251  e6e8 20c1e0             	jsr stupt		; set line base adr
  2252  e6eb 68                 	pla
  2253  e6ec a4ed               	ldy scxmax		; move cursor to right side
  2254  e6ee 84d2               bakout: sty pntr
  2255  e6f0 c4ed               	cpy scxmax		; set z-flag if moved to new line
  2256  e6f2 18                 	clc			; always clear
  2257  e6f3 60                 bakot2: rts
  2258                          ; -------------------------------------------------------------------------------------------------
  2259                          ; savpos - Save row & column position
  2260  e6f4 a4d2               savpos: ldy pntr
  2261  e6f6 84e0               	sty sedt1
  2262  e6f8 a6d1               	ldx tblx
  2263  e6fa 86e1               	stx sedt2
  2264  e6fc 60                 	rts
  2265                          ; -------------------------------------------------------------------------------------------------
  2266                          ; Delete or insert a character
  2267  e6fd b034               delins: bcs insert		; C=1 is insert
  2268                          ; delete a character
  2269  e6ff 20dae3             deleet: jsr cleft		; move back 1 position
  2270  e702 20f4e6             	jsr savpos		; save column & row positions
  2271  e705 b00f               	bcs delout		; abort if at top left corner
  2272                          
  2273  e707 c4ed               deloop: cpy scxmax		; at right margin?
  2274  e709 9016               	bcc delop1		; no - skip ahaed
  2275  e70b a6d1               	ldx tblx
  2276  e70d e8                 	inx
  2277  e70e 204ae6             	jsr getbt1		; is next line a wrapped line?
  2278  e711 b00e               	bcs delop1		; yes - continue with delete
  2279  e713 20e1e1             	jsr doblnk		; no - blank last character
  2280                          
  2281  e716 a5e0               delout: lda sedt1		; restore column and row positions
  2282  e718 85d2               	sta pntr
  2283  e71a a5e1               	lda sedt2
  2284  e71c 85d1               	sta tblx
  2285  e71e 4cc1e0             	jmp stupt		; restore pnt and exit
  2286                          
  2287  e721 20c3e6             delop1: jsr nxtchr
  2288  e724 2021e3             	jsr get1ch		; get next character
  2289  e727 20d6e6             	jsr bakchr
  2290  e72a 20e8e1             	jsr dsptco		; move it back 1 position
  2291  e72d 20c3e6             	jsr nxtchr		; move up 1 position
  2292  e730 4c07e7             	jmp deloop		; loop until at end of line
  2293                          ; Insert a character 
  2294  e733 20f4e6             insert: jsr savpos		; save column & row positions
  2295  e736 2099e6             	jsr fndend		; move to last char on the line
  2296  e739 e4e1               	cpx sedt2		; last row equal to starting row?
  2297  e73b d002               	bne ins10		; no - skip ahead
  2298  e73d c4e0               	cpy sedt1		; is last position before starting position?
  2299  e73f 9021               ins10:	bcc ins50		; yes - no need to move anything
  2300  e741 207de7             	jsr movchr		; move to next char position
  2301  e744 b022               	bcs insout		; abort if scroll needed but disabled
  2302                          
  2303  e746 20d6e6             ins30:	jsr bakchr
  2304  e749 2021e3             	jsr get1ch		; move char forward 1 position
  2305  e74c 20c3e6             	jsr nxtchr
  2306  e74f 20e8e1             	jsr dsptco
  2307  e752 20d6e6             	jsr bakchr
  2308  e755 a6d1               	ldx tblx
  2309  e757 e4e1               	cpx sedt2		; at original position
  2310  e759 d0eb               	bne ins30
  2311  e75b c4e0               	cpy sedt1
  2312  e75d d0e7               	bne ins30		; no - loop till we are
  2313                          
  2314  e75f 20e1e1             	jsr doblnk		; insert a blank
  2315  e762 e6da               ins50:	inc insrt		; inc insert count
  2316  e764 d002               	bne insout		; only allow up to 255
  2317  e766 c6da               	dec insrt
  2318  e768 4c16e7             insout:	jmp delout		; restore original position
  2319                          ; -------------------------------------------------------------------------------------------------
  2320                          ; Stop/run
  2321  e76b 900f               stprun: bcc runrts		; exit if a stop code
  2322  e76d 78                 	sei			; disable interrupts
  2323  e76e a209               	ldx #9
  2324  e770 86d8               	stx ndx			; set keyboard queue size
  2325  e772 bd55eb             runlop:	lda runtb-1,x
  2326  e775 9d9e03             	sta keyd-1,x		; load run character sequence into kybd queue
  2327  e778 ca                 	dex
  2328  e779 d0f7               	bne runlop
  2329                          
  2330  e77b 58                 	cli			; enable interrupts
  2331  e77c 60                 runrts: rts
  2332                          ; -------------------------------------------------------------------------------------------------
  2333                          ; movchr  -  Move to next char position
  2334                          ; insert blank line if at end of line
  2335                          ;   y = column position
  2336                          ;   on exit - carry set = abort - scroll disabled
  2337  e77d c4ed               movchr: cpy scxmax
  2338  e77f 900b               	bcc movc10		; easy if not at end of line
  2339  e781 a6d1               	ldx tblx
  2340  e783 e018               	cpx #scymax
  2341  e785 9005               	bcc movc10		; skip if not last line of screen
  2342  e787 2c9b03             	bit scrdis
  2343  e78a 301f               	bmi movc30		; abort if scrolling disabled
  2344                          
  2345  e78c 20c1e0             movc10:	jsr stupt		; set pnt address
  2346  e78f 20c3e6             	jsr nxtchr		; move to next char position
  2347  e792 9017               	bcc movc30		; done if not move to new line
  2348  e794 2048e6             	jsr getbit		; check if on a continued line
  2349  e797 b011               	bcs movc20		; skip ahead if not
  2350  e799 a218               	ldx #scymax		; check
  2351  e79b e000               	cpx #0
  2352  e79d d002               	bne movc15		; no...pass through old code
  2353  e79f 68                 	pla			; abort
  2354  e7a0 68                 	pla
  2355  e7a1 2c9b03             movc15:	bit scrdis		; restore patched area (test for scrolling mode)
  2356  e7a4 38                 	sec			; prep for abort...
  2357  e7a5 7004               	bvs movc30
  2358  e7a7 20a3e5             	jsr scrdwn		; else insert a blank line
  2359                          
  2360  e7aa 18                 movc20:	clc			; for clean exit
  2361  e7ab 60                 movc30: rts
  2362                          ; -------------------------------------------------------------------------------------------------
  2363                          ; Change color
  2364  e7ac a010               chkcol:	ldy #16			; there's 16 colors
  2365  e7ae 88                 chk1a:	dey
  2366  e7af 3014               	bmi chk1b
  2367  e7b1 d91bec             	cmp coltab,y
  2368  e7b4 d0f8               	bne chk1a
  2369  e7b6 24ea               	bit mode		; check mode
  2370  e7b8 3003               	bmi chkcol7		; -> mode7
  2371                          ; mode 6
  2372  e7ba 84cf               	sty color		; change the color
  2373  e7bc 60                 	rts
  2374                          ; mode 7
  2375  e7bd 48                 chkcol7:pha			; save char
  2376  e7be b92bec             	lda col8bit,y
  2377  e7c1 85cf               	sta color
  2378  e7c3 68                 	pla
  2379  e7c4 60                 	rts
  2380                          
  2381  e7c5 4cb2e3             chk1b:	jmp cuser
  2382                          ; -------------------------------------------------------------------------------------------------
  2383                          ; Turn off all modes - Reset modes: insert, reverse, quote
  2384                          ;   expected to return zero
  2385  e7c8 a900               toqm:	lda #0
  2386  e7ca 85da               	sta insrt
  2387  e7cc 8d9703             	sta rvs
  2388  e7cf 85d9               	sta qtsw
  2389  e7d1 60                 	rts
  2390                          ; -------------------------------------------------------------------------------------------------
  2391                          ; Enable / Disable scrolling
  2392                          ;   carry set = disable
  2393  e7d2 a900               scrsw:	lda #0
  2394  e7d4 6a                 	ror
  2395  e7d5 8d9b03             	sta scrdis
  2396  e7d8 60                 	rts
  2397                          ; -------------------------------------------------------------------------------------------------
  2398                          ; ********** Patched new f-key functions with sei/cli and chr$(141) for shift-return **********
  2399  e7d9 78                 keyfun: sei			; prevent fight over variables with keyscan...
  2400  e7da 88                 	dey
  2401  e7db 3003               	bmi listky		; do list if no parameters given
  2402  e7dd 4c85e8             	jmp addkey		; - else go add a new key definition
  2403                          ; list key defintions
  2404  e7e0 a000               listky:	ldy #0			; initialize key counter
  2405                          
  2406  e7e2 c8                 listlp:	iny
  2407  e7e3 84e0               	sty sedt1
  2408  e7e5 88                 	dey			; minus 1 for indexing
  2409  e7e6 b98303             	lda keysiz,y		; get key length
  2410  e7e9 f054               	beq nodefn		; no listing if no defintion
  2411  e7eb 8d9d03             	sta keyidx		; save key length
  2412  e7ee 2039ea             	jsr findky		; get buffer start addr for function key
  2413  e7f1 85bf               	sta keypnt
  2414  e7f3 86c0               	stx keypnt+1		; save 2 byte address in temp loc
  2415                          ; print 'key ' preamble
  2416  e7f5 a203               	ldx #3
  2417  e7f7 bd6de8             preamb:	lda keword,x
  2418  e7fa 20d2ff             	jsr bsout
  2419  e7fd ca                 	dex
  2420  e7fe 10f7               	bpl preamb
  2421                          ; convert to 1 digit ascii
  2422  e800 a5e0               	lda sedt1		; get key number
  2423  e802 18                 	clc
  2424  e803 6930               	adc #$30		; make ascii
  2425                          ; print key string
  2426  e805 20d2ff             	jsr bsout		; print digit
  2427  e808 a000               	ldy #0			; init string position counter
  2428  e80a a92c               	lda #','		; for comma print
  2429  e80c 20d2ff             lstk20:	jsr bsout		; print char - comma or plus-sign
  2430  e80f a207               	ldx #7			; for chr$ printing - no plus-sign or quote to preceed
  2431  e811 b1bf               txtprt:	lda (keypnt),y		; get byte
  2432  e813 c90d               	cmp #13
  2433  e815 f031               	beq lstkcr		; print chr$(13) for return
  2434  e817 c98d               	cmp #141
  2435  e819 f030               	beq lstksc		; print chr$(141) for shift-return
  2436  e81b c922               	cmp #34
  2437  e81d f02f               	beq lstkqt		; print chr$(34) for quote
  2438  e81f e009               	cpx #9			; was a normal char printed last time
  2439  e821 f007               	beq lstk10		; yes - skip ahead
  2440  e823 48                 	pha			; save char
  2441  e824 a922               	lda #$22 ; "
  2442  e826 20d2ff             	jsr bsout		; print a quote
  2443  e829 68                 	pla			; restore the char
  2444                          
  2445  e82a 20d2ff             lstk10:	jsr bsout		; print the char
  2446  e82d a209               	ldx #9			; for chr$ - print quote and plus next time
  2447  e82f c8                 	iny
  2448  e830 cc9d03             	cpy keyidx
  2449  e833 d0dc               	bne txtprt		; loop to end of string
  2450                          
  2451  e835 a922               	lda #$22 ; "
  2452  e837 20d2ff             	jsr bsout		; print ending quote
  2453                          
  2454  e83a a90d               lstk30:	lda #cr
  2455  e83c 20d2ff             	jsr bsout		; do a return
  2456                          
  2457  e83f a4e0               nodefn:	ldy sedt1		; get key number
  2458  e841 c008               	cpy #pgmkys
  2459  e843 d09d               	bne listlp		; loop til all keys checked
  2460                          
  2461  e845 58                 	cli			; all done...clear the keyscan holdoff
  2462  e846 18                 	clc			; okay return always
  2463  e847 60                 	rts
  2464                          
  2465  e848 a20a               lstkcr:	ldx #qtword-cdword-1	; index for return
  2466  e84a 2c                 	!byte $2c		; skip 2
  2467  e84b a213               lstksc:	ldx #addkey-cdword-1	; index for shifted-return
  2468  e84d 2c                 	!byte $2c		; skip 2
  2469  e84e a20e               lstkqt:	ldx #scword-cdword-1	; index for quote
  2470                          
  2471  e850 8a                 lstk:	txa			; save value index....
  2472  e851 48                 	pha			; save .x
  2473  e852 a206               	ldx #crword-cdword-1	; print chr$(
  2474  e854 bd71e8             lstklp:	lda cdword,x		; print loop
  2475  e857 f00a               	beq lstk40		; zero is end...
  2476  e859 20d2ff             	jsr bsout
  2477  e85c ca                 	dex
  2478  e85d 10f5               	bpl lstklp
  2479                          
  2480  e85f 68                 	pla			; move number and repeat
  2481  e860 aa                 	tax
  2482  e861 d0f1               	bne lstklp		; loop again for 'xxx)' ending part
  2483                          
  2484  e863 c8                 lstk40:	iny
  2485  e864 cc9d03             	cpy keyidx
  2486  e867 f0d1               	beq lstk30		; exit if all string printed
  2487  e869 a92b               	lda #'+'		; set to print plus sign
  2488  e86b d09f               	bne lstk20		; return to routine
  2489                          
  2490  e86d 2059454b           keword:	!pet " yek"
  2491  e871 28245248432b22     cdword:	!pet "($rhc+",$22 ; "
  2492  e878 00293331           crword:	!pet 0,")31"
  2493  e87c 00293433           qtword:	!pet 0,")43"
  2494  e880 0029313431         scword:	!pet 0,")141"
  2495                          
  2496                          ; insert a new key defintion
  2497  e885 48                 addkey:	pha			; save zero page address of params
  2498  e886 aa                 	tax
  2499  e887 84e0               	sty sedt1		; save key number in temp loc
  2500  e889 b500               	lda zp,x		; get new string length
  2501  e88b 38                 	sec
  2502  e88c f98303             	sbc keysiz,y		; subtract old length
  2503  e88f 85e1               	sta sedt2		; save difference in temp location
  2504  e891 6e9c03             	ror fktmp		; save the carry
  2505  e894 c8                 	iny
  2506  e895 2039ea             	jsr findky		; find start addr of next function key
  2507  e898 85c1               	sta sedsal
  2508  e89a 86c2               	stx sedsal+1		; save 2 byte address in temp loc
  2509  e89c a008               	ldy #pgmkys
  2510  e89e 2039ea             	jsr findky		; find end of last function key
  2511  e8a1 85c3               	sta sedeal
  2512  e8a3 86c4               	stx sedeal+1		; save next free byte addr in temp loc
  2513  e8a5 ac9c03             	ldy fktmp		; check if new string is longer or shorter
  2514  e8a8 1013               	bpl keysho		; skip ahead if shorter
  2515  e8aa 18                 	clc
  2516  e8ab ed8103             	sbc pkyend		; subtract last available adress
  2517  e8ae a8                 	tay
  2518  e8af 8a                 	txa
  2519  e8b0 ed8203             	sbc pkyend+1
  2520  e8b3 aa                 	tax
  2521  e8b4 98                 	tya
  2522  e8b5 18                 	clc
  2523  e8b6 65e1               	adc sedt2		; add difference
  2524  e8b8 8a                 	txa
  2525  e8b9 6900               	adc #0
  2526  e8bb b05c               	bcs kyxit		; exit if no room, skip if memory not full
  2527                          
  2528                          ; expand or contract key area to make room for new key definition.
  2529                          keysho:
  2530  e8bd a5c3               kymove:	lda sedeal
  2531  e8bf 18                 	clc			; check if entire area expanded or contracted
  2532  e8c0 e5c1               	sbc sedsal
  2533  e8c2 a5c4               	lda sedeal+1
  2534  e8c4 e5c2               	sbc sedsal+1
  2535  e8c6 902a               	bcc keyins		; go insert new key defintion if yes
  2536  e8c8 a000               	ldy #0
  2537  e8ca ad9c03             	lda fktmp		; check if expand or contract
  2538  e8cd 1011               	bpl kshort		; skip if needs to be contracted
  2539                          
  2540  e8cf a5c3               	lda sedeal
  2541  e8d1 d002               	bne newky4		; dec 1 from source addr
  2542  e8d3 c6c4               	dec sedeal+1		; sub 1 for borrow
  2543  e8d5 c6c3               newky4:	dec sedeal
  2544  e8d7 b1c3               	lda (sedeal),y		; move 1 byte up to expand
  2545  e8d9 a4e1               	ldy sedt2		; get offset = difference
  2546  e8db 91c3               	sta (sedeal),y		; move byte up
  2547  e8dd 4cbde8             	jmp kymove		; loop until all bytes moved
  2548                          
  2549  e8e0 b1c1               kshort:	lda (sedsal),y		; get source byte
  2550  e8e2 a4e1               	ldy sedt2		; get offset = difference
  2551  e8e4 c6c2               	dec sedsal+1		; sub 1 to move down
  2552  e8e6 91c1               	sta (sedsal),y		; move the byte down
  2553  e8e8 e6c2               	inc sedsal+1
  2554  e8ea e6c1               	inc sedsal		; move source up 1 byte
  2555  e8ec d0cf               	bne kymove
  2556  e8ee e6c2               	inc sedsal+1		; add 1 for carry
  2557  e8f0 d0cb               	bne kymove		; always
  2558                          ; insert the new string defintion
  2559  e8f2 a4e0               keyins:	ldy sedt1		; get the key index
  2560  e8f4 2039ea             	jsr findky		; find buffer start address for this key
  2561  e8f7 85c1               	sta sedsal
  2562  e8f9 86c2               	stx sedsal+1		; save 2 byte address in temp loc
  2563  e8fb a4e0               	ldy sedt1
  2564  e8fd 68                 	pla
  2565  e8fe 48                 	pha
  2566  e8ff aa                 	tax			; get zero page addr of params
  2567  e900 b500               	lda zp,x
  2568  e902 998303             	sta keysiz,y		; save key length
  2569  e905 a8                 	tay
  2570  e906 f010               	beq kyinok		; equal to zero no keys...exit
  2571  e908 b501               	lda zp+1,x		; get & save low byte of string address
  2572  e90a 85c3               	sta sedeal
  2573  e90c b502               	lda zp+2,x		; get & save high byte of string address
  2574  e90e 85c4               	sta sedeal+1
  2575                          
  2576  e910 88                 kyinlp:	dey
  2577  e911 b1c3               	lda (sedeal),y		; get byte
  2578  e913 91c1               	sta (sedsal),y		; store into buffer
  2579  e915 98                 	tya			; .y flags...end?
  2580  e916 d0f8               	bne kyinlp		; no... loop
  2581                          
  2582  e918 18                 kyinok:	clc			; for good exit carry clear
  2583  e919 68                 kyxit:	pla			; pop zero page address for params
  2584  e91a 58                 	cli			; all done...release keyscan
  2585  e91b 60                 	rts			; c-set is memory full error
  2586                          ; -------------------------------------------------------------------------------------------------
  2587                          ;*******************************
  2588                          ; Keyboard scanner
  2589                          ;*******************************
  2590                          ; Cursor routine
  2591  e91c a5e3               scnkey: lda crson
  2592  e91e d016               	bne key			; skip if cursor is off (run mode)
  2593                          ; solid cursor
  2594  e920 a5ce               	lda crssw
  2595  e922 d012               	bne key			; skip if cursor already visible
  2596                          	
  2597  e924 e6ce               	inc crssw		; set visibility switch
  2598  e926 2021e3             	jsr get1ch		; get char and color under cursor
  2599  e929 85db               	sta config		; remember char under cursor
  2600  e92b a6cd               	ldx tcolor
  2601  e92d 86d0               	stx gdcol		; remember char color
  2602  e92f a6cf               	ldx color		; load actual color
  2603  e931 4980               	eor #$80		; inverse char
  2604  e933 20eae1             	jsr dspp		; print (reversed) char
  2605                          ; Keyboard scanner
  2606  e936 a900               key:	lda #$00
  2607  e938 85e7               	sta shflag
  2608  e93a a040               	ldy #64			; last key index
  2609  e93c 84e8               	sty sfdx		; null key found
  2610  e93e 8d0fde             	sta via1+pra		; raise all lines
  2611  e941 ae00de             	ldx via1+prb		; check for a key down
  2612  e944 e0ff               	cpx #$ff		; no keys down?
  2613  e946 f070               	beq scnout		; branch if none
  2614  e948 a8                 	tay			; .a=0 ldy #0
  2615  e949 a952               	lda #<mode1
  2616  e94b 85e4               	sta keytab
  2617  e94d a9ea               	lda #>mode1
  2618  e94f 85e5               	sta keytab+1
  2619  e951 a9fe               	lda #$fe		; start with 1st column
  2620  e953 8d0fde             	sta via1+pra
  2621  e956 a208               scn20:	ldx #8			; 8 row keyboard
  2622  e958 48                 	pha			; save column output info
  2623  e959 ad00de             scn22:	lda via1+prb
  2624  e95c cd00de             	cmp via1+prb		; debounce keyboard
  2625  e95f d0f8               	bne scn22
  2626  e961 4a                 scn30:	lsr			; look for key down
  2627  e962 b014               	bcs ckit		; none
  2628  e964 48                 	pha
  2629  e965 b1e4               	lda (keytab),y		; get char code
  2630  e967 c905               	cmp #$05
  2631  e969 b00a               	bcs spck2		; if not special key go on
  2632  e96b c903               	cmp #$03		; could it be a stop key?
  2633  e96d f006               	beq spck2		; branch if so
  2634  e96f 05e7               	ora shflag
  2635  e971 85e7               	sta shflag		; put shift bit in flag byte
  2636  e973 1002               	bpl ckut
  2637                          
  2638  e975 84e8               spck2:	sty sfdx		; save key number
  2639  e977 68                 ckut:	pla
  2640  e978 c8                 ckit:	iny
  2641  e979 c041               	cpy #65
  2642  e97b b00b               	bcs ckit1		; branch if finished
  2643  e97d ca                 	dex
  2644  e97e d0e1               	bne scn30
  2645  e980 38                 	sec
  2646  e981 68                 	pla			; reload column info
  2647  e982 2a                 	rol
  2648  e983 8d0fde             	sta via1+pra		; next column on keyboard
  2649  e986 d0ce               	bne scn20		; always branch
  2650  e988 68                 ckit1:	pla			; dump column output...all done
  2651  e989 4cfee9             	jmp shflog		; evaluate shift functions
  2652  e98c a4e8               rekey:	ldy sfdx		; get key index
  2653  e98e b1e4               	lda (keytab),y		; get char code
  2654  e990 aa                 	tax			; save the char
  2655                          ; check function key $85-$8c	
  2656  e991 c985               	cmp #$85		; check if function key
  2657  e993 900f               	bcc notfun		; skip - not a function key
  2658  e995 c98d               	cmp #$8d
  2659  e997 b00b               	bcs notfun		; skip - not a function key
  2660  e999 98                 	tya
  2661  e99a 48                 	pha
  2662  e99b 2015ea             	jsr funjmp		; do function key indirect
  2663  e99e 68                 	pla
  2664  e99f a8                 	tay
  2665  e9a0 a2ff               	ldx #$ff		; no key
  2666  e9a2 b03d               	bcs keyxit		; done if carry flag set (always set in funjmp->dokeyf)
  2667                          ; Not a function key
  2668  e9a4 c4d4               notfun: cpy lstx		; same as prev char index?
  2669  e9a6 f006               	beq rpt10		; yes
  2670  e9a8 a00a               	ldy #10			; no - reset delay before repeat
  2671  e9aa 84df               	sty delay
  2672  e9ac d031               	bne ckit2		; always
  2673  e9ae 297f               rpt10:	and #$7f		; unshift it
  2674  e9b0 24d3               	bit rptflg		; check for repeat disable
  2675  e9b2 3016               	bmi rpt20		; yes
  2676  e9b4 7042               	bvs scnrts
  2677  e9b6 c97f               	cmp #$7f		; no keys ?
  2678  e9b8 f025               scnout:	beq ckit2		; yes - get out
  2679  e9ba c914               	cmp #$14		; an inst/del key ?
  2680  e9bc f00c               	beq rpt20		; yes - repeat it
  2681  e9be c920               	cmp #$20		; a space key ?
  2682  e9c0 f008               	beq rpt20		; yes
  2683  e9c2 c91d               	cmp #$1d		; a crsr left/right ?
  2684  e9c4 f004               	beq rpt20		; yes
  2685  e9c6 c911               	cmp #$11		; a crsr up/dwn ?
  2686  e9c8 d02e               	bne scnrts		; no - exit
  2687  e9ca a4df               rpt20:	ldy delay		; time to repeat ?
  2688  e9cc f004               	beq rpt40		; yes
  2689  e9ce c6df               	dec delay
  2690  e9d0 d026               	bne scnrts
  2691  e9d2 c6de               rpt40:	dec kount		; time for next repeat ?
  2692  e9d4 d022               	bne scnrts		; no
  2693  e9d6 a004               	ldy #4			; yes - reset ctr
  2694  e9d8 84de               	sty kount
  2695  e9da a4d8               	ldy ndx			; no repeat if queue full
  2696  e9dc 88                 	dey
  2697  e9dd 1019               	bpl scnrts
  2698                          
  2699  e9df a4e8               ckit2:	ldy sfdx		; get index of key
  2700  e9e1 84d4               keyxit:	sty lstx		; save this index to key found
  2701  e9e3 a4e7               	ldy shflag		; update shift status
  2702  e9e5 84e6               	sty lstshf
  2703  e9e7 e0ff               ckit3:	cpx #$ff		; a null key or no key ?
  2704  e9e9 f00d               	beq scnrts		; branch if so
  2705  e9eb 8a                 	txa			; need x as index so...
  2706  e9ec a6d8               	ldx ndx			; get # of chars in key queue
  2707  e9ee e00a               	cpx #10			; irq buffer full ?
  2708  e9f0 b006               	bcs scnrts		; yes - no more insert
  2709                          putque:
  2710  e9f2 9d9f03             	sta keyd,x		; put raw data here
  2711  e9f5 e8                 	inx
  2712  e9f6 86d8               	stx ndx			; update key queue count
  2713  e9f8 a97f               scnrts:	lda #$7f		; setup pa7 for stop key sense
  2714  e9fa 8d0fde             	sta via1+pra
  2715  e9fd 60                 	rts
  2716                          ; -------------------------------------------------------------------------------------------------
  2717                          ; shift logic
  2718  e9fe a5e7               shflog:	lda shflag
  2719  ea00 0a                 	asl
  2720  ea01 c908               	cmp #$08		; was it a control key
  2721  ea03 9002               	bcc nctrl		; branch if not
  2722  ea05 a906               	lda #6			; else use table #4
  2723                          ;
  2724                          nctrl:
  2725  ea07 aa                 notkat:	tax
  2726  ea08 bd4aea             	lda keycod,x
  2727  ea0b 85e4               	sta keytab
  2728  ea0d bd4bea             	lda keycod+1,x
  2729  ea10 85e5               	sta keytab+1
  2730                          
  2731  ea12 4c8ce9             	jmp rekey
  2732                          ; rsr 12/08/81 modify for vic-40
  2733                          ; rsr  2/18/82 modify for 6526 input pad sense
  2734                          ; rsr  3/11/82 fix keyboard debounce, repair file
  2735                          ; rsr  3/11/82 modify for commodore 64
  2736                          ; -------------------------------------------------------------------------------------------------
  2737                          ; Jump vector: Function key indirect
  2738  ea15 6ca803             funjmp: jmp (funvec)
  2739                          ; -------------------------------------------------------------------------------------------------
  2740                          ; Default function key handler
  2741  ea18 c4d4               dokeyf: cpy lstx
  2742  ea1a f01b               	beq funrts		; exit not allowed to repeat
  2743  ea1c a5d8               	lda ndx
  2744  ea1e 05dd               	ora kyndx
  2745  ea20 d015               	bne funrts		; exit - function queue not empty
  2746  ea22 8d9d03             	sta keyidx		; init pointer index into function area
  2747  ea25 8a                 	txa
  2748  ea26 38                 	sec
  2749  ea27 e985               	sbc #$85		; calc function key number 0-7
  2750  ea29 18                 	clc
  2751  ea2a a8                 	tay
  2752  ea2b b98303             	lda keysiz,y		; get function key size
  2753  ea2e 85dd               	sta kyndx		; - and store it for key scan
  2754  ea30 2039ea             	jsr findky
  2755  ea33 85bf               	sta keypnt		; get function start addr
  2756  ea35 86c0               	stx keypnt+1		; - and save in keypnt
  2757                          
  2758  ea37 38                 funrts: sec
  2759  ea38 60                 	rts
  2760                          ; -------------------------------------------------------------------------------------------------
  2761                          ; Find address of function key given in y-reg
  2762  ea39 a5bd               findky: lda pkybuf
  2763  ea3b a6be               	ldx pkybuf+1
  2764                          
  2765  ea3d 18                 findlp: clc
  2766  ea3e 88                 	dey			; found key yet?
  2767  ea3f 3008               	bmi fndout		; yes - done
  2768  ea41 798303             	adc keysiz,y		; add function key size
  2769  ea44 90f7               	bcc findlp		; loop if no high byte carry-over
  2770  ea46 e8                 	inx
  2771  ea47 d0f4               	bne findlp		; loop - always
  2772                          
  2773  ea49 60                 fndout: rts
  2774                          ; -------------------------------------------------------------------------------------------------
  2775                          ; ***** 'keyboard tables'
  2776                          keycod:				; keyboard mode 'dispatch'
  2777  ea4a 52ea               	!word mode1
  2778  ea4c 93ea               	!word mode2
  2779  ea4e d4ea               	!word mode3
  2780  ea50 15eb               	!word contrl		; control keys
  2781                          ; -------------------------------------------------------------------------------------------------
  2782                          ; ***** 'editor.3' *****
  2783                          ; keyboard tables
  2784                          mode1:										; normal keys
  2785  ea52 140d1d8b85878911   	!byte $14,$0d,$1d,$8b,$85,$87,$89,$11  ;del ret rt  f7  f1  f3  f5  dn
  2786  ea5a 335741345a534501   	!byte $33,$57,$41,$34,$5a,$53,$45,$01  ; 3   w   a   4   z   s   e  shf
  2787  ea62 3552443643465458   	!byte $35,$52,$44,$36,$43,$46,$54,$58  ; 5   r   d   6   c   f   t   x
  2788  ea6a 3759473842485556   	!byte $37,$59,$47,$38,$42,$48,$55,$56  ; 7   y   g   8   b   h   u   v
  2789  ea72 39494a304d4b4f4e   	!byte $39,$49,$4a,$30,$4d,$4b,$4f,$4e  ; 9   i   j   0   m   k   o   n
  2790  ea7a 2b504c2d2e3a402c   	!byte $2b,$50,$4c,$2d,$2e,$3a,$40,$2c  ; +   p   l   -   .   :   @   ,
  2791  ea82 5c2a3b13013d5e2f   	!byte $5c,$2a,$3b,$13,$01,$3d,$5e,$2f  ;lb.  *   ;  hom shf  =   ^   /
  2792  ea8a 315f043220025103   	!byte $31,$5f,$04,$32,$20,$02,$51,$03  ; 1  <-- ctl  2  spc  C=  q stop
  2793  ea92 ff                 	!byte $ff	; end of table null
  2794                          ;
  2795                          mode2:										; shift
  2796  ea93 948d9d8c86888a91   	!byte $94,$8d,$9d,$8c,$86,$88,$8a,$91  ;ins RTN lft f8  f2  f4  f6  up
  2797  ea9b 23d7c124dad3c501   	!byte $23,$d7,$c1,$24,$da,$d3,$c5,$01  ; #   W   A   $   Z   S   E  shf
  2798  eaa3 25d2c426c3c6d4d8   	!byte $25,$d2,$c4,$26,$c3,$c6,$d4,$d8  ; %   R   D   &   C   F   T   X
  2799  eaab 27d9c728c2c8d5d6   	!byte $27,$d9,$c7,$28,$c2,$c8,$d5,$d6  ; '   Y   G   (   B   H   U   V
  2800  eab3 29c9ca30cdcbcfce   	!byte $29,$c9,$ca,$30,$cd,$cb,$cf,$ce  ; )   I   J   0   M   K   O   N
  2801  eabb dbd0ccdd3e5bba3c   	!byte $db,$d0,$cc,$dd,$3e,$5b,$ba,$3c  ;+gr  P   L  -gr  >   [  @gr  <
  2802  eac3 a9c05d93013dde3f   	!byte $a9,$c0,$5d,$93,$01,$3d,$de,$3f  ;lbg *gr  ]  clr shf  =  pi   ?
  2803  eacb 215f0422a002d183   	!byte $21,$5f,$04,$22,$a0,$02,$d1,$83  ; !  <-- ctl  "  SPC  C=  Q  run
  2804  ead3 ff                 	!byte $ff	; end of table null
  2805                          ;
  2806                          mode3:										; left window grahpics
  2807  ead4 948d9d8c86888a91   	!byte $94,$8d,$9d,$8c,$86,$88,$8a,$91  ;ins RTN lft f8  f2  f4  f6  up
  2808  eadc 96b3b097adaeb101   	!byte $96,$b3,$b0,$97,$ad,$ae,$b1,$01  ;red  W   A  cyn  Z   S   E  shf
  2809  eae4 98b2ac99bcbba3bd   	!byte $98,$b2,$ac,$99,$bc,$bb,$a3,$bd  ;pur  R   D  grn  C   F   T   X 
  2810  eaec 9ab7a59bbfb4b8be   	!byte $9a,$b7,$a5,$9b,$bf,$b4,$b8,$be  ;blu  Y   G  yel  B   H   U   V
  2811  eaf4 29a2b530a7a1b9aa   	!byte $29,$a2,$b5,$30,$a7,$a1,$b9,$aa  ; )   I   J   0   M   K   O   N
  2812  eafc a6afb6dc3e5ba43c   	!byte $a6,$af,$b6,$dc,$3e,$5b,$a4,$3c  ;+gr  P   L  -gr  >   [  @gr  <
  2813  eb04 a8df5d93013dde3f   	!byte $a8,$df,$5d,$93,$01,$3d,$de,$3f  ;lbg *gr  ]  clr shf  =  pi   ?
  2814  eb0c 815f0495a002ab83   	!byte $81,$5f,$04,$95,$a0,$02,$ab,$83  ;blk <-- ctl wht spc  C=  Q  run
  2815  eb14 ff                 	!byte $ff	; end of table null
  2816                          ;
  2817                          contrl:										; control keys
  2818  eb15 ffffffffffffffff   	!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff  ; ~   ~   ~   ~   ~   ~   ~   ~
  2819  eb1d 1c17019f1a1305ff   	!byte $1c,$17,$01,$9f,$1a,$13,$05,$ff  ;red /w  /a  cyn /z  /s  /e   ~
  2820  eb25 9c12041e03061418   	!byte $9c,$12,$04,$1e,$03,$06,$14,$18  ;pur /r  /d  grn /c  /f  /t  /x
  2821  eb2d 1f19079e02081516   	!byte $1f,$19,$07,$9e,$02,$08,$15,$16  ;yel /y  /g  yel /b  /h  /u  /v
  2822  eb35 12090a920d0b0f0e   	!byte $12,$09,$0a,$92,$0d,$0b,$0f,$0e  ;ron /i  /j  rof /m  /k  /o  /n
  2823  eb3d 02100c82ff1b00ff   	!byte $02,$10,$0c,$82,$ff,$1b,$00,$ff  ;esc /p  /l  dsc  ~  /[  /@   ~	esc/dsc=e/d scrolling
  2824  eb45 1cff1dffff1f1eff   	!byte $1c,$ff,$1d,$ff,$ff,$1f,$1e,$ff  ;/lb  ~  /]   ~   ~  /=  /pi  ~
  2825  eb4d 9006ff05ffff11ff   	!byte $90,$06,$ff,$05,$ff,$ff,$11,$ff  ;blk /<-  ~  wht  ~   ~  /q   ~
  2826  eb55 ff                 	!byte $ff	; end of table null
  2827                          ; -------------------------------------------------------------------------------------------------
  2828                          ; <SHIFT> <RUN/STOP> String: DLOAD "*" + RUN
  2829  eb56 44cc222a0d         runtb:  !pet "d",$cc,$22,"*",cr		; dL"* <RETURN>
  2830  eb5b 52554e0d           	!pet "run",cr	          	; run <RETURN>
  2831                          ; -------------------------------------------------------------------------------------------------
  2832                          ;****** address of color ram lines ******
  2833                          linz0	= clrram
  2834                          linz1	= linz0+collen
  2835                          linz2	= linz1+collen
  2836                          linz3	= linz2+collen
  2837                          linz4	= linz3+collen
  2838                          linz5	= linz4+collen
  2839                          linz6	= linz5+collen
  2840                          linz7	= linz6+collen
  2841                          linz8	= linz7+collen
  2842                          linz9	= linz8+collen
  2843                          linz10	= linz9+collen
  2844                          linz11	= linz10+collen
  2845                          linz12	= linz11+collen
  2846                          linz13	= linz12+collen
  2847                          linz14	= linz13+collen
  2848                          linz15	= linz14+collen
  2849                          linz16	= linz15+collen
  2850                          linz17	= linz16+collen
  2851                          linz18	= linz17+collen
  2852                          linz19	= linz18+collen
  2853                          linz20	= linz19+collen
  2854                          linz21	= linz20+collen
  2855                          linz22	= linz21+collen
  2856                          linz23	= linz22+collen
  2857                          linz24	= linz23+collen
  2858                          
  2859                          ;****** color ram lines lo byte table ******
  2860  eb5f 00                 cldtb2:	!byte <linz0
  2861  eb60 28                 	!byte <linz1
  2862  eb61 50                 	!byte <linz2
  2863  eb62 78                 	!byte <linz3
  2864  eb63 a0                 	!byte <linz4
  2865  eb64 c8                 	!byte <linz5
  2866  eb65 f0                 	!byte <linz6
  2867  eb66 18                 	!byte <linz7
  2868  eb67 40                 	!byte <linz8
  2869  eb68 68                 	!byte <linz9
  2870  eb69 90                 	!byte <linz10
  2871  eb6a b8                 	!byte <linz11
  2872  eb6b e0                 	!byte <linz12
  2873  eb6c 08                 	!byte <linz13
  2874  eb6d 30                 	!byte <linz14
  2875  eb6e 58                 	!byte <linz15
  2876  eb6f 80                 	!byte <linz16
  2877  eb70 a8                 	!byte <linz17
  2878  eb71 d0                 	!byte <linz18
  2879  eb72 f8                 	!byte <linz19
  2880  eb73 20                 	!byte <linz20
  2881  eb74 48                 	!byte <linz21
  2882  eb75 70                 	!byte <linz22
  2883  eb76 98                 	!byte <linz23
  2884  eb77 c0                 	!byte <linz24
  2885                          
  2886                          ;****** color ram lines hi byte table ******
  2887  eb78 d8                 cldtb1:	!byte >linz0
  2888  eb79 d8                 	!byte >linz1
  2889  eb7a d8                 	!byte >linz2
  2890  eb7b d8                 	!byte >linz3
  2891  eb7c d8                 	!byte >linz4
  2892  eb7d d8                 	!byte >linz5
  2893  eb7e d8                 	!byte >linz6
  2894  eb7f d9                 	!byte >linz7
  2895  eb80 d9                 	!byte >linz8
  2896  eb81 d9                 	!byte >linz9
  2897  eb82 d9                 	!byte >linz10
  2898  eb83 d9                 	!byte >linz11
  2899  eb84 d9                 	!byte >linz12
  2900  eb85 da                 	!byte >linz13
  2901  eb86 da                 	!byte >linz14
  2902  eb87 da                 	!byte >linz15
  2903  eb88 da                 	!byte >linz16
  2904  eb89 da                 	!byte >linz17
  2905  eb8a da                 	!byte >linz18
  2906  eb8b da                 	!byte >linz19
  2907  eb8c db                 	!byte >linz20
  2908  eb8d db                 	!byte >linz21
  2909  eb8e db                 	!byte >linz22
  2910  eb8f db                 	!byte >linz23
  2911  eb90 db                 	!byte >linz24
  2912                          ; -------------------------------------------------------------------------------------------------
  2913                          ; Dispatch table (control codes $00-$1F, $80-$9F)
  2914  eb91 b1e3               ctable:	!word cuser-1
  2915  eb93 abe7               	!word chkcol-1		; -/orange
  2916  eb95 d1e7               	!word scrsw-1		; enable/disable scrolling
  2917  eb97 6ae7               	!word stprun-1		; stop/run
  2918  eb99 b1e3               	!word cuser-1 
  2919  eb9b abe7               	!word chkcol-1		; white/F1
  2920  eb9d b1e3               	!word cuser-1		; -/F3
  2921  eb9f b1e3               	!word cuser-1		; -/F5
  2922  eba1 b1e3               	!word cuser-1		; -/F7
  2923  eba3 b1e3               	!word cuser-1		; -/F2
  2924  eba5 b1e3               	!word cuser-1		; -/F4
  2925  eba7 b1e3               	!word cuser-1		; -/F6
  2926  eba9 b1e3               	!word cuser-1		; -/F8
  2927  ebab 14e4               	!word nxt1-1		; return or shifted return
  2928  ebad b1e3               	!word cuser-1
  2929  ebaf b1e3               	!word cuser-1		; 
  2930  ebb1 abe7               	!word chkcol-1		; -/black
  2931  ebb3 b4e3               	!word cdnup-1		; cursor down/up
  2932  ebb5 e4e3               	!word rvsf-1		; rvs on/off
  2933  ebb7 eae3               	!word homclr-1		; home/clr
  2934  ebb9 fce6               	!word delins-1		; delete/insert character
  2935  ebbb abe7               	!word chkcol-1		; -/brown
  2936  ebbd abe7               	!word chkcol-1		; -/lightred
  2937  ebbf abe7               	!word chkcol-1		; -/gray1
  2938  ebc1 abe7               	!word chkcol-1		; -/gray2
  2939  ebc3 abe7               	!word chkcol-1		; -/lightgreen
  2940  ebc5 abe7               	!word chkcol-1		; -/lightblue
  2941  ebc7 abe7               	!word chkcol-1		; -/gray3
  2942  ebc9 abe7               	!word chkcol-1		; red/purple
  2943  ebcb d1e3               	!word crtlf-1		; cursor right/left
  2944  ebcd abe7               	!word chkcol-1		; green/yellow
  2945  ebcf abe7               	!word chkcol-1		; blue/cyan
  2946                          ; -------------------------------------------------------------------------------------------------
  2947                          ; Length of function key texts
  2948  ebd1 04                 keylen: !byte key2-key1
  2949  ebd2 04                 	!byte key3-key2
  2950  ebd3 05                 	!byte key4-key3
  2951  ebd4 19                 	!byte key5-key4
  2952  ebd5 06                 	!byte key6-key5
  2953  ebd6 06                 	!byte key7-key6
  2954  ebd7 03                 	!byte key8-key7
  2955  ebd8 05                 	!byte keyend-key8
  2956                          
  2957                          ; Function key definitions
  2958                          keydef:
  2959  ebd9 52554e0d           key1:	!pet "run",cr					; F1
  2960  ebdd 4043443a           key2:	!pet "@cd:"					; F2
  2961  ebe1 4c4953540d         key3:	!pet "list",cr					; F3
  2962  ebe6 4fd0382c382c3135...key4:	!pet "oP8,8,15:pR8,",$22,"u0>",9,$22,":clO8",cr	; F4
  2963  ebff 444c4f414422       key5:	!pet "dload",$22				; F5
  2964  ec05 445341564522       key6:	!pet "dsave",$22				; F6
  2965  ec0b 40240d             key7:	!pet "@$",cr					; F7
  2966  ec0e 535953300d         key8:	!pet "sys0",cr					; F8
  2967                          keyend:
  2968                          ; -------------------------------------------------------------------------------------------------
  2969                          ; bits  -  bit position table
  2970  ec13 8040201008040201   bits:	!byte $80,$40,$20,$10,$08,$04,$02,$01
  2971                          ; -------------------------------------------------------------------------------------------------
  2972                          ; Color control code table
  2973                          ; blk,wht,red,cyan,magenta,grn,blue,yellow
  2974  ec1b 90051c9f9c1e1f9e   coltab:	!byte $90,$05,$1c,$9f,$9c,$1e,$1f,$9e
  2975                          ; org,brown,lred,gray1,gray2,lgreen,lblue,gray3
  2976  ec23 8195969798999a9b   	!byte $81,$95,$96,$97,$98,$99,$9a,$9b
  2977                          ; rsr modify for vic-40 system			*** Just for fun from rev.1 c64-kernal rev.1 ;) ***
  2978                          ; rsr 12/31/81 add 8 more colors
  2979                          ; -------------------------------------------------------------------------------------------------
  2980                          ; 8-bit Colors for mode 6
  2981                          col8bit:
  2982  ec2b 00ff3ce757cd43fd   	!byte $00,$ff,$3c,$e7,$57,$cd,$43,$fd	; black, white, red, cyan, violet, green, 6=blue, yellow
  2983  ec33 7c587d246ded8bb6   	!byte $7c,$58,$7d,$24,$6d,$ed,$8b,$b6	; orange, brown, ltred, dkgrey, grey, ltgreen, ltblue, ltgrey
  2984                          ; ***************************************** ZONE VDP **********************************************
  2985                          !zone vdpeditor
  2986                          ; init vdp
  2987  ec3b a900               vinit:	lda #0
  2988  ec3d aa                 	tax
  2989  ec3e 8d01dca9918d01dc   	+VdpSetReg 17			; write VDP regs fast indirect
  2990  ec46 ea                 	+VdpWait WAIT23,7-1
  2991  ec47 bd9fee             vinilp:	lda VdpInitData,x
  2992  ec4a 8d03dc             	sta VDPIndirect
  2993  ec4d e8                 	inx
  2994  ec4e e00f               	cpx #VdpInitDataEnd-VdpInitData
  2995                          	+VdpWait WAIT23,14
  2996  ec50 d0f5               	bne vinilp
  2997                          	
  2998  ec52 a90d               	lda #VDPREG18
  2999                          	+VdpWait WAIT23,11-1
  3000  ec54 8d01dca9928d01dc   	+VdpSetReg 18			; set register 18 V/H display adjust L 7-1,0,f-8 R
  3001                          ; clear 128kB VRAM (in mode 6/7 complete autoincrement)
  3002  ec5c a000               	ldy #$00
  3003  ec5e 98                 	tya
  3004  ec5f aa                 	tax
  3005                          	+VdpWait WAIT23,9-1
  3006  ec60 8e01dc09408d01dc   	+VdpWriteAddress		; set VRAM write address to $AAXX = $0000, Bank Reg already 0
  3007  ec68 a902               	lda #$2				; 2x $10000 VRAM to clear
  3008  ec6a 85f0               	sta temp1			; A16 counter
  3009  ec6c 98                 	tya				; VRAM init value =$00
  3010                          	; x, y already 0
  3011  ec6d eaeaeaeaea         	+VdpWait WAITVRAM1,10
  3012  ec72 8d00dc             viramlp:sta VDPRamWrite
  3013  ec75 e8                 	inx
  3014  ec76 eaeaeaeaeaea       	+VdpWait WAITVRAM,8
  3015  ec7c d0f4               	bne viramlp
  3016  ec7e c8                 	iny
  3017  ec7f d0f1               	bne viramlp
  3018  ec81 c6f0               	dec temp1			; dec A16 counter
  3019  ec83 d0ed               	bne viramlp
  3020                          ; y already 0
  3021  ec85 98                 	tya				; a=0
  3022  ec86 85eb               	sta lastvbank			; remember last vram bank
  3023                          	+VdpWait WAIT23,23-1	
  3024  ec88 8d01dca98e8d01dc   	+VdpSetReg 14			; set VRAM bank register to 0
  3025                          	; x, y already 0
  3026  ec90 98                 	tya				; a=0
  3027  ec91 8d01dca9908d01dc   	+VdpSetReg 16			; set VDP register 16 = palette pointer to $00 
  3028  ec99 ea                 	+VdpWait WAIT23,7-1	
  3029  ec9a bdaeee             vipallp:lda PaletteData,x		; load palette-color to write
  3030  ec9d 8d02dc             	sta VDPPalette
  3031  eca0 e8                 	inx
  3032  eca1 e020               	cpx #PaletteDataEnd-PaletteData	; finished ?
  3033                          	+VdpWait WAIT23,14	
  3034  eca3 d0f5               	bne vipallp			; ..no -> next color
  3035                          ; init vars
  3036  eca5 a000               	ldy #<(!MODE<<7)		; shift startup mode to bit#7 and inverse to force mode set
  3037  eca7 84ea               	sty mode			; store mode flag
  3038  eca9 a9c8               	lda #>font			; default font in ROM
  3039  ecab 8d8e03             	sta userfont_adr+1
  3040                          	
  3041  ecae a900               	lda #0
  3042  ecb0 a020               	ldy #SPRITES
  3043  ecb2 996103             visprlp:sta sprite_flags,y		; clear all sprite flags
  3044  ecb5 88                 	dey
  3045  ecb6 d0fa               	bne visprlp
  3046                          
  3047  ecb8 85f6               	sta sizex			; size x lo = zero
  3048  ecba 85f8               	sta x0
  3049  ecbc 85f2               	sta y0
  3050  ecbe 85d1               	sta tblx			; reset cursor
  3051  ecc0 85d2               	sta pntr
  3052  ecc2 8d8d03             	sta userfont_adr
  3053                          	
  3054  ecc5 a9e7               	lda #TEXTCOL			; default color
  3055  ecc7 85cf               	sta color
  3056  ecc9 a900               	lda #BGRCOL			; default background color
  3057  eccb 85ee               	sta bgcolor
  3058  eccd 8d8b03             	sta bgcolor_del
  3059                          
  3060                          !if MODE=6 {				; default left colors mode 6
  3061                          	lda #(BGRCOL<<4)
  3062                          	sta bgcolor_left
  3063                          	lda #(BGRCOL<<4)+BGRCOL		; double background color for vdp commands
  3064                          	sta bgcolor_del
  3065                          }	
  3066  ecd0 a900               	lda #EXTCOL			; a backdrop color
  3067  ecd2 a005               	ldy #((MODE&$01)<<2|PAL<<1)+1	; y = mode, bit#0=0 screen off
  3068                          ; set mode, backdrop bgcolor
  3069  ecd4 8d01dca9878d01dc   vmode:	+VdpSetReg 7			; set reg 7 backdrop color
  3070  ecdc 98                 	tya
  3071  ecdd 48                 	pha				; remember mode
  3072  ecde 2904               	and #$04			; isolate graphics 6/7 bit
  3073  ece0 85f0               	sta temp1			; remember
  3074  ece2 0a                 	asl				; shift to bit#7
  3075  ece3 0a                 	asl
  3076  ece4 0a                 	asl
  3077  ece5 0a                 	asl
  3078  ece6 0a                 	asl
  3079  ece7 c5ea               	cmp mode			; check graphics mode
  3080  ece9 f03c               	beq vmpalnt			; ..no change -> skip
  3081                          	
  3082  eceb 85ea               	sta mode			; store new mode
  3083  eced a901               	lda #>SIZEX7			; default mode7 sizex
  3084  ecef a228               	ldx #COLUMNS7			; default mode7 columns
  3085  ecf1 24ea               	bit mode			; check mode
  3086  ecf3 3003               	bmi vmode7			; -> skip if mode7
  3087  ecf5 a250               	ldx #COLUMNS6			; mode6 columns
  3088  ecf7 0a                 	asl				; double size x for mode6
  3089  ecf8 85f7               vmode7:	sta sizex+1			; store size x hi
  3090  ecfa 86ec               	stx columns			; store screen columns
  3091  ecfc ca                 	dex
  3092  ecfd 86ed               	stx scxmax			; store last screen column
  3093  ecff a90a               	lda #VDPREG0			; base value
  3094  ed01 05f0               	ora temp1			; add graphics 6/7 bit
  3095  ed03 8d01dca9808d01dc   	+VdpSetReg 0			; set new graphics mode in reg 0
  3096                          
  3097                          ; calculate screen line table	
  3098  ed0b a0d0               	ldy #>scnram			; screen base
  3099  ed0d a900               	lda #<scnram
  3100  ed0f a200               	ldx #0				; line index
  3101  ed11 9dc303             vmlnlp:	sta ldtb2,x			; store low to table
  3102  ed14 48                 	pha
  3103  ed15 98                 	tya
  3104  ed16 9daa03             	sta ldtb1,x			; store line high
  3105  ed19 68                 	pla
  3106  ed1a e8                 	inx
  3107  ed1b e019               	cpx #25				; last line?
  3108  ed1d f008               	beq vmpalnt			; yes
  3109  ed1f 18                 	clc
  3110  ed20 65ec               	adc columns			; add columns
  3111  ed22 90ed               	bcc vmlnlp
  3112  ed24 c8                 	iny				; inc high
  3113  ed25 b0ea               	bcs vmlnlp			; always
  3114                          
  3115  ed27 68                 vmpalnt:pla				; get mode
  3116  ed28 a8                 	tay				; remember in y
  3117  ed29 2902               	and #$02			; isolate NTSC/PAL bit
  3118  ed2b 0980               	ora #VDPREG9			; add lines bit
  3119                          	+VdpWait WAIT23,39-1
  3120  ed2d 8d01dca9898d01dc   	+VdpSetReg 9
  3121                          
  3122  ed35 98                 	tya
  3123  ed36 2908               	and #$08			; isolate yjk-bit
  3124  ed38 ea                 	+VdpWait WAIT23,7-1
  3125  ed39 8d01dca9998d01dc   	+VdpSetReg 25			; set yjk
  3126                          
  3127  ed41 98                 	tya				; get mode again
  3128  ed42 2901               	and #$01			; isolate on/off bit
  3129                          	+VdpWait WAIT23,11-1
  3130  ed44 d00b               	bne vmscron			; -> screen on		
  3131                          ; off				; *** disable screen ***
  3132  ed46 a902               	lda #VDPREG1 & $bf		; set mode reg 1 (M1+M2), bit#6 = 0 disables screen
  3133  ed48 8d01dca9818d01dc   	+VdpSetReg 1
  3134  ed50 60                 	rts
  3135                          vmscron:
  3136                          ; on				; *** enable screen ***
  3137  ed51 a942               	lda #VDPREG1 | $40		; set mode reg 1 (M1+M2), bit#6 = 1 enables screen
  3138  ed53 8d01dca9818d01dc   	+VdpSetReg 1
  3139  ed5b 60                 	rts
  3140                          ; -------------------------------------------------------------------------------------------------
  3141                          ; clear screen with backgroundcolor
  3142  ed5c a9d4               vclear:	lda #SIZEY
  3143  ed5e 85f5               	sta dy
  3144                          					; call from uprint clears only text screen area
  3145  ed60 a9208d01dca9918d...	+VdpCommand zero, zero, zero, zero, zero, zero, sizex, sizex+1, dy, bgcolor_del, zero, HMMV
  3146                          	
  3147  edcb 20d7e2             	jsr clrscr			; clear screen+color ram
  3148  edce 4c8bee             	jmp waitcmd			; wait for command execution
  3149                          ; ----------------------------------------------------------------------------
  3150                          ; display a char on VDP screen
  3151                          ;   a = char, x = color
  3152                          vchar:
  3153                          ; calc char start address in font
  3154  edd1 48                 	pha				; remember char
  3155  edd2 86f0               	stx temp1			; remember color
  3156  edd4 85c1               	sta source_pointer		; store char to source pointer
  3157  edd6 a200               	ldx #$00
  3158  edd8 86c2               	stx source_pointer+1
  3159  edda 0a                 	asl				; *8 for char position in font
  3160  eddb 26c2               	rol source_pointer+1
  3161  eddd 0a                 	asl
  3162  edde 26c2               	rol source_pointer+1
  3163  ede0 0a                 	asl
  3164  ede1 26c2               	rol source_pointer+1
  3165  ede3 18                 	clc
  3166  ede4 6d8d03             	adc userfont_adr		; add userfont baseaddress
  3167  ede7 85c1               	sta source_pointer
  3168  ede9 a5c2               	lda source_pointer+1
  3169  edeb 6d8e03             	adc userfont_adr+1
  3170  edee 85c2               	sta source_pointer+1
  3171                          ; calc x
  3172  edf0 a5d2               	lda pntr			; get column
  3173  edf2 0a                 	asl				; *3 (char byte width mode 6)
  3174  edf3 18                 	clc
  3175  edf4 65d2               	adc pntr
  3176  edf6 24ea               	bit mode			; check mode
  3177  edf8 1001               	bpl +				; skip mode 6
  3178  edfa 0a                 	asl				; *2 (*6 total) (width mode 7)
  3179  edfb 85fa               +	sta x1
  3180                          ; calc y	
  3181  edfd a5d1               	lda tblx			; get row
  3182  edff 0a                 	asl				; *8 (userfont height)
  3183  ee00 0a                 	asl
  3184  ee01 0a                 	asl
  3185  ee02 85f3               	sta y1
  3186                          
  3187  ee04 a200               	ldx #0
  3188  ee06 86f1               	stx temp2			; clear char line counter
  3189                          ; set vram address
  3190  ee08 29c0               	and #$c0			; isolate bit 6+7 (16k bank)
  3191  ee0a c5eb               	cmp lastvbank			; same bank like last line ?
  3192  ee0c f00d               	beq vchlp			; ..yes -> skip set bank
  3193  ee0e 85eb               	sta lastvbank			; remember bank
  3194                          ; set bank
  3195  ee10 0a                 	asl				; address bits 14+15 -> bit 0+1 (bank)
  3196  ee11 2a                 	rol
  3197  ee12 2a                 	rol
  3198  ee13 8d01dca98e8d01dc   	+VdpSetReg 14			; set VRAM bank
  3199                          	+VdpWait WAIT23,14
  3200                          ; set address (bank never changes inside a row)
  3201  ee1b a5f3               vchlp:	lda y1				; get y line
  3202  ee1d 293f               	and #$3f			; remove VRAM address bit 14+15
  3203  ee1f a6fa               	ldx x1
  3204  ee21 a4f1               	ldy temp2			; get char line counter
  3205  ee23 8e01dc09408d01dc   	+VdpWriteAddress
  3206  ee2b 24ea               	bit mode			; check mode
  3207  ee2d 1023               	bpl vchmod6			; write char mode 6
  3208                          ; write char mode 7
  3209  ee2f a206               	ldx #FONTW			; set bit counter
  3210  ee31 b1c1               	lda (source_pointer),y		; load data byte
  3211  ee33 4a                 	lsr				; shift one right for first shift left in loop
  3212  ee34 a4ee               	ldy bgcolor			; load bgcolor as default
  3213                          	+VdpWait WAITVRAM1,25-1
  3214  ee36 0a                 vchpxlp:asl
  3215  ee37 1002               	bpl vchpix
  3216  ee39 a4f0               	ldy temp1			; set pixel
  3217  ee3b 8c00dc             vchpix:	sty VDPRamWrite			; write color
  3218  ee3e a4ee               	ldy bgcolor			; default for clear pixel
  3219  ee40 ca                 	dex
  3220  ee41 eaea               	+VdpWait WAITVRAM,16
  3221  ee43 d0f1               	bne vchpxlp			; next bit
  3222                          ; check last line of print char reached
  3223  ee45 a6f1               	ldx temp2			; get char line counter
  3224  ee47 e8                 	inx				; inc line
  3225  ee48 e008               	cpx #FONTH			; finished char ?
  3226  ee4a f03d               	beq vchx			; ..yes -> x to next column
  3227                          ; next line
  3228  ee4c 86f1               	stx temp2			; store new char line counter
  3229  ee4e e6f3               	inc y1				; next y
  3230  ee50 d0c9               	bne vchlp			; always -> next char line
  3231                          ; write char mode 6
  3232  ee52 a5f0               vchmod6:lda temp1			; get color
  3233  ee54 0a                 	asl				; shift to high nibble
  3234  ee55 0a                 	asl
  3235  ee56 0a                 	asl
  3236  ee57 0a                 	asl
  3237  ee58 85f4               	sta temp3			; remember left nibble color
  3238  ee5a a203               	ldx #FONTW/2			; set 2pixel counter
  3239  ee5c b1c1               	lda (source_pointer),y		; load data byte
  3240  ee5e 4a                 	lsr				; shift one right for first shift left in loop
  3241  ee5f a4ef               	ldy bgcolor_left		; load bgcolor as default
  3242                          	+VdpWait WAITVRAM1,45-1
  3243  ee61 0a                 vch6plp:asl
  3244  ee62 1002               	bpl vchpixl
  3245  ee64 a4f4               	ldy temp3			; set pixel
  3246  ee66 84f5               vchpixl:sty temp4			; remember left pixel
  3247                          ; right pixel
  3248  ee68 a4ee               	ldy bgcolor			; load bgcolor as default
  3249  ee6a 0a                 	asl
  3250  ee6b 1002               	bpl vchpixr
  3251  ee6d a4f0               	ldy temp1			; set pixel
  3252  ee6f 48                 vchpixr:pha				; remember source byte
  3253  ee70 98                 	tya				; move to a
  3254  ee71 05f5               	ora temp4			; add left pixel
  3255  ee73 8d00dc             	sta VDPRamWrite			; write color
  3256  ee76 68                 	pla				; restore source byte
  3257  ee77 a4ef               	ldy bgcolor_left		; default for clear pixel
  3258  ee79 ca                 	dex
  3259                          	+VdpWait WAITVRAM,39-1
  3260  ee7a d0e5               	bne vch6plp			; next 2pixel
  3261                          ; check last line of print char reached
  3262  ee7c a6f1               	ldx temp2			; char line counter
  3263  ee7e e8                 	inx				; inc line
  3264  ee7f e008               	cpx #FONTH			; finished char ?
  3265  ee81 f006               	beq vchx			; ..yes -> x to next column
  3266                          ; next line
  3267  ee83 86f1               	stx temp2			; store new char line counter
  3268  ee85 e6f3               	inc y1				; next y
  3269  ee87 d092               	bne vchlp			; always -> next char line
  3270                          ; both modes
  3271                          ; char finished
  3272  ee89 68                 vchx:	pla				; restore char
  3273  ee8a 60                 	rts
  3274                          ; -------------------------------------------------------------------------------------------------
  3275                          ; wait for command execution finished
  3276                          waitcmd:
  3277  ee8b a902               	lda #2
  3278                          	+VdpWait WAIT23,8
  3279  ee8d 8d01dca98f8d01dc   	+VdpSetReg 15			; reg 15 = 2 initiates read status-reg 2
  3280  ee95 eaeaea             	+VdpWait WAIT23,3-1		; wait for DVP
  3281  ee98 ad81dc             vrdylp:	lda VDPStatus			; read status
  3282  ee9b 4a                 	lsr				; command execute bit#0 in c
  3283  ee9c b0fa               	bcs vrdylp			; not finished -> wait
  3284  ee9e 60                 	rts
  3285                          ; **************************************** ZONE VDP-DATA ******************************************
  3286                          !zone vdpdata
  3287                          ; vdp-data
  3288                          VdpInitData:	; graphics7-mode
  3289  ee9f 0e021f8000f71e00...!byte VDPREG0|(MODE&$01)<<2,VDPREG1,$1f,$80,$00,$f7,$1e,$00,$28,VDPREG9|PAL<<1,$00,$01,$10,$f0,$00
  3290                          	; reg  0: $0a mode control 0: bit#1-3=M3,M4,M5: mode 6=101, mode 7=111
  3291                          	; reg  1: $00 mode control 1: mode 7 (bit#3 M2 = 0, bit#4 M1 = 0, bit#6 = 1, display enable)
  3292                          	;             (bit#1 = 1 sprite size 16x16, bit#0 = 0 sprites not magnified, bit#5 = 0 virq off)
  3293                          	; reg  2: $1f BitmapData table base address $0000 (bit#5 * $10000, bit#0-4 = 1)
  3294                          	; reg  3: $ff color table base address $FFC0 (* $40)
  3295                          	; reg  4: $00 pattern (character) generator table base address $0000 (* $800)
  3296                          	; reg  5: $f7 sprite attribute table base address $FA00 (* $80) - Sprite color table = -200 -> $F800
  3297                          	; reg  6: $1e sprite pattern (data) generator base address = $F000 (* $800)
  3298                          	; reg  7: $00 8bit backdrop color 
  3299                          	; reg  8: $28 mode control 2: refresh bit#3 = 1: 64k VRAM chips, bit#2 = 0 sprites not disabled
  3300                          	;             bit#5=1 color 0 not transparent (mode6)
  3301                          	; reg  9: $80 mode control 3: bit#1 = NTSC/PAL, #2 = EVEN/ODD, #3 = interlace, #7 = 192/212 lines
  3302                          	; reg 10: $03 color table base address $F800 bit#0-2 = A14-A16
  3303                          	; reg 11: $01 sprite attribute table base address $FA00 bit#0-1 = A15-A16
  3304                          	; reg 12: $10 text/background blink color
  3305                          	; reg 13: $f0 blink periods ON/OFF - f0 = blinking off
  3306                          	; reg 14: $00 VRAM write addresss bit#0-2 = A14-A16
  3307                          VdpInitDataEnd:
  3308                          ; ***** Color Palette - 16 colors, 2 byte/color: RB, 0G each 3bit -> C64 VICII-colors *****
  3309                          PaletteData:
  3310  eeae 0000770770011706   	!byte $00,$00,$77,$07,$70,$01,$17,$06	;	0=black		1=white		2=red		3=cyan
  3311  eeb6 5602320606027207   	!byte $56,$02,$32,$06,$06,$02,$72,$07	;	4=violet	5=green		6=blue		7=yellow
  3312  eebe 7003600272031101   	!byte $70,$03,$60,$02,$72,$03,$11,$01	;	8=orange	9=brown		a=lightred	b=darkgrey
  3313  eec6 3303520727045505   	!byte $33,$03,$52,$07,$27,$04,$55,$05	;	c=grey		d=litegreen	e=lightblue	f=lightgrey
  3314                          PaletteDataEnd:
  3315                          ; ****************************************** KERNAL ***********************************************
  3316                          ;***************************************
  3317                          ;*                                     *
  3318                          ;* KK  K EEEEE RRRR  NN  N  AAA  LL    *
  3319                          ;* KK KK EE    RR  R NNN N AA  A LL    *
  3320                          ;* KKK   EE    RR  R NNN N AA  A LL    *
  3321                          ;* KKK   EEEE  RRRR  NNNNN AAAAA LL    *
  3322                          ;* KK K  EE    RR  R NN NN AA  A LL    *
  3323                          ;* KK KK EE    RR  R NN NN AA  A LL    *
  3324                          ;* KK KK EEEEE RR  R NN NN AA  A LLLLL *
  3325                          ;*                                     *
  3326                          ;***************************************
  3327                          ;***************************************
  3328                          ;* CBM KERNAL                          *
  3329                          ;*   MEMORY AND I/O DEPENDENT ROUTINES *
  3330                          ;* DRIVING THE HARDWARE OF THE         *
  3331                          ;* FOLLOWING MODEL : LC256             *
  3332                          ;* COPYRIGHT (C) 1983 BY CBM           *
  3333                          ;* COPYRIGHT (C) 2024 Vossi, Baleares  *
  3334                          ;***************************************
  3335                          ;
  3336                          ; ##### monitor #####
  3337                          !zone kernal
  3338                          ;************************************************
  3339                          ;* kernal monitor                               *
  3340                          ;*                                              *
  3341                          ;* entry via call (jmp) or breakpoint (brk)     *
  3342                          ;* ---functions---                              *
  3343                          ;* <:>      alter memory                        *
  3344                          ;* <;>      alter registers                     *
  3345                          ;* <.>      alter assembly                      *
  3346                          ;* <r>      display registers                   *
  3347                          ;* <m>      display memory                      *
  3348                          ;* <a>      assemble                            *
  3349                          ;* <d>      disassemble                         *
  3350                          ;* <g>      start execution of code             *
  3351                          ;* <j>      start subroutine (jsr)              *
  3352                          ;* <t>      transfer memory                     *
  3353                          ;* <c>      compare memory                      *
  3354                          ;* <f>      fill memory                         *
  3355                          ;* <h>      hunt memory                         *
  3356                          ;* <l>      load                                *
  3357                          ;* <s>      save                                *
  3358                          ;* <v>      verify                              *
  3359                          ;* <b>      select RAM 0 bank (0-15)            *
  3360                          ;* <@>      disk command (@$ directory)         *
  3361                          ;* <x>      warm start basic                    *
  3362                          ;* <u>      set default disk unit               *
  3363                          ;*                                              *
  3364                          ;* for syntax & semantics see cbm kernal manual *
  3365                          ;* copyright (c) 1981 by cbm                    *
  3366                          ;************************************************
  3367                          ; Reset Entry
  3368                          *= kernal+$f00
  3369                          
  3370                          ; ***** Warm start entry *******
  3371  ef00 20bafd             monon:	jsr ioinit		; get i/o
  3372  ef03 20d4fe             	jsr restor		; vectors
  3373  ef06 2004e0             	jsr jcint		; screen editor
  3374                          
  3375                          ; ***** Cold start entry ******
  3376  ef09 20ccff             monoff:	jsr clrch		; clear channels
  3377  ef0c a95a               	lda #winit		; waste two bytes so timc=60950
  3378  ef0e a200               	ldx #<monon		; point reset vectors at monitor on
  3379  ef10 a0ef               	ldy #>monon
  3380  ef12 20f4fe             	jsr vreset
  3381  ef15 58                 	cli			; release irq's
  3382                          
  3383                          ; ***** Call entry *****
  3384  ef16 a9c0               timc:	lda #$40+$80
  3385  ef18 8d5d03             	sta msgflg		; error+messages on
  3386  ef1b a940               	lda #ms34-ms1		; call entry
  3387  ef1d 85b6               	sta tmpc
  3388  ef1f d01d               	bne b3			; branch always
  3389                          
  3390                          ; ***** Break entry *****
  3391  ef21 20ccff             timb:	jsr clrch		; clr channels
  3392  ef24 a959               	lda #ms36-ms1		; break entry
  3393  ef26 85b6               	sta tmpc
  3394  ef28 d8                 	cld 
  3395                          
  3396                          ; Save .y,.x,.a,flags, and pc
  3397  ef29 a205               	ldx #5
  3398                          ; Pop registers from stack and save them
  3399  ef2b 68                 b1:	pla
  3400  ef2c 95a7               	sta pch,x
  3401  ef2e ca                 	dex
  3402  ef2f 10fa               	bpl b1
  3403                          	
  3404  ef31 38                 	sec
  3405  ef32 a5a8               	lda pcl			; pc -1 for correct reentry address after break
  3406  ef34 e901               	sbc #1
  3407  ef36 85a8               	sta pcl
  3408  ef38 a5a7               	lda pch
  3409  ef3a e900               	sbc #0
  3410  ef3c 85a7               	sta pch
  3411                          
  3412                          
  3413  ef3e ad0003             b3:	lda cinv
  3414  ef41 85af               	sta invl		; save irq low
  3415  ef43 ad0103             	lda cinv+1
  3416  ef46 85ae               	sta invh		; save irq high
  3417                          
  3418  ef48 ba                 	tsx
  3419  ef49 86ad               	stx sp			; save original sp
  3420  ef4b 58                 	cli			; clear ints
  3421  ef4c a908               	lda #8			; set disk default to 8
  3422  ef4e 85b7               	sta ddisk
  3423                          
  3424  ef50 a4b6               b5:	ldy tmpc		; message code
  3425  ef52 20dbf3             	jsr spmsg		; print break/call
  3426                          
  3427  ef55 a952               	lda #'r'		; display regs on entry
  3428  ef57 d01f               	bne s0			; branch always
  3429                          ; ***** Error entry *****
  3430                          
  3431  ef59 200df0             erropr:	jsr outqst
  3432  ef5c 68                 	pla
  3433  ef5d 68                 	pla
  3434                          
  3435                          ; ***** Command interpreter entry *****
  3436                          strtm1=*-1
  3437  ef5e a9c0               	lda #$40+$80
  3438  ef60 8d5d03             	sta msgflg		; i/o messages to screen
  3439  ef63 a900               	lda #<buf		; put filename at bottom of basic buffer
  3440  ef65 8590               	sta fnadr
  3441  ef67 a902               	lda #>buf
  3442  ef69 8591               	sta fnadr+1
  3443  ef6b 2010f0             	jsr crlf
  3444                          
  3445  ef6e 205bf3             st1:	jsr gnc			; read command
  3446                          
  3447  ef71 c920               	cmp #' '
  3448  ef73 f0f9               	beq st1			; span blanks
  3449  ef75 6c1e03             	jmp (usrcmd)		; user indirect for monitor
  3450                          ; -------------------------------------------------------------------------------------------------
  3451                          ; Command interpreter
  3452  ef78 a200               s0:	ldx #0
  3453  ef7a 869c               	stx fnlen
  3454  ef7c a8                 	tay			; save current command
  3455                          
  3456                          ; Put return address for commands on stack
  3457  ef7d a9ef               	lda #>strtm1
  3458  ef7f 48                 	pha
  3459  ef80 a95d               	lda #<strtm1
  3460  ef82 48                 	pha
  3461                          
  3462  ef83 98                 	tya			; current command in .a
  3463                          
  3464  ef84 dda3ef             s1:	cmp cmds,x		; is it this one?
  3465  ef87 d010               	bne s2			; notit
  3466                          
  3467  ef89 8d9403             	sta savx		; save current command
  3468                          
  3469                          ; Indirect jmp from table
  3470  ef8c bda4ef             	lda cmds+1,x
  3471  ef8f 85b0               	sta tmp0
  3472  ef91 bda5ef             	lda cmds+2,x
  3473  ef94 85b1               	sta tmp0+1
  3474  ef96 6cb000             	jmp (tmp0)
  3475                          
  3476                          ; Each table entry is 3 long---skip to next
  3477  ef99 e8                 s2:	inx
  3478  ef9a e8                 	inx
  3479  ef9b e8                 	inx
  3480  ef9c e03c               	cpx #cmdend-cmds
  3481  ef9e 90e4               	bcc s1			; loop for all commands
  3482                          ; Command not in table
  3483  efa0 4c59ef             	jmp erropr		; syntax error
  3484                          ; -------------------------------------------------------------------------------------------------
  3485                          ; Command table
  3486  efa3 3a                 cmds:	!pet ':'		; alter memory
  3487  efa4 1cf1               	!word altm
  3488  efa6 3b                 	!pet ";"		; alter registers
  3489  efa7 d2f0               	!word altr
  3490  efa9 2e                 	!pet '.'		; alter assembly
  3491  efaa 22c1               	!word assem
  3492  efac 52                 	!pet 'r'		; display registers
  3493  efad 30f0               	!word dsplyr
  3494  efaf 4d                 	!pet 'm'		; display memory
  3495  efb0 91f0               	!word dsplym
  3496  efb2 41                 	!pet 'a'		; assemble
  3497  efb3 22c1               	!word assem
  3498  efb5 44                 	!pet 'd'		; disassemble
  3499  efb6 90c2               	!word disasm
  3500  efb8 47                 	!pet 'g'		; start execution
  3501  efb9 42f1               	!word go
  3502  efbb 4a                 	!pet 'j'		; jsr to subroutine
  3503  efbc 65f1               	!word gosub
  3504  efbe 54                 	!pet 't'		; transfer memory
  3505  efbf 9ec4               	!word trnsfr
  3506  efc1 43                 	!pet 'c'		; compare memory
  3507  efc2 99c4               	!word compar
  3508  efc4 46                 	!pet 'f'		; fill memory
  3509  efc5 82f1               	!word fill
  3510  efc7 48                 	!pet 'h'		; hunt
  3511  efc8 f4c4               	!word hunt
  3512  efca 4c                 	!pet 'l'		; load
  3513  efcb a4f1               	!word ld
  3514  efcd 53                 	!pet 's'		; save 
  3515  efce a4f1               	!word ld
  3516  efd0 56                 	!pet 'v'		; verify
  3517  efd1 a4f1               	!word ld
  3518  efd3 42                 	!pet 'b'		; bank RAM0
  3519  efd4 f0f0               	!word bank
  3520  efd6 40                 	!pet '@'		; disk command (alternate)
  3521  efd7 6df2               	!word disk
  3522  efd9 58                 	!pet 'x'		; warm start basic
  3523  efda dfef               	!word xeit
  3524  efdc 55                 	!pet 'u'		; default disk unit set
  3525  efdd 06f1               	!word unitd
  3526                          cmdend:
  3527                          ; -------------------------------------------------------------------------------------------------
  3528                          ; Exit 'x'
  3529  efdf a900               xeit:	lda #0
  3530  efe1 a209               	ldx #9
  3531  efe3 956f               xcfaclp:sta hulp,x		; clear basic fac
  3532  efe5 ca                 	dex
  3533  efe6 10fb               	bpl xcfaclp
  3534                          
  3535  efe8 68                 	pla			; remove command return from stack
  3536  efe9 68                 	pla
  3537  efea 78                 	sei			; disable interrupts...all warm start code expects
  3538  efeb 6cf803             	jmp (evect)		; go warmstart language
  3539                          ; -------------------------------------------------------------------------------------------------
  3540                          ; Move tmp0/tmp0+1 to PC memory location
  3541  efee a5b0               putp:	lda tmp0		; move tmp0 to pch,pcl
  3542  eff0 85a8               	sta pcl
  3543  eff2 a5b1               	lda tmp0+1
  3544  eff4 85a7               	sta pch
  3545  eff6 60                 	rts
  3546                          ; -------------------------------------------------------------------------------------------------
  3547                          ; Set tmp2 to point to the saved regs in zero page
  3548  eff7 a9a9               setr:	lda #<flgs		; set to access regs
  3549  eff9 85b0               	sta tmp0
  3550  effb a900               	lda #>flgs
  3551  effd 85b1               	sta tmp0+1
  3552  efff a905               	lda #5
  3553  f001 60                 	rts
  3554                          ; -------------------------------------------------------------------------------------------------
  3555                          ; Prints '.:' or '.;' before data to permit alter after 'm' or 'r' command
  3556                          
  3557  f002 48                 altrit: pha			; preserve alter character
  3558  f003 2010f0             	jsr crlf
  3559  f006 68                 	pla
  3560  f007 20d2ff             	jsr bsout
  3561                          
  3562  f00a a920               space:  lda #' '		; output a space
  3563  f00c 2c                 	!byte $2C		; skip two bytes
  3564                          
  3565  f00d a93f               outqst: lda #'?'		; output question
  3566  f00f 2c                 	!byte $2C		; skip two bytes
  3567                          
  3568  f010 a90d               crlf:   lda #cr			; do carriage return
  3569  f012 4cd2ff             	jmp bsout
  3570                          ; -------------------------------------------------------------------------------------------------
  3571                          ; Data for register display heading
  3572  f015 0d2020             regk:	!pet cr,"  "		; 3 spaces
  3573  f018 2050432020495251...	!pet " pc "," irq "," sr ac xr yr sp"
  3574                          ; -------------------------------------------------------------------------------------------------
  3575                          ; Display register function 'r'
  3576  f030 a200               dsplyr:	ldx #0
  3577  f032 bd15f0             d2:	lda regk,x
  3578  f035 20d2ff             	jsr bsout		; print heading
  3579  f038 e8                 	inx
  3580  f039 e01b               	cpx #dsplyr-regk	; max length
  3581  f03b d0f5               	bne d2
  3582  f03d a93b               	lda #";"
  3583  f03f 2002f0             	jsr altrit		; allow alter after display
  3584  f042 a6a7               	ldx pch
  3585  f044 a4a8               	ldy pcl
  3586  f046 2024f3             	jsr putwrd		; print program counter
  3587  f049 a6ae               	ldx invh
  3588  f04b a4af               	ldy invl
  3589  f04d 2024f3             	jsr putwrd		; print irq vector
  3590  f050 20f7ef             	jsr setr		; set to print .p,.a,.x,.y,.s
  3591                          
  3592                          ; display memory subroutine
  3593  f053 85b6               dm:	sta tmpc
  3594  f055 a000               	ldy #0			; indirect index
  3595  f057 849c               	sty fnlen		; fnlen is zero-page crossing flag...
  3596  f059 b1b0               dm1:	lda (tmp0),y
  3597  f05b 2029f3             	jsr puthxs		; write byte of memory
  3598                          
  3599  f05e c8                 dm2:	iny
  3600  f05f c4b6               	cpy tmpc		; bytes finished?
  3601  f061 d0f6               	bne dm1			; ..no -> next byte
  3602                          
  3603  f063 a5b6               	lda tmpc
  3604  f065 c908               	cmp #8
  3605  f067 d027               	bne dmx			; no char with register display
  3606                          
  3607                          ; display character
  3608  f069 a000               	ldy #0
  3609  f06b b1b0               dmchar:	lda (tmp0),y		; re-get byte from memory
  3610  f06d 48                 	pha
  3611  f06e 297f               	and #$7f		; mask control characters ($00-$1f and $80-$9f)
  3612  f070 c920               	cmp #$20
  3613  f072 68                 	pla
  3614  f073 b002               	bcs dmctl
  3615  f075 a92e               	lda #'.'		; print control characters as '.'
  3616                          
  3617  f077 20d2ff             dmctl:	jsr bsout
  3618  f07a c8                 	iny
  3619  f07b c4b6               	cpy tmpc		; char finished?
  3620  f07d d0ec               	bne dmchar		; ..no -> next char
  3621                          ; increment indirect
  3622  f07f 18                 	clc
  3623  f080 a5b0               	lda tmp0
  3624  f082 65b6               	adc tmpc		; add bytes per line
  3625  f084 85b0               	sta tmp0
  3626  f086 a5b1               	lda tmp0+1
  3627  f088 6900               	adc #0
  3628  f08a 85b1               	sta tmp0+1
  3629  f08c 9002               	bcc dmx			; no zero page crossing
  3630  f08e c69c               	dec fnlen
  3631                          
  3632  f090 60                 dmx:	rts
  3633                          ; -------------------------------------------------------------------------------------------------
  3634                          ; Display memory function 'm'
  3635  f091 20e8c5             dsplym:	jsr parse		; read start adr
  3636  f094 b039               	bcs arrn		; ...err if no sa
  3637  f096 20d8f2             	jsr t2t2		; sa to tmp2
  3638                          
  3639                          ; allow user to type just one address
  3640  f099 20e8c5             	jsr parse		; read end adr
  3641  f09c 9008               	bcc dsp123		; good...no default
  3642                          
  3643  f09e a5b4               	lda tmp2
  3644  f0a0 85b0               	sta tmp0		; default low byte
  3645  f0a2 a5b5               	lda tmp2+1
  3646  f0a4 85b1               	sta tmp0+1		; default hi byte
  3647                          
  3648  f0a6 20d8f2             dsp123:	jsr t2t2		; sa to tmp0, ea to tmp2
  3649                          
  3650  f0a9 20e1ff             dsp1:	jsr stop		; stop key?
  3651  f0ac f020               	beq beqs1		; yes...break list
  3652                          
  3653  f0ae a93a               	lda #':'
  3654  f0b0 2002f0             	jsr altrit		; allow alter
  3655  f0b3 a6b1               	ldx tmp0+1
  3656  f0b5 a4b0               	ldy tmp0
  3657  f0b7 2024f3             	jsr putwrd		; write start address
  3658                          
  3659  f0ba a908               	lda #8			; count of bytes
  3660  f0bc 2053f0             	jsr dm			; display bytes
  3661                          
  3662  f0bf a59c               	lda fnlen		; check for zero-crossing
  3663  f0c1 d00b               	bne beqs1		; yup....
  3664  f0c3 38                 	sec
  3665  f0c4 a5b4               	lda tmp2
  3666  f0c6 e5b0               	sbc tmp0
  3667  f0c8 a5b5               	lda tmp2+1
  3668  f0ca e5b1               	sbc tmp0+1
  3669  f0cc b0db               	bcs dsp1		; end >= start
  3670                          
  3671  f0ce 60                 beqs1:	rts			; a.o.k. exit
  3672                          
  3673  f0cf 4c59ef             arrn:	jmp erropr		; syntax error jump
  3674                          ; -------------------------------------------------------------------------------------------------
  3675                          ; Alter register function ';'
  3676  f0d2 20e8c5             altr:	jsr parse		; read new pc
  3677  f0d5 b0f8               	bcs arrn		; ...no address=error
  3678                          
  3679  f0d7 20eeef             	jsr putp		; alter pc
  3680                          
  3681  f0da 20e8c5             	jsr parse		; read new irq
  3682  f0dd b0f0               	bcs arrn		; ...no address=error
  3683                          
  3684  f0df a5b0               	lda tmp0
  3685  f0e1 85af               	sta invl		; alter irq vector
  3686  f0e3 a5b1               	lda tmp0+1
  3687  f0e5 85ae               	sta invh
  3688                          
  3689  f0e7 20f7ef             	jsr setr		; set to alter r's
  3690  f0ea 20d8f2             	jsr t2t2		; flags adr in t2
  3691  f0ed 4c26f1             	jmp a4			; store regs
  3692                          ; -------------------------------------------------------------------------------------------------
  3693                          ; Select bank RAM 0 'b'
  3694  f0f0 20e8c5             bank:	jsr parse		; get a byte
  3695  f0f3 b0da               	bcs arrn		; ...if none...error
  3696  f0f5 c903               	cmp #2+1
  3697  f0f7 b0d6               	bcs arrn		; > 2 digits
  3698  f0f9 a5b0               	lda tmp0
  3699  f0fb c910               	cmp #mxbank		; compare range
  3700  f0fd b0d0               	bcs arrn		; too large
  3701  f0ff 8d9603             	sta temp		; store new bank
  3702  f102 2064fc             	jsr RestoreBank		; switch to RAM0 bank in temp	
  3703  f105 60                 	rts
  3704                          ; -------------------------------------------------------------------------------------------------
  3705                          ; Unit default for disk 'u'
  3706  f106 20e8c5             unitd:	jsr parse		; get a byte
  3707  f109 b0c4               	bcs arrn		; ...if none...error
  3708  f10b c903               	cmp #2+1
  3709  f10d b0c0               	bcs arrn		; > 2 digits
  3710  f10f a5b0               	lda tmp0
  3711  f111 c908               	cmp #8			; range 8-31
  3712  f113 90ba               	bcc arrn		; too small
  3713  f115 c920               	cmp #32
  3714  f117 b0b6               	bcs arrn		; too large
  3715  f119 85b7               	sta ddisk
  3716  f11b 60                 	rts
  3717                          ; -------------------------------------------------------------------------------------------------
  3718                          ; Alter memory - read adr and data ':'
  3719  f11c 20e8c5             altm:	jsr parse		; read alter adr
  3720  f11f b0ae               	bcs arrn		; ...if none...error
  3721  f121 20d8f2             	jsr t2t2		; adr in t2
  3722                          
  3723  f124 a908               	lda #8			; allow 8 bytes change
  3724                          
  3725                          ; common code for ':' and ';'
  3726  f126 85b6               a4:	sta tmpc		; number of bytes to change
  3727                          
  3728  f128 20e8c5             a5:	jsr parse		; read byte
  3729  f12b b014               	bcs a9			; eol or error
  3730  f12d c903               	cmp #2+1
  3731  f12f b010               	bcs a9			; > 2 digits  
  3732  f131 a5b0               	lda tmp0
  3733                          
  3734  f133 a000               	ldy #0
  3735  f135 91b4               	sta (tmp2),y		; store it away
  3736                          
  3737                          ; increment store address
  3738  f137 e6b4               	inc tmp2
  3739  f139 d002               	bne a6
  3740  f13b e6b5               	inc tmp2+1
  3741                          
  3742  f13d c6b6               a6:	dec tmpc		; count byte
  3743  f13f d0e7               	bne a5			; until zero
  3744  f141 60                 a9:	rts
  3745                          ; -------------------------------------------------------------------------------------------------
  3746                          ; Start execution function 'g'
  3747  f142 20e8c5             go:	jsr parse		; get addr
  3748  f145 b003               	bcs g1			; none...pc is address
  3749  f147 20eeef             	jsr putp		; move addr to p.c.
  3750                          
  3751  f14a a6ad               g1:	ldx sp
  3752  f14c 9a                 	txs			; orig or new sp value to sp
  3753                          
  3754  f14d 78                 	sei			; prevent disaster
  3755                          
  3756  f14e a5ae               	lda invh
  3757  f150 8d0103             	sta cinv+1		; set up irq vector
  3758  f153 a5af               	lda invl
  3759  f155 8d0003             	sta cinv
  3760                          
  3761                          ; get flags,pch,pcl,.a,.x,.y
  3762  f158 a200               	ldx #0
  3763  f15a b5a7               g2:	lda pch,x
  3764  f15c 48                 	pha			; everybody on stack
  3765  f15d e8                 	inx
  3766  f15e e006               	cpx #6
  3767  f160 d0f8               	bne g2
  3768                          
  3769                          ; interrupt return sets everybody up from data on stack
  3770  f162 4c1cff             	jmp prend
  3771                          ; -------------------------------------------------------------------------------------------------
  3772                          ; Jsr command 'j' - start executing at supplied address or (default) the current contents of the PC
  3773  f165 20e8c5             gosub:	jsr parse		; get addr
  3774  f168 b003               	bcs gosub1		; none...pc is address
  3775  f16a 20eeef             	jsr putp		; move addr to p.c.
  3776                          
  3777                          ; set flags,pc,.a,.x,.y
  3778  f16d a5a9               gosub1:	lda flgs		; flags
  3779  f16f 48                 	pha
  3780  f170 a5a8               	lda pcl			; PC
  3781  f172 85b0               	sta tmp0
  3782  f174 a5a7               	lda pch
  3783  f176 85b1               	sta tmp0+1
  3784  f178 a6ab               	ldx xr			; regs
  3785  f17a a4ac               	ldy yr
  3786  f17c a5aa               	lda acc
  3787  f17e 28                 	plp
  3788  f17f 6cb000             	jmp (tmp0)
  3789                          ; -------------------------------------------------------------------------------------------------
  3790                          ; fill memory
  3791                          ;   syntax: f ssss eeee	vv = start eeee value
  3792  f182 20c4c5             fill:	jsr range		; get sa in tmp2, calculate length, put in tmp1
  3793  f185 b01a               	bcs errl1		; ...none=error
  3794  f187 20e8c5             	jsr parse		; get fill value
  3795  f18a b015               	bcs errl1		; ...none=error
  3796  f18c c903               	cmp #2+1
  3797  f18e b011               	bcs errl1		; > 2 digits
  3798                          
  3799  f190 a000               	ldy #0
  3800  f192 a5b0               fillp:	lda tmp0
  3801  f194 91b4               	sta (tmp2),y
  3802  f196 2016f3             	jsr inct2
  3803  f199 b006               	bcs errl1		; disallow bank-wrapping operations
  3804  f19b 2008f3             	jsr dect1
  3805  f19e b0f2               	bcs fillp
  3806                          
  3807  f1a0 60                 	rts
  3808                          
  3809  f1a1 4c59ef             errl1:	jmp erropr
  3810                          ; -------------------------------------------------------------------------------------------------
  3811                          ; Load ram function 'l' and 's'
  3812  f1a4 a4b7               ld:	ldy ddisk
  3813  f1a6 849e               	sty fa			; default device u
  3814  f1a8 a000               	ldy #0			; .y=0 to count name length
  3815  f1aa 849c               	sty fnlen		; reset file name length
  3816                          
  3817  f1ac 205bf3             l1:	jsr gnc			; get char
  3818  f1af f0f0               	beq errl1		; command only -> syntax error
  3819                          
  3820  f1b1 c920               	cmp #' '
  3821  f1b3 f0f7               	beq l1			; span blanks
  3822                          
  3823  f1b5 c922               	cmp #$22 ; "		; string next?
  3824  f1b7 d0e8               l2:	bne errl1		; no file name...
  3825                          
  3826  f1b9 205bf3             l3:	jsr gnc			; get character of name
  3827  f1bc f00f               	beq l5			; end...asssume load
  3828                          
  3829  f1be c922               	cmp #$22 ; "		; end of string?
  3830  f1c0 f059               	beq l7			; yes...could still be 'l' or 's'
  3831                          
  3832  f1c2 9190               	sta (fnadr),y		; store name
  3833  f1c4 e69c               	inc fnlen
  3834  f1c6 c8                 	iny
  3835  f1c7 c010               	cpy #16			; max file name length
  3836                          
  3837  f1c9 f0d6               l4:	beq errl1		; file name too long
  3838  f1cb d0ec               	bne l3			; branch always
  3839                          ; default load address
  3840  f1cd a9ff               l5	lda #$ff		; default no move load
  3841  f1cf 85b0               	sta tmp0
  3842  f1d1 85b1               	sta tmp0+1
  3843                          ; see if we got a load
  3844  f1d3 ad9403             l6:	lda savx		; get last command
  3845  f1d6 c956               	cmp #'v'		; check for verify?
  3846  f1d8 f007               	beq verify		; yes
  3847  f1da c94c               	cmp #'l'		; load?
  3848  f1dc d0d9               	bne l2			; no..not a load..error
  3849  f1de a900               	lda #0			; flag load
  3850  f1e0 2c                 	!byte $2c		; skip next
  3851  f1e1 a980               verify:	lda #$80		; flag for verify
  3852  f1e3 8d5b03             	sta verck		; store flag
  3853                          
  3854  f1e6 ad40de             	lda via2+prb		; get MMU reg
  3855  f1e9 290f               	and #%00001111		; isolate RAM0 bank
  3856  f1eb 0d5b03             	ora verck		; set verify flag bit#7
  3857  f1ee a6b0               	ldx tmp0
  3858  f1f0 a4b1               	ldy tmp0+1
  3859                          
  3860  f1f2 20d5ff             	jsr load		; do load/verify
  3861                          
  3862  f1f5 b007               	bcs verifyx
  3863  f1f7 ad9403             	lda savx
  3864  f1fa c956               	cmp #'v'		; check for verify
  3865  f1fc f001               	beq verchk
  3866  f1fe 60                 verifyx:rts
  3867                          ; print verify result 
  3868  f1ff 2010f0             verchk:	jsr crlf
  3869  f202 a59b               	lda status		; get verify state
  3870  f204 2910               	and #$10
  3871  f206 d003               	bne lssterr		; error detected
  3872  f208 4c71f3             	jmp printok		; output ok
  3873                          
  3874  f20b a942               lssterr:lda #'b'
  3875  f20d 20d2ff             	jsr bsout
  3876  f210 a941               	lda #'a'
  3877  f212 20d2ff             	jsr bsout
  3878  f215 a944               	lda #'d'
  3879  f217 20d2ff             	jsr bsout
  3880  f21a 60                 	rts
  3881                          
  3882  f21b 205bf3             l7:	jsr gnc			; get next char
  3883  f21e f0ad               	beq l5			; no...default load
  3884  f220 c92c               	cmp #','		; delimeter?
  3885  f222 f004               	beq l8			; yes
  3886  f224 c920               	cmp #' '
  3887  f226 d042               	bne l15			; no delimeter -> error
  3888                          
  3889  f228 20e8c5             l8:	jsr parse		; get next parm
  3890  f22b b0a0               	bcs l5			; none...default load
  3891  f22d c903               	cmp #2+1
  3892  f22f b039               	bcs l15			; > 2 digits
  3893  f231 a5b0               	lda tmp0
  3894  f233 c908               	cmp #8			; range 8-31
  3895  f235 9033               	bcc l15			; too small
  3896  f237 c920               	cmp #32
  3897  f239 b02f               	bcs l15			; too large
  3898  f23b 859e               	sta fa
  3899                          
  3900  f23d 20e8c5             	jsr parse		; more parms?
  3901  f240 b08b               	bcs l5			; no...default load
  3902                          ; set up start address
  3903  f242 a5b0               	lda tmp0
  3904  f244 8596               	sta stal
  3905  f246 a5b1               	lda tmp0+1
  3906  f248 8597               	sta stah
  3907                          
  3908  f24a 20e8c5             	jsr parse		; try to read end address
  3909  f24d b084               	bcs l6			; no... do load
  3910                          
  3911                          ; set up end save address
  3912  f24f a5b0               	lda tmp0
  3913  f251 8594               	sta eal
  3914  f253 a5b1               	lda tmp0+1
  3915  f255 8595               	sta eah
  3916                          
  3917  f257 ad9403             l14:	lda savx 		; was command save?
  3918  f25a c953               	cmp #'s'
  3919  f25c d00c               	bne l15			; no...load can't have parms
  3920                          
  3921  f25e ad40de             	lda via2+prb		; get MMU reg
  3922  f261 290f               	and #%00001111		; isolate RAM0 bank
  3923  f263 a296               	ldx #<stal		; get addresses of params for save
  3924  f265 a094               	ldy #<eal
  3925  f267 4cd8ff             	jmp save
  3926                          
  3927  f26a 4c59ef             l15:	jmp erropr
  3928                          ; -------------------------------------------------------------------------------------------------
  3929                          ; Send disk command, print directory (@$) or read status '@'
  3930  f26d a000               disk:	ldy #0			; .y=0 to count string length
  3931  f26f 849b               	sty status		; clear status @ i/o begin
  3932  f271 849c               	sty fnlen		; filename length of zero...
  3933  f273 a6b7               	ldx ddisk		; get default disk
  3934                          
  3935  f275 205bf3             	jsr gnc			; get char
  3936  f278 c924               	cmp #'$'
  3937  f27a d003               	bne diskcmd
  3938  f27c 4c5ec5             	jmp diskdir		; ...branch if directory read
  3939                          
  3940  f27f 98                 diskcmd:tya			; la=0
  3941  f280 a00f               	ldy #15			; open command channel
  3942  f282 209afe             	jsr setlfs		; .a-0 temporary channel #
  3943  f285 18                 	clc
  3944  f286 20c0ff             	jsr open		; open a real channel
  3945  f289 b044               	bcs disk30		; exit if bad return
  3946                          
  3947  f28b 2054f3             	jsr glc			; see if status check
  3948  f28e f01d               	beq disk20		; yes
  3949                          
  3950  f290 48                 	pha
  3951  f291 a200               	ldx #0
  3952  f293 20c9ff             	jsr ckout		; set up as output
  3953  f296 68                 	pla
  3954  f297 b036               	bcs disk30		; bad status return
  3955  f299 9003               	bcc disk15		; no...ok
  3956                          
  3957  f29b 20cfff             disk10:	jsr basin		; get a character
  3958  f29e c90d               disk15:	cmp #cr			; see if end
  3959  f2a0 08                 	php			; save for later
  3960  f2a1 20d2ff             	jsr bsout		; out to floppy
  3961  f2a4 a59b               	lda status
  3962  f2a6 d023               	bne disk28		; bad status returned
  3963  f2a8 28                 	plp			; end?
  3964  f2a9 d0f0               	bne disk10		; no...continue
  3965  f2ab f022               	beq disk30		; yes...floppy done
  3966                          
  3967  f2ad 2010f0             disk20:	jsr crlf
  3968  f2b0 a200               	ldx #0
  3969  f2b2 20c6ff             	jsr chkin		; tell floppy to speak
  3970  f2b5 b018               	bcs disk30		; bad device
  3971                          
  3972  f2b7 20cfff             disk25: jsr basin		; get a character
  3973  f2ba c90d               	cmp #cr
  3974  f2bc 08                 	php			; save test for later
  3975  f2bd 20d2ff             	jsr bsout		; out to screen
  3976  f2c0 a59b               	lda status		; check for bad basin
  3977  f2c2 29bf               	and #$ff-$40		; remove eoi bit
  3978  f2c4 d005               	bne disk28		; report bad status
  3979  f2c6 28                 	plp			; end?
  3980  f2c7 d0ee               	bne disk25		; no...
  3981  f2c9 f004               	beq disk30		; yes...floppy done
  3982                          
  3983  f2cb 68                 disk28:	pla			; clean up...
  3984  f2cc 207cfc             disk29:	jsr error5		; report error #5 for bad device
  3985  f2cf 20ccff             disk30:	jsr clrch		; clean up
  3986  f2d2 a900               	lda #0
  3987  f2d4 38                 	sec			; close device (c=1)
  3988  f2d5 4cc3ff             	jmp close
  3989                          ; -------------------------------------------------------------------------------------------------
  3990                          ; Exchange temporaries
  3991  f2d8 a202               t2t2:	ldx #2
  3992  f2da b5af               t2t21:	lda tmp0-1,x
  3993  f2dc 48                 	pha
  3994  f2dd b5b3               	lda tmp2-1,x
  3995  f2df 95af               	sta tmp0-1,x 
  3996  f2e1 68                 	pla
  3997  f2e2 95b3               	sta tmp2-1,x
  3998  f2e4 ca                 	dex
  3999  f2e5 d0f3               	bne t2t21
  4000  f2e7 60                 	rts
  4001                          ; -------------------------------------------------------------------------------------------------
  4002                          ; subtract tmp2 from tmp0, result in tmp0
  4003  f2e8 38                 sub0m2:	sec
  4004  f2e9 a5b0               	lda tmp0
  4005  f2eb e5b4               	sbc tmp2
  4006  f2ed 85b0               	sta tmp0
  4007  f2ef a5b1               	lda tmp0+1
  4008  f2f1 e5b5               	sbc tmp2+1
  4009  f2f3 85b1               	sta tmp0+1		; note .c=0 indicates tmp0 < tmp2, thus tmp0 is negative!
  4010  f2f5 60                 	rts
  4011                          ; -------------------------------------------------------------------------------------------------
  4012                          ; decrement t0
  4013  f2f6 a901               dect0:  lda #1
  4014                          ; subtract .a from tmp0
  4015  f2f8 85a5               subt0:  sta sxreg
  4016  f2fa 38                 	sec
  4017  f2fb a5b0               	lda tmp0
  4018  f2fd e5a5               	sbc sxreg
  4019  f2ff 85b0               	sta tmp0
  4020  f301 a5b1               	lda tmp0+1
  4021  f303 e900               	sbc #0
  4022  f305 85b1               	sta tmp0+1
  4023  f307 60                 	rts
  4024                          ; -------------------------------------------------------------------------------------------------
  4025                          ; decrement t1
  4026  f308 38                 dect1:  sec
  4027  f309 a5b2               	lda tmp1
  4028  f30b e901               	sbc #1
  4029  f30d 85b2               	sta tmp1
  4030  f30f a5b3               	lda tmp1+1
  4031  f311 e900               	sbc #0
  4032  f313 85b3               	sta tmp1+1
  4033  f315 60                 	rts
  4034                          ; -------------------------------------------------------------------------------------------------
  4035                          ; increment tmp2 - returns c=1 at overflow
  4036  f316 a901               inct2:	lda #1
  4037                          ; add .a to tmp2
  4038  f318 18                 addt2:  clc
  4039  f319 65b4               	adc tmp2
  4040  f31b 85b4               	sta tmp2
  4041  f31d a5b5               	lda tmp2+1
  4042  f31f 6900               	adc #0
  4043  f321 85b5               	sta tmp2+1
  4044  f323 60                 addt2x:	rts
  4045                          ; -------------------------------------------------------------------------------------------------
  4046                          ; print address: x=hi, y=lo
  4047  f324 8a                 putwrd:	txa
  4048  f325 2031f3             	jsr puthex
  4049  f328 98                 	tya
  4050                          
  4051  f329 2031f3             puthxs:	jsr puthex		; print byte in .a as two hex digits
  4052                          
  4053  f32c a920               putspc:	lda #' '		; print <space>
  4054  f32e 4cd2ff             	jmp bsout
  4055                          
  4056                          ; print hex byte, preserve x
  4057  f331 86a5               puthex:	stx sxreg
  4058  f333 203ff3             	jsr makhex
  4059  f336 20d2ff             	jsr bsout
  4060  f339 8a                 	txa
  4061  f33a a6a5               	ldx sxreg
  4062  f33c 4cd2ff             	jmp bsout
  4063                          ; -------------------------------------------------------------------------------------------------
  4064                          ; convert .a to 2 hex digits & put msb in .a, lsb in .x
  4065  f33f 48                 makhex:	pha
  4066  f340 2049f3             	jsr maknib		; convert nibble
  4067  f343 aa                 	tax			; move low nibble to .x
  4068  f344 68                 	pla
  4069  f345 4a                 	lsr			; sift high nibble right and convert it to .a
  4070  f346 4a                 	lsr
  4071  f347 4a                 	lsr
  4072  f348 4a                 	lsr
  4073                          
  4074  f349 290f               maknib:	and #$0f
  4075  f34b c90a               	cmp #$0a
  4076  f34d 9002               	bcc mak0_9		; number 0-9
  4077  f34f 6906               	adc #$06		; add 6+carry=7 for 'a-f
  4078  f351 6930               mak0_9	adc #'0'		; add petscii '0'
  4079  f353 60                 	rts
  4080                          ; -------------------------------------------------------------------------------------------------
  4081                          ; get last character: return in .a, z=1 if EOL, : (terminator) or ?
  4082  f354 86a5               glc:	stx sxreg
  4083  f356 a5a4               	lda lastchr
  4084  f358 4c62f3             	jmp gncchk
  4085                          ; get next character
  4086  f35b 86a5               gnc:	stx sxreg
  4087  f35d 20cfff             	jsr basin
  4088  f360 85a4               	sta lastchr		; save for glc
  4089  f362 c90d               gncchk:	cmp #cr			; is it a cr
  4090  f364 f006               	beq gnceol		; eol-return with z=1
  4091  f366 c93a               	cmp #':'
  4092  f368 f002               	beq gnceol		; eol-return with z=1
  4093  f36a c93f               	cmp #'?'
  4094  f36c 08                 gnceol:	php
  4095  f36d a6a5               	ldx sxreg
  4096  f36f 28                 	plp
  4097  f370 60                 	rts
  4098                          ; -------------------------------------------------------------------------------------------------
  4099                          ; output "OK"
  4100  f371 a94f               printok:lda #'o'
  4101  f373 20d2ff             	jsr bsout
  4102  f376 a94b               	lda #'k'
  4103  f378 20d2ff             	jsr bsout
  4104  f37b 60                 	rts
  4105                          ; -------------------------------------------------------------------------------------------------
  4106                          ; ##### messages #####
  4107  f37c 0d492f4f20455252...ms1:	!pet cr,"i/o error ",$a3
  4108  f388 0d53454152434849...ms5:	!pet cr,"searching",$a0
  4109  f393 464f52a0           ms6:	!pet "for",$a0
  4110  f397 0d4c4f4144494ec7   ms10:	!pet cr,"loadin",$c7
  4111  f39f 0d534156494e47a0   ms11:	!pet cr,"saving",$a0
  4112  f3a7 0d56455249465949...ms21:	!pet cr,"verifyin",$c7
  4113  f3b1 0d464f554e44a0     ms17:	!pet cr,"found",$a0
  4114  f3b8 0d4f4b8d           ms18:	!pet cr,"ok",$8d
  4115  f3bc 0d2a2a204c433235...ms34:	!pet cr,"** lc256 monitor 1.0 **",$8d
  4116  f3d5 0d42524541cb       ms36:	!pet cr,"brea",$cb
  4117                          ; -------------------------------------------------------------------------------------------------
  4118                          ; Print message to screen only if output enabled
  4119  f3db 2c5d03             spmsg:	bit msgflg		; printing messages?
  4120  f3de 100d               	bpl msg10		; no...
  4121  f3e0 b97cf3             msg:	lda ms1,y
  4122  f3e3 08                 	php
  4123  f3e4 297f               	and #$7f
  4124  f3e6 20d2ff             	jsr bsout
  4125  f3e9 c8                 	iny
  4126  f3ea 28                 	plp
  4127  f3eb 10f3               	bpl msg
  4128  f3ed 18                 msg10:	clc
  4129  f3ee 60                 	rts
  4130                          ; -------------------------------------------------------------------------------------------------
  4131                          ; ***** 'serial routines' *****
  4132                          ; command serial bus device to talk
  4133  f3ef 0940               ntalk:	ora #$40		; make a talk  adr
  4134  f3f1 2c                 	!byte $2c		; skip two bytes
  4135                          ; command serial bus device to listen
  4136  f3f2 0920               nlistn:	ora #$20		; make a listen adr
  4137  f3f4 48                 list1:	pha
  4138                          ; check if last char in buffer? - If yes set EOI and send with EOI
  4139  f3f5 24a3               	bit c3p0		; character left in buf?
  4140  f3f7 100a               	bpl list2		; no...
  4141                          ; send buffered character
  4142  f3f9 38                 	sec			; set eoi flag
  4143  f3fa 66a4               	ror r2d2
  4144                          ;
  4145                          !if JIFFY = 1{			; ##### JIFFY #####
  4146  f3fc 2094f7             	jsr jdSendByte	
  4147                          } else{
  4148                          	jsr isour		; send last character
  4149                          }
  4150                          ;
  4151  f3ff 46a3               	lsr c3p0		; buffer clear flag
  4152  f401 46a4               	lsr r2d2		; clear eoi flag
  4153                          ;
  4154  f403 68                 list2:	pla			; talk/listen address
  4155  f404 85a5               	sta bsour
  4156  f406 78                 	sei
  4157                          !if JIFFY = 1{			; ##### JIFFY #####
  4158  f407 20ccf5             	jsr jdIecDataH		; JD: set data 1, and clear serial bit count
  4159                          } else{
  4160                          	jsr datahi
  4161                          }
  4162  f40a c93f               	cmp #$3f		; clkhi only on unlisten
  4163  f40c d003               	bne list5
  4164  f40e 20baf5             	jsr clkhi
  4165                          ;
  4166  f411 ad4fde             list5:	lda via2+pra		; assert attention
  4167  f414 0908               	ora #$08
  4168  f416 8d4fde             	sta via2+pra
  4169                          ;
  4170  f419 78                 isoura:	sei
  4171  f41a 20c3f5             	jsr clklo		; set clock line low
  4172  f41d 20d0f5             	jsr datahi
  4173  f420 20f6f5             	jsr w1ms		; delay 1 ms
  4174                          
  4175  f423 78                 isour:	sei			; no irq's allowed
  4176  f424 20d0f5             	jsr datahi		; make sure data is released
  4177  f427 20e2f5             	jsr debvia		; data should be low
  4178                          
  4179  f42a 9003               	bcc isr00		; device found -> skip
  4180                          
  4181  f42c 4cccf4             	jmp nodev		; no device found (data is after 1ms still high = no answer)
  4182                          
  4183  f42f 20baf5             isr00:	jsr clkhi		; clock line high
  4184  f432 24a4               	bit r2d2		; eoi flag test
  4185  f434 100a               	bpl noeoi
  4186                          ; do the eoi (leave clock high until receiver confirms with data high impulse)
  4187  f436 20e2f5             isr02:	jsr debvia		; wait for data to go high
  4188  f439 90fb               	bcc isr02
  4189                          ;
  4190  f43b 20e2f5             isr03:	jsr debvia		; wait for data to go low
  4191  f43e b0fb               	bcs isr03
  4192                          ;
  4193  f440 20e2f5             noeoi:	jsr debvia		; wait for data high
  4194  f443 90fb               	bcc noeoi
  4195  f445 20c3f5             	jsr clklo		; set clock low
  4196                          ; set to send data
  4197                          !if JIFFY = 1{			; ##### JIFFY #####
  4198  f448 8a                 	txa
  4199  f449 48                 	pha
  4200                          
  4201  f44a a208               	ldx #8
  4202                          
  4203  f44c ad4fde             jsr01:	lda via2+pra		; debounce the bus
  4204  f44f cd4fde             	cmp via2+pra
  4205  f452 d0f8               	bne jsr01
  4206  f454 cd4fde             	cmp via2+pra
  4207  f457 d0f3               	bne jsr01
  4208  f459 cd4fde             	cmp via2+pra
  4209  f45c d0ee               	bne jsr01
  4210  f45e 2c4fde             	bit via2+pra		; time out?
  4211  f461 3005               	bmi jsr02		; no, -> skip
  4212                          ; time out
  4213  f463 68                 	pla
  4214  f464 aa                 	tax
  4215  f465 4ccff4             	jmp frmerr		; time out error
  4216                          
  4217  f468 20d0f5             jsr02:	jsr datahi
  4218                          
  4219  f46b 66a5               	ror bsour		; bit set?
  4220  f46d b003               	bcs jsrhi		; yes, -> output a 1
  4221                          ; outpur a 0
  4222  f46f 20d9f5             	jsr datalo		; no, -> output a 0
  4223                          
  4224                          jsrhi:	
  4225                          ; clock low 70us
  4226                          !if CLOCK > 1{
  4227  f472 8a                 	txa
  4228  f473 a224               	ldx #(CLOCK-1)*12	; 3*12 = 36 * 5 extra cycles @ 4MHz
  4229  f475 ca                 -	dex
  4230  f476 d0fd               	bne -
  4231  f478 aa                 	tax
  4232                          }
  4233  f479 20baf5             	jsr clkhi
  4234                          ; clock high 26us
  4235                          !if CLOCK > 1{
  4236  f47c 8a                 	txa
  4237  f47d a20f               	ldx #(CLOCK-1)*5	; 3*5 = 15 * 5 extra cycles @ 4MHz
  4238  f47f ca                 -	dex
  4239  f480 d0fd               	bne -
  4240  f482 aa                 	tax
  4241                          } 
  4242                          !if CLOCK = 1{
  4243                          	nop
  4244                          	nop
  4245                          	nop
  4246                          	nop
  4247                          }	
  4248  f483 ad4fde             	lda via2+pra
  4249  f486 29df               	and #$df		; DATA line = L (5V)
  4250  f488 0910               	ora #$10		; CLK line = H (0V)
  4251  f48a 08                 	php
  4252  f48b 48                 	pha
  4253  f48c 8d4fde             	sta via2+pra
  4254                          
  4255  f48f 2908               	and #$08		; Check ATN line?
  4256  f491 f01f               	beq jsskip		; H (0V) -> skip
  4257                          ; ATN L (5V)
  4258  f493 a5a5               	lda bsour		; next bit to bit #7 (for Jiffy EOI flag if last bit)
  4259  f495 6a                 	ror
  4260  f496 6a                 	ror
  4261                          
  4262                          ; check if jiffy drive connected between bit 6 and 7
  4263  f497 e002               	cpx #2			; bit counter = 2 (second last bit?)
  4264  f499 d017               	bne jsskip		; no, -> skip
  4265                          
  4266                          ; wait 330us for data low = jiffy device connected
  4267  f49b a278               	ldx #$1e*CLOCK		; 30 * 11 cycles for each MHz
  4268  f49d 2c4fde             jssidlp:bit via2+pra		; DATA line (L)?
  4269  f4a0 1005               	bpl jifdev		; yes, -> jiffy device found
  4270                          
  4271  f4a2 ca                 	dex
  4272  f4a3 d0f8               	bne jssidlp		; -> wait more
  4273  f4a5 f009               	beq jnojdev		; always -> no jiffy device found
  4274                          ; jiffy device found - wait for Data=H to continue
  4275  f4a7 2c4fde             jifdev:	bit via2+pra		; DATA line (L)?
  4276  f4aa 10fb               	bpl jifdev		; yes, -> wait until (H)
  4277                          ; set bit 6=jiffy, bit7=bit7 of byte to send
  4278  f4ac 0940               	ora #$40		; set bit 6 which means ...
  4279  f4ae 85a4               	sta r2d2		; ... device is a JiffyDOS device
  4280                          
  4281  f4b0 a202               jnojdev:ldx #2			; restore bit counter
  4282                          
  4283  f4b2 68                 jsskip:	pla
  4284  f4b3 28                 	plp
  4285  f4b4 ca                 	dex			; 8 bits done?
  4286  f4b5 d095               	bne jsr01		; no, -> send next bit
  4287                          
  4288  f4b7 68                 	pla
  4289  f4b8 aa                 	tax
  4290                          ; now all eight bits have been sent it's up to the peripheral to signal the
  4291                          ; byte was received by pulling the serial data low. this should be done within
  4292                          ; one milisecond
  4293                          } else{
  4294                          	lda #8			; count 8 bits
  4295                          	sta count
  4296                          ;
  4297                          isr01:	lda via2+pra		; debounce the bus
  4298                          	cmp via2+pra
  4299                          	bne isr01
  4300                          	cmp via2+pra
  4301                          	bne isr01
  4302                          	cmp via2+pra
  4303                          	bne isr01
  4304                          	asl			; set the flags
  4305                          	bcc frmerr		; data must be hi
  4306                          ;
  4307                          	ror bsour		; next bit into carry
  4308                          	bcs isrhi
  4309                          	jsr datalo
  4310                          	bne isrclk
  4311                          isrhi:	jsr datahi
  4312                          isrclk:	
  4313                          ; clock low 70us
  4314                          !if CLOCK > 1{
  4315                          	txa
  4316                          	ldx #(CLOCK-1)*12	; 3*12 = 36 * 5 extra cycles @ 4MHz
  4317                          -	dex
  4318                          	bne -
  4319                          	tax
  4320                          }
  4321                          	jsr clkhi		; clock hi
  4322                          ; clock high 26us
  4323                          !if CLOCK > 1{
  4324                          	txa
  4325                          	ldx #(CLOCK-1)*5	; 3*5 = 15 * 5 extra cycles @ 4MHz
  4326                          -	dex
  4327                          	bne -
  4328                          	tax
  4329                          }
  4330                          !if CLOCK = 1{
  4331                          	nop
  4332                          	nop
  4333                          	nop
  4334                          	nop
  4335                          }	
  4336                          	lda via2+pra
  4337                          	and #$ff-$20		; data high
  4338                          	ora #$10		; clock low
  4339                          	sta via2+pra
  4340                          	dec count
  4341                          	bne isr01
  4342                          }
  4343  f4b9 a910               	lda #4*CLOCK		; set timer for 1ms
  4344  f4bb 8d09de             	sta via1+t2hi
  4345  f4be ad0dde             isr04:	lda via1+ifr
  4346  f4c1 2920               	and #$20
  4347  f4c3 d00a               	bne frmerr
  4348  f4c5 20e2f5             	jsr debvia
  4349  f4c8 b0f4               	bcs isr04		; wait 1ms for data low
  4350                          
  4351  f4ca 58                 	cli			; let irq's continue
  4352  f4cb 60                 	rts
  4353                          ; -------------------------------------------------------------------------------------------------
  4354                          ; device not present error
  4355  f4cc a980               nodev:	lda #$80
  4356  f4ce 2c                 	!byte $2c
  4357                          frmerr:	; framing error
  4358  f4cf a903               	lda #$03
  4359  f4d1 20aafe             csberr:	jsr udst		; commodore serial bus error entry
  4360  f4d4 58                 	cli			; irq's were off...turn on
  4361  f4d5 18                 	clc			; make sure no kernal error returned
  4362  f4d6 904a               	bcc dlabye		; turn atn off ,release all lines
  4363                          ; -------------------------------------------------------------------------------------------------
  4364                          ; send secondary address after listen
  4365  f4d8 85a5               nsecnd:	sta bsour		; buffer character
  4366  f4da 2019f4             	jsr isoura		; send it
  4367                          ; release attention after listen
  4368  f4dd ad4fde             scatn:	lda via2+pra
  4369  f4e0 29f7               	and #$ff-$08
  4370  f4e2 8d4fde             	sta via2+pra		; release attention
  4371  f4e5 60                 	rts
  4372                          ; -------------------------------------------------------------------------------------------------
  4373                          ; talk second address
  4374  f4e6 85a5               ntksa:	sta bsour		; buffer character
  4375  f4e8 2019f4             	jsr isoura		; send second addr
  4376                          ; shift over to listener
  4377  f4eb 78                 tkatn:	sei			; no irq's here
  4378  f4ec 20d9f5             	jsr datalo		; data line low
  4379  f4ef 20ddf4             	jsr scatn
  4380  f4f2 20baf5             	jsr clkhi		; clock line high jsr/rts
  4381                          !if JIFFY = 1{			; ##### JIFFY #####
  4382  f4f5 2c4fde             tkatn1:	bit via2+pra		; test bit6 and wait for CLK = H (0V)
  4383  f4f8 70fb               	bvs tkatn1		; no, -> wait
  4384                          } else{
  4385                          tkatn1:	jsr debvia		; wait for clock to go low
  4386                          	bmi tkatn1
  4387                          }
  4388  f4fa 58                 	cli			; irq's okay now
  4389  f4fb 60                 	rts
  4390                          ; -------------------------------------------------------------------------------------------------
  4391                          ; buffered output to serial bus
  4392  f4fc 24a3               nciout:	bit c3p0		; buffered char?
  4393  f4fe 3005               	bmi ci2			; yes...send last
  4394                          ; first char: set c3p0 buffered char flag and don't send char!
  4395  f500 38                 	sec			; no...
  4396  f501 66a3               	ror c3p0		; set buffered char flag
  4397  f503 d005               	bne ci4			; branch always
  4398                          ; from second char: send buffered char in bsour - leave c3p0 flag untouched
  4399  f505 48                 ci2:	pha			; save current char
  4400                          !if JIFFY = 1{			; ##### JIFFY #####
  4401  f506 2094f7             	jsr jdSendByte
  4402                          } else{
  4403                          	jsr isour		; send last char
  4404                          }
  4405  f509 68                 	pla			; restore current char
  4406  f50a 85a5               ci4:	sta bsour		; buffer current char
  4407  f50c 18                 	clc			; carry-good exit
  4408  f50d 60                 	rts
  4409                          ; -------------------------------------------------------------------------------------------------
  4410                          ; send untalk command on serial bus
  4411  f50e 78                 nuntlk:	sei
  4412                          !if JIFFY = 1{			; ##### JIFFY #####
  4413  f50f ad4fde             	lda via2+pra
  4414  f512 0908               	ora #$08
  4415  f514 8d4fde             	sta via2+pra		; ATN line = L (0V)
  4416                          
  4417  f517 20c3f5             	jsr clklo
  4418                          } else{
  4419                          	jsr clklo
  4420                          	lda via2+pra		; pull atn
  4421                          	ora #$08
  4422                          	sta via2+pra
  4423                          }
  4424  f51a a95f               	lda #$5f		; untalk command
  4425  f51c 2c                 	!byte $2c		; skip two bytes
  4426                          ; -------------------------------------------------------------------------------------------------
  4427                          ; send unlisten command on serial bus
  4428  f51d a93f               nunlsn:	lda #$3f		; unlisten command
  4429  f51f 20f4f3             	jsr list1		; send it
  4430                          ; release all lines
  4431  f522 20ddf4             dlabye:	jsr scatn		; always release atn
  4432                          ; delay then release clock and data
  4433  f525 8a                 dladlh:	txa			 ; delay approx 60 us
  4434  f526 a228               	ldx #10*CLOCK
  4435  f528 ca                 dlad00:	dex
  4436  f529 d0fd               	bne dlad00
  4437  f52b aa                 	tax
  4438  f52c 20baf5             	jsr clkhi
  4439  f52f 4cd0f5             	jmp datahi
  4440                          ; -------------------------------------------------------------------------------------------------
  4441                          ; input a byte from serial bus
  4442                          ;
  4443                          ; this routine reads a byte of data from the serial bus using full handshaking.
  4444                          ; the data is returned in the accumulator. before using this routine the TALK
  4445                          ; routine, talk/$FFB4, must have been called first to command the device on
  4446                          ; the serial bus to send data on the bus. if the input device needs a secondary
  4447                          ; command it must be sent by using the TKSA routine, $FF96, before calling this routine.
  4448                          ;
  4449                          ; errors are returned in the status word which can be read by calling the
  4450                          ; READST routine, ReadIoStatus.
  4451                          nacptr:	
  4452                          !if JIFFY = 1{			; ##### JIFFY #####
  4453                          IecByteIn2:
  4454  f532 4cd5f6             	jmp jdIecByteIn
  4455                          
  4456                          IecByteIn:			; save the serial bus bit count
  4457                          }
  4458  f535 78                  	sei			; no irq allowed
  4459  f536 a900               	lda #$00		; set eoi/error flag
  4460                          
  4461  f538 85a6               	sta count
  4462  f53a 20baf5             	jsr clkhi		; make sure clock line is released
  4463  f53d 20e2f5             acp00a:	jsr debvia		; wait for clock high
  4464  f540 10fb               	bpl acp00a
  4465  f542 20d0f5             	jsr datahi		; data line high
  4466                          ;
  4467  f545 a904               eoiacp:	lda #1*CLOCK		; set timer 2 for 256us
  4468  f547 8d09de             	sta via1+t2hi
  4469  f54a ad0dde             acp00:	lda via1+ifr
  4470  f54d 2920               	and #$20		; check the timer
  4471  f54f d007               	bne acp00b		; ran out.....
  4472  f551 20e2f5             	jsr debvia		; check the clock line
  4473  f554 30f4               	bmi acp00		; no not yet
  4474  f556 1018               	bpl acp01		; yes.....
  4475                          ;
  4476  f558 a5a6               acp00b:	lda count		; check for error (twice thru timeouts)
  4477  f55a f005               	beq acp00c
  4478  f55c a902               	lda #2
  4479  f55e 4cd1f4             	jmp csberr		; st = 2 read timeout
  4480                          ; timer ran out do an eoi thing
  4481  f561 20d9f5             acp00c:	jsr datalo		; data line low
  4482  f564 2025f5             	jsr dladlh		; delay and then set datahi (also clkhi) ************ VOSSI from vic kernal **********
  4483  f567 a940               	lda #$40
  4484  f569 20aafe             	jsr udst		; or an eoi bit into status
  4485  f56c e6a6               	inc count		; go around again for error check on eoi
  4486  f56e d0d5               	bne eoiacp
  4487                          ; do the byte transfer
  4488  f570 a908               acp01:	lda #8			; set up counter
  4489  f572 85a6               	sta count
  4490                          ;
  4491  f574 ad4fde             acp03:	lda via2+pra		; wait for clock high
  4492  f577 cd4fde             	cmp via2+pra		; debounce
  4493  f57a d0f8               	bne acp03
  4494  f57c cd4fde             	cmp via2+pra		; debounce
  4495  f57f d0f3               	bne acp03
  4496  f581 cd4fde             	cmp via2+pra		; debounce
  4497  f584 d0ee               	bne acp03
  4498  f586 0a                 	asl			; shift data into carry
  4499  f587 10eb               	bpl acp03		; clock still low...
  4500  f589 66a5               	ror bsour1		; rotate data in
  4501                          ;
  4502  f58b ad4fde             acp03a:	lda via2+pra		; wait for clock low
  4503  f58e cd4fde             	cmp via2+pra		; debounce
  4504  f591 d0f8               	bne acp03a
  4505  f593 cd4fde             	cmp via2+pra		; debounce
  4506  f596 d0f3               	bne acp03a
  4507  f598 cd4fde             	cmp via2+pra		; debounce
  4508  f59b d0ee               	bne acp03a
  4509  f59d 0a                 	asl
  4510  f59e 30eb               	bmi acp03a
  4511  f5a0 c6a6               	dec count
  4512  f5a2 d0d0               	bne acp03		; more bits.....
  4513                          ; ...exit...
  4514  f5a4 20d9f5             	jsr datalo		; data low
  4515  f5a7 249b               	bit status		; check for eoi
  4516  f5a9 5003               	bvc acp04		; none...
  4517                          ;
  4518  f5ab 2025f5             	jsr dladlh		; delay then set data high
  4519                          ;
  4520                          acp04:
  4521                          !if JIFFY = 1 & CLOCK > 1{	; ##### JIFFY #####
  4522                          ; delay to fix errors with non-jiffy drives	
  4523  f5ae 8a                 	txa
  4524  f5af a206               	ldx #(CLOCK-1)*2	
  4525  f5b1 ca                 -	dex
  4526  f5b2 d0fd               	bne -
  4527  f5b4 aa                 	tax
  4528                          }
  4529  f5b5 a5a5               	lda bsour1
  4530  f5b7 58                 	cli			; irq is ok
  4531  f5b8 18                 	clc			; good exit
  4532  f5b9 60                 	rts
  4533                          ; -------------------------------------------------------------------------------------------------
  4534                          ; set clock line high (inverted)
  4535  f5ba ad4fde             clkhi:	lda via2+pra
  4536  f5bd 29ef               	and #$ff-$10
  4537  f5bf 8d4fde             	sta via2+pra
  4538  f5c2 60                 	rts
  4539                          ; -------------------------------------------------------------------------------------------------
  4540                          ; set clock line low  (inverted)
  4541  f5c3 ad4fde             clklo:	lda via2+pra
  4542  f5c6 0910               	ora #$10
  4543  f5c8 8d4fde             	sta via2+pra
  4544  f5cb 60                 	rts
  4545                          ; ########################################### JIFFY ###############################################
  4546                          !if JIFFY = 1{
  4547                          ;**  This is a patch that clears the flag that indicates a JiffyDOS device, before setting data hi.
  4548                          jdIecDataH:
  4549  f5cc a900               	lda #$00
  4550  f5ce 85a4               	sta r2d2		; clear JiffyDOS device flag
  4551                          }
  4552                          ; set data line high (inverted)
  4553                          datahi:
  4554  f5d0 ad4fde             	lda via2+pra
  4555  f5d3 29df               	and #$ff-$20
  4556  f5d5 8d4fde             	sta via2+pra
  4557  f5d8 60                 	rts
  4558                          ; -------------------------------------------------------------------------------------------------
  4559                          ; set data line low  (inverted)
  4560  f5d9 ad4fde             datalo:	lda via2+pra
  4561  f5dc 0920               	ora #$20
  4562  f5de 8d4fde             	sta via2+pra
  4563  f5e1 60                 	rts
  4564                          ; -------------------------------------------------------------------------------------------------
  4565                          ; debounce the via
  4566  f5e2 ad4fde             debvia:	lda via2+pra
  4567  f5e5 cd4fde             	cmp via2+pra
  4568  f5e8 d0f8               	bne debvia
  4569  f5ea cd4fde             	cmp via2+pra
  4570  f5ed d0f3               	bne debvia
  4571  f5ef cd4fde             	cmp via2+pra
  4572  f5f2 d0ee               	bne debvia
  4573  f5f4 0a                 	asl			; shift the data bit into the carry...
  4574  f5f5 60                 	rts			; ...and the clock into neg flag
  4575                          ; -------------------------------------------------------------------------------------------------
  4576                          ; delay 1ms for isoura (vic uses t2, c64 uses loop)
  4577  f5f6 a910               w1ms:	lda #4*CLOCK		; set timer for 1ms
  4578  f5f8 8d09de             	sta via1+t2hi
  4579  f5fb ad0dde             w1ms1:	lda via1+ifr
  4580  f5fe 2920               	and #$20
  4581  f600 f0f9               	beq w1ms1
  4582  f602 60                 	rts
  4583                          ; *******************************
  4584                          ; written 8/11/80 bob fairbairn
  4585                          ; test serial0.6 8/12/80  rjf
  4586                          ; change i/o structure 8/21/80 rjf
  4587                          ; more i/o changes 8/24/80 rjf
  4588                          ; final release into kernal 8/26/80 rjf
  4589                          ; some clean up 9/8/80 rsr
  4590                          ; add irq protect on isour and tkatn 9/22/80 rsr
  4591                          ; fix untalk 10/7/80 rsr
  4592                          ; modify for vic-40 i/o system 12/08/81 rsr
  4593                          ; add sei to (untlk,isoura,list2) 12/14/81 rsr
  4594                          ; modify for 6526 flags fix errs 12/31/81 rsr
  4595                          ; modify for commodore 64 i/o  3/11/82 rsr
  4596                          ; change acptr eoi for better response 3/28/82 rsr
  4597                          ; change wait 1 ms routine for less code 4/8/82 rsr
  4598                          ; ******************************
  4599                          ; ########################################### JIFFY ###############################################
  4600                          !if JIFFY = 1{
  4601                          ;**  This routine is a patch to the original load routine and tests if the
  4602                          ;    current device is a JiffyDOS device. If not, the routine jumps back to
  4603                          ;    the original loader. Some handshaking is done.
  4604                          jdLOAD:
  4605  f603 20b3fb             	jsr loding
  4606  f606 24a4               	bit r2d2		; JiffyDOS device?
  4607  f608 3003               	bmi jload		; yes, -> continue
  4608  f60a 4c44fb             	jmp ld40		; original load routine
  4609                          
  4610  f60d 78                 jload:	sei
  4611                          !if CLOCK = 1{
  4612                          	ldy #0
  4613                          }
  4614  f60e 20f3fc             jload2:	jsr ud60		; <STOP> key pressed?
  4615  f611 1037               	bpl jlstop
  4616                          
  4617  f613 ad4fde             	lda via2+pra
  4618  f616 2907               	and #$07		; all IEC lines L (5V)
  4619  f618 85a6               	sta jdtemp
  4620  f61a 8d4fde             	sta via2+pra
  4621                          ; receiver ready to receive
  4622  f61d 0920               	ora #$20		; DATA line = H (0V)
  4623  f61f aa                 	tax			; X = %0010 0xxx
  4624                          
  4625  f620 2c4fde             jlclkh:	bit via2+pra		; CLK line = L (5V)?
  4626  f623 50fb               	bvc jlclkh		; no, -> wait
  4627  f625 2c4fde             	bit via2+pra		; debounce
  4628  f628 50f6               	bvc jlclkh		; no, -> wait
  4629  f62a 2c4fde             	bit via2+pra		; debounce
  4630  f62d 50f1               	bvc jlclkh		; no, -> wait
  4631                          ; sender ready to send
  4632  f62f 1025               	bpl jldath		; if DATAline = (H), -> LOAD
  4633                          ; loops for CLK=0 in us = EOI
  4634                          ; $64*11 = 1100 cycles loop  -> $3f*17 cycles loop
  4635  f631 a2dc               	ldx #$37*CLOCK
  4636  f633 2c4fde             jleoilp:bit via2+pra		; EOI?
  4637  f636 500b               	bvc jleoi		; yes, -> 
  4638  f638 2c4fde             	bit via2+pra		; again to get 6 more cycles
  4639  f63b 5006               	bvc jleoi		; needed for 4MHz clock loops below $ff! loops
  4640                          
  4641  f63d ca                 	dex
  4642  f63e d0f3               	bne jleoilp		; loop again for EOI
  4643                          
  4644  f640 a942               	lda #$42		; EOI & READ TIME OUT
  4645  f642 2c                 	!byte $2C		; skip next
  4646  f643 a940               jleoi:	lda #$40		; EOI found
  4647  f645 20aafe             	jsr udst		; update status
  4648                          
  4649  f648 18                 	clc
  4650  f649 24                 	!byte $24		; skip next
  4651  f64a 38                 jlstop:	sec
  4652  f64b 2064fc             	jsr RestoreBank		; restore RAM0 bank
  4653  f64e b003               	bcs jlbreak		; if carry set, stop detected
  4654                          
  4655  f650 4c80fb             	jmp jdCloseFile
  4656                          
  4657  f653 4c1ffc             jlbreak:jmp break
  4658                          
  4659  f656 2c4fde             jldath:	bit via2+pra		; DATA line = L (5V)?
  4660  f659 10fb               	bpl jldath		; no, -> wait
  4661  f65b 2c4fde             	bit via2+pra		; DATA line = L (5V)?
  4662  f65e 10f6               	bpl jldath		; no, -> wait
  4663  f660 2c4fde             	bit via2+pra		; DATA line = L (5V)?
  4664  f663 10f1               	bpl jldath		; no, -> wait
  4665                          ; prepare transmission with DATA+CLK = L (5V)
  4666                          jlread:	
  4667                          !if CLOCK = 1{
  4668                          	nop
  4669                          	nop
  4670                          	nop
  4671                          	nop
  4672                          }
  4673                          ; original = 18 cycles (via bit/bpl to via stx)
  4674                          !if CLOCK > 1{
  4675  f665 a00b               	ldy #3+(CLOCK-2)*4	; 3*4 = 12 * 5 extra cycles @ 4MHz
  4676  f667 88                 -	dey
  4677  f668 d0fd               	bne -
  4678                          }
  4679  f66a a5a6               	lda jdtemp
  4680  f66c 8e4fde             	stx via2+pra		; store %0010 0xxx
  4681                          				; DATA line = L (5V)
  4682  f66f 2c4fde             	bit via2+pra		; CLK line = L (5V)
  4683  f672 509a               	bvc jload2		; no, -> try again
  4684                          ; start transmission with DATA = L (5V)
  4685                          !if CLOCK = 1{
  4686                          	nop
  4687                          }
  4688                          ; original = 17 cycles (via stx to ora) (incl. nop above / without 15 cy)
  4689                          ; optimized !!! 15+16=31 is perfect (extra 14-18 works)
  4690                          !if CLOCK = 2{
  4691                          	pha			; 16 cycles
  4692                          	pla
  4693                          	pha
  4694                          	pla
  4695                          	nop
  4696                          }
  4697                          !if CLOCK > 2{
  4698                          ; optimized !!!!
  4699                          ; 15+31=46 at 3MHz, 15+46=61 at 4MHz are perfect (at 4 MHz works extra 41-51)
  4700  f674 a009               	ldy #3+(CLOCK-2)*3	; 2*3 = 6 * 5 extra cycles @ 4MHz
  4701  f676 88                 -	dey
  4702  f677 d0fd               	bne -
  4703                          }
  4704  f679 8d4fde             	sta via2+pra		; store %0000 0xxx
  4705                          ; read 8 bits 
  4706  f67c 0d4fde             	ora via2+pra		; receive 2 bits
  4707  f67f 4a                 	lsr
  4708  f680 4a                 	lsr
  4709  f681 ea                 	nop
  4710                          !if CLOCK = 2{
  4711                          	nop
  4712                          	nop
  4713                          	nop
  4714                          	nop
  4715                          	nop
  4716                          }
  4717                          !if CLOCK > 2{
  4718                          ; original = 10 cycles via ora to ora)
  4719  f682 a005               	ldy #1+(CLOCK-2)*2	; 2*2 = 2 * 5 extra cycles @ 4MHz
  4720  f684 88                 -	dey
  4721  f685 d0fd               	bne -
  4722  f687 ea                 	nop
  4723  f688 ea                 	nop
  4724                          }
  4725  f689 0d4fde             	ora via2+pra		; receive 2 bits
  4726  f68c 4a                 	lsr
  4727  f68d 4a                 	lsr
  4728  f68e 45a6               	eor jdtemp
  4729                          !if CLOCK = 2{
  4730                          	pha			; 11 cycles
  4731                          	pla
  4732                          	nop
  4733                          	nop
  4734                          }
  4735                          !if CLOCK > 2{
  4736                          ; original = 11 cycles via ora to eor)
  4737  f690 a006               	ldy #4+(CLOCK-3)*2	; 1*2 = 2 * 5 extra cycles @ 4MHz
  4738  f692 88                 -	dey
  4739  f693 d0fd               	bne -
  4740  f695 ea                 	nop
  4741                          }
  4742  f696 4d4fde             	eor via2+pra		; receive 2 bits
  4743  f699 4a                 	lsr
  4744  f69a 4a                 	lsr
  4745  f69b 45a6               	eor jdtemp
  4746                          !if CLOCK = 2{
  4747                          	pha			; 11 cycles
  4748                          	pla
  4749                          	nop
  4750                          	nop
  4751                          }
  4752                          !if CLOCK > 2{
  4753                          ; original = 11 cycles via ora to eor)
  4754  f69d a006               	ldy #4+(CLOCK-3)*2	; 1*2 = 2 * 5 extra cycles @ 4MHz
  4755  f69f 88                 -	dey
  4756  f6a0 d0fd               	bne -
  4757  f6a2 ea                 	nop
  4758                          }
  4759  f6a3 4d4fde             	eor via2+pra		; receive 2 bits
  4760                          !if CLOCK > 1{
  4761                          ; original = min. 20 cycles via eor to jlread)
  4762                          ; NECESSARY !
  4763  f6a6 a015               	ldy #3+(CLOCK-1)*6	; 3*6 = 18 * 5 extra cycles @ 4MHz
  4764  f6a8 88                 -	dey
  4765  f6a9 d0fd               	bne -
  4766                          } 
  4767                          !if CLOCK > 1{
  4768  f6ab a000               	ldy #0
  4769                          }
  4770  f6ad 2c5b03             	bit verck		; performing verify?
  4771  f6b0 300b               	bmi jlveri		; yes, -> VERIFY
  4772                          
  4773  f6b2 9194               	sta (eal),y		; save read byte
  4774                          
  4775  f6b4 e694               jlvcont:inc eal
  4776  f6b6 d0ad               	bne jlread
  4777                          
  4778  f6b8 e695               	inc eal+1
  4779  f6ba 4c65f6             	jmp jlread		; next byte
  4780                          ; VERIFY
  4781  f6bd d194               jlveri:	cmp (eal),y		; compare OK?
  4782  f6bf f0f3               	beq jlvcont		; yes, -> continue
  4783                          
  4784  f6c1 38                 	sec
  4785  f6c2 a910               	lda #$10		; VERIFY ERROR
  4786  f6c4 859b               	sta status
  4787  f6c6 d0ec               	bne jlvcont		; always ->
  4788                          ; ########################################### JIFFY ###############################################
  4789                           ; JIFFY DOS subroutines
  4790                          ;**  This is a routine used by JiffyDOS to untalk device (A), then TALK and
  4791                          ;    TKSA is executed to current device with current secondary address.
  4792                          jdTalkTKSA:
  4793  f6c8 20abff             	jsr untlk
  4794                          
  4795  f6cb a59e               	lda fa
  4796  f6cd 20b4ff             	jsr talk
  4797                          
  4798  f6d0 a59f               	lda sa
  4799  f6d2 4c96ff             	jmp tksa
  4800                          ; ########################################### JIFFY ###############################################
  4801                          ;**  JiffyDOS: read an IEC byte 
  4802                          jdIecByteIn:
  4803  f6d5 78                 	sei
  4804  f6d6 24a4               	bit r2d2		; JiffyDOS device?
  4805  f6d8 7003               	bvs jbyin		; yes
  4806                          
  4807  f6da 4c35f5             	jmp IecByteIn		; no, -> normal read routine
  4808                          ;**  Read a byte from the IEC bus	
  4809  f6dd ad4fde             jbyin:	lda via2+pra
  4810  f6e0 cd4fde             	cmp via2+pra		; debounce
  4811  f6e3 d0f8               	bne jbyin
  4812  f6e5 cd4fde             	cmp via2+pra		; debounce
  4813  f6e8 d0f3               	bne jbyin
  4814  f6ea cd4fde             	cmp via2+pra		; debounce
  4815  f6ed d0ee               	bne jbyin
  4816  f6ef c940               	cmp #$40		; DATA = H (0V) + CLK = H (0V) 
  4817  f6f1 90ea               	bcc jbyin		; yes, wait
  4818                          ; sender is ready = CLK gets L (5V) >=$40
  4819                          ;   receiver here still holds CLK H (0V)
  4820  f6f3 2907               	and #$07
  4821  f6f5 48                 	pha			; save .a
  4822                          	
  4823                          ; original >= 14 cycles wait for VIC raster (orig. 31 via lda to sta)
  4824  f6f6 8a                 	txa			; save .x
  4825  f6f7 a21f               	ldx #1+(CLOCK-1)*10	; 3*10 = 30 * 5 extra cycles @ 4MHz
  4826  f6f9 ca                 -	dex
  4827  f6fa d0fd               	bne -
  4828  f6fc aa                 	tax			; restore .x
  4829  f6fd ea                 	nop
  4830  f6fe ea                 	nop
  4831                          
  4832  f6ff 68                 	pla			; restore .a
  4833                          ; send ready to receive with DATA = L (5V)
  4834  f700 8d4fde             	sta via2+pra		; store %0000 0xxx = all lines L (5V)
  4835  f703 85a5               	sta bsour1
  4836                          ; optimized: 14 is perfect (12-16 are OK)
  4837                          !if CLOCK = 2{
  4838                          	pha			; 14 cycles
  4839                          	pla
  4840                          	pha
  4841                          	pla
  4842                          }
  4843                          !if CLOCK > 2{
  4844                          ; original = 16 cycles via sta to ora)
  4845                          ; optimized: 30 / 45 cycles are perfect (at 4MHz works 40-50)
  4846  f705 8a                 	txa			; save .x
  4847  f706 a207               	ldx #1+(CLOCK-2)*3	; 2*3 = 6 * 5 extra cycles @ 4MHz
  4848  f708 ca                 -	dex
  4849  f709 d0fd               	bne -
  4850  f70b aa                 	tax			; restore .x
  4851  f70c ea                 	nop
  4852  f70d 2400               	bit zp
  4853                          } 	
  4854  f70f a5a5               	lda bsour1		; optimized - one cycle less (orig. 2x nop) 
  4855  f711 0920               	ora #$20
  4856  f713 48                 	pha
  4857                          ; read 8 bits
  4858  f714 0d4fde             	ora via2+pra		; receive 2 bits
  4859  f717 4a                 	lsr
  4860  f718 4a                 	lsr
  4861  f719 ea                 	nop
  4862                          !if CLOCK = 2{
  4863                          	pha			; 10 cycles
  4864                          	pla
  4865                          	bit zp
  4866                          }
  4867                          !if CLOCK > 2{
  4868                          ; original = 10 cycles via ora to ora)
  4869  f71a 48                 	pha
  4870  f71b 8a                 	txa			; save .x
  4871  f71c a203               	ldx #1+(CLOCK-3)*2	; 1*2 = 2 * 5 extra cycles @ 4MHz
  4872  f71e ca                 -	dex
  4873  f71f d0fd               	bne -
  4874  f721 aa                 	tax			; restore .x
  4875  f722 68                 	pla
  4876  f723 2400               	bit zp			; 3 cycles
  4877                          }
  4878  f725 0d4fde             	ora via2+pra		; receive 2 bits
  4879  f728 4a                 	lsr
  4880  f729 4a                 	lsr
  4881  f72a 45a5               	eor bsour1
  4882                          !if CLOCK = 2{
  4883                          	pha			; 11 cycles
  4884                          	pla
  4885                          	nop
  4886                          	nop
  4887                          }
  4888                          !if CLOCK > 2{
  4889                          ; original = 11 cycles via ora to eor)
  4890  f72c 48                 	pha
  4891  f72d 8a                 	txa			; save .x
  4892  f72e a203               	ldx #1+(CLOCK-3)*2	; 1*2 = 2 * 5 extra cycles @ 4MHz
  4893  f730 ca                 -	dex
  4894  f731 d0fd               	bne -
  4895  f733 aa                 	tax			; restore .x
  4896  f734 68                 	pla
  4897  f735 ea                 	nop
  4898  f736 ea                 	nop
  4899  f737 ea                 	nop
  4900                          }
  4901  f738 4d4fde             	eor via2+pra		; receive 2 bits
  4902  f73b 4a                 	lsr
  4903  f73c 4a                 	lsr
  4904  f73d 45a5               	eor bsour1
  4905                          !if CLOCK = 2{
  4906                          	pha			; 11 cycles
  4907                          	pla
  4908                          	nop
  4909                          	nop
  4910                          }
  4911                          !if CLOCK > 2{
  4912                          ; original = 11 cycles via eor to eor)
  4913  f73f 48                 	pha
  4914  f740 8a                 	txa			; save .x
  4915  f741 a203               	ldx #1+(CLOCK-3)*2	; 1*2 = 2 * 5 extra cycles @ 4MHz
  4916  f743 ca                 -	dex
  4917  f744 d0fd               	bne -
  4918  f746 aa                 	tax			; restore .x
  4919  f747 68                 	pla
  4920  f748 ea                 	nop
  4921  f749 ea                 	nop
  4922  f74a ea                 	nop
  4923                          }
  4924  f74b 4d4fde             	eor via2+pra		; receive 2 bits
  4925  f74e 85a5               	sta bsour1
  4926                          
  4927                          !if CLOCK > 1{
  4928                          ; original = 15 cycles via eor to sta)
  4929  f750 8a                 	txa			; save .x
  4930  f751 a207               	ldx #1+(CLOCK-2)*3	; 2*3 = 6 * 5 extra cycles @ 4MHz
  4931  f753 ca                 -	dex
  4932  f754 d0fd               	bne -
  4933  f756 aa                 	tax			; restore .x
  4934  f757 ea                 	nop
  4935  f758 2400               	bit zp			; 3 cycles
  4936                          } 
  4937  f75a 68                 	pla
  4938  f75b 2c4fde             	bit via2+pra
  4939  f75e 8d4fde             	sta via2+pra		; store %0010 0xxx, DATA line = H (0V)
  4940                          ; Check EOI?
  4941  f761 502c               	bvc jbyinx		; no EOI: CLK = H (0V) -> exit and return byte
  4942                          ; CLK = L (5V)
  4943  f763 1025               	bpl jseteoi		; EOI: CLK = L (5V), DATA = H (0V) -> set EOI
  4944                          ; DATA = L (5V)
  4945  f765 a942               	lda #$42		; EOI & READ TIME OUT
  4946  f767 4cd1f4             	jmp csberr
  4947                          ; ########################################### JIFFY ###############################################
  4948                          jdIecByteIn2:
  4949  f76a 20d5f6             	jsr jdIecByteIn
  4950                          
  4951  f76d 48                 	pha
  4952  f76e 24a4               	bit r2d2		; test bit6, device is a JD device?
  4953  f770 5011               	bvc jbyin2x		; no, ->
  4954                          
  4955  f772 a000               	ldy #0
  4956  f774 b190               	lda (fnadr),y		; current filename
  4957  f776 c924               	cmp #'$'		; directory?
  4958  f778 f009               	beq jbyin2x		; yes, -> exit
  4959                          
  4960  f77a e69f               	inc sa			; why ???
  4961  f77c 20c8f6             	jsr jdTalkTKSA
  4962                          
  4963  f77f c69f               	dec sa
  4964  f781 06a4               	asl r2d2		; why ???
  4965                          
  4966  f783 68                 jbyin2x:pla
  4967  f784 60                 	rts
  4968                          ; ########################################### JIFFY ###############################################
  4969                          ;**  Set bit 4 of the Status
  4970                          SetStatusBit4:
  4971  f785 a910               	lda #$10
  4972  f787 4caafe             	jmp udst
  4973                          ; ########################################### JIFFY ###############################################
  4974  f78a a940               jseteoi:lda #$40		; set EOI
  4975  f78c 20aafe             	jsr udst		; update status
  4976                          
  4977  f78f a5a5               jbyinx:	lda bsour1		; read data byte from IEC bus
  4978                          
  4979  f791 58                 	cli			; enable interrrupts
  4980  f792 18                 	clc			; good exit
  4981  f793 60                 	rts
  4982                          ; ########################################### JIFFY ###############################################
  4983                          ;**  The following routine is used to send a byte to a device on ther serial bus.
  4984                          ;    The routine checks if the device is a JiffyDOS device by reading r2d2.
  4985                          ;    If it is not a JiffyDOS device, the routine jumps back to the original load routine.
  4986                          jdSendByte:
  4987  f794 78                 	sei
  4988  f795 24a4               	bit r2d2		; JiffyDOS device?
  4989  f797 7009               	bvs jsbyte		; yes -> send jiffy byte 
  4990                          ; second check?
  4991  f799 a5a4               	lda r2d2		; JiffyDOS device?
  4992  f79b c9a0               	cmp #$a0		; shifted in EOI bit#7 + jiffy bit#6 shifted to #5
  4993  f79d b003               	bcs jsbyte		; yes -> send jiffy byte 
  4994                          ; normal send
  4995  f79f 4c23f4             	jmp isour		; no jiffy dev -> send byte standard 
  4996                          
  4997  f7a2 8a                 jsbyte:	txa			; save X
  4998  f7a3 48                 	pha
  4999                          
  5000  f7a4 a5a5               	lda bsour		; byte to be send
  5001  f7a6 29f0               	and #$f0
  5002  f7a8 48                 	pha			; save upper four bits
  5003                          
  5004  f7a9 a5a5               	lda bsour
  5005  f7ab 290f               	and #$0f
  5006  f7ad aa                 	tax			; X = lower four bits of data byte
  5007                          
  5008                          
  5009  f7ae ad4fde             jsb2dah:lda via2+pra		; DATA line = H (0V)?
  5010  f7b1 10fb               	bpl jsb2dah		; yes -> wait
  5011                          ; receiver is ready if sets data = L (5V)
  5012  f7b3 2907               	and #$07		; store via2 pra register value with cleared IEC bits
  5013  f7b5 85a5               	sta bsour		; ..to byte to send
  5014  f7b7 8d4fde             	sta via2+pra		; all lines L (5V)
  5015                          ; start transmission with setting all lines L
  5016                          !if CLOCK > 1{
  5017                          ; original = 10 cycles via sta to ora)
  5018  f7ba 8a                 	txa			; save .x
  5019  f7bb a205               	ldx #1+(CLOCK-2)*2	; 2*2 = 4 * 5 extra cycles @ 4MHz
  5020  f7bd ca                 -	dex
  5021  f7be d0fd               	bne -
  5022  f7c0 aa                 	tax			; restore .x
  5023                          }
  5024                          ; send 8 bits
  5025  f7c1 68                 	pla			; upper four bits
  5026  f7c2 05a5               	ora bsour
  5027  f7c4 8d4fde             	sta via2+pra		; send bits 4 (CLK) and 5 (DATA)
  5028  f7c7 4a                 	lsr
  5029  f7c8 4a                 	lsr
  5030  f7c9 29f0               	and #$f0
  5031  f7cb 05a5               	ora bsour
  5032                          ; tuned here +2cycles for the complete time of bits 4,5 + 6,7 transmission
  5033                          !if CLOCK = 2{
  5034                          	pha			; 14 cycles
  5035                          	pla
  5036                          	pha
  5037                          	pla
  5038                          }
  5039                          !if CLOCK > 2{
  5040                          ; original = 12 cycles via sta to sta)
  5041  f7cd 48                 	pha
  5042  f7ce 8a                 	txa			; save .x
  5043  f7cf a206               	ldx #3+(CLOCK-3)*3	; 1+1*3 = (1 + 3) * 5 extra cycles @ 4MHz
  5044  f7d1 ca                 -	dex
  5045  f7d2 d0fd               	bne -
  5046  f7d4 aa                 	tax			; restore .x
  5047  f7d5 68                 	pla
  5048  f7d6 ea                 	nop			; tuned here
  5049                          }
  5050  f7d7 8d4fde             	sta via2+pra		; send bits 6 and 7
  5051                          ; send lower nibble encoded from table
  5052                          !if CLOCK > 1{
  5053                          ; original = 10 cycles via sta to sta)
  5054  f7da 8a                 	txa			; save .x
  5055  f7db a205               	ldx #1+(CLOCK-2)*2	; 2*2 = 4 * 5 extra cycles @ 4MHz
  5056  f7dd ca                 -	dex
  5057  f7de d0fd               	bne -
  5058  f7e0 aa                 	tax			; restore .x
  5059  f7e1 2400               	bit zp			; tuned here 3cy
  5060                          }
  5061  f7e3 bd35f8             	lda jdLoNibbleEnc,x	; load lower four bits encoded
  5062  f7e6 05a5               	ora bsour
  5063  f7e8 8d4fde             	sta via2+pra		; send bits bits 4+5 of encoded value
  5064                          
  5065  f7eb 4a                 	lsr
  5066  f7ec 4a                 	lsr
  5067  f7ed 29f0               	and #$f0
  5068  f7ef 05a5               	ora bsour
  5069                          !if CLOCK = 2{
  5070                          	pha			; 13 cycles
  5071                          	pla
  5072                          	nop
  5073                          	nop
  5074                          	nop
  5075                          }
  5076                          !if CLOCK > 2{
  5077                          ; original = 12 cycles via sta to sta)
  5078  f7f1 48                 	pha
  5079  f7f2 8a                 	txa			; save .x
  5080  f7f3 a205               	ldx #2+(CLOCK-3)*3	; 1+1*3 = (1 + 3) * 5 extra cycles @ 4MHz
  5081  f7f5 ca                 -	dex
  5082  f7f6 d0fd               	bne -
  5083  f7f8 aa                 	tax			; restore .x
  5084  f7f9 68                 	pla
  5085  f7fa ea                 	nop			; tuned here
  5086                          }
  5087  f7fb 8d4fde             	sta via2+pra		; send bits 6+7 of encoded value
  5088                          
  5089                          ; check if EOI needed?
  5090  f7fe 290f               	and #$0f
  5091  f800 24a4               	bit r2d2		; EOI needed?
  5092  f802 3002               	bmi jsb2eoi		; yes, -> signal EOI: CLK = L (0V)
  5093                          ; no EOI
  5094  f804 0910               	ora #$10		; CLK = H (0V)
  5095                          jsb2eoi:
  5096                          !if CLOCK = 2{
  5097                          	pha			; 13 cycles
  5098                          	pla
  5099                          	nop
  5100                          	nop
  5101                          	nop
  5102                          }
  5103                          !if CLOCK > 2{
  5104                          ; original = 12 cycles via sta to sta)
  5105  f806 48                 	pha
  5106  f807 8a                 	txa			; save .x
  5107  f808 a206               	ldx #3+(CLOCK-3)*3	; 1*3 = 3 * 5 extra cycles @ 4MHz
  5108  f80a ca                 -	dex
  5109  f80b d0fd               	bne -
  5110  f80d aa                 	tax			; restore .x
  5111  f80e 68                 	pla
  5112                          }
  5113  f80f 8d4fde             	sta via2+pra		; CLK+DATA = H (CLK = L if EOI)
  5114                          !if CLOCK > 1{
  5115                          ; original = 14 cycles via sta to sta)
  5116  f812 8a                 	txa			; save .x
  5117  f813 a207               	ldx #1+(CLOCK-2)*3	; 2*3 = 6 * 5 extra cycles @ 4MHz
  5118  f815 ca                 -	dex
  5119  f816 d0fd               	bne -
  5120  f818 aa                 	tax			; restore .x
  5121  f819 ea                 	nop
  5122  f81a ea                 	nop
  5123                          }
  5124  f81b 68                 	pla
  5125  f81c aa                 	tax			; restore X
  5126                          
  5127  f81d a5a5               	lda bsour
  5128  f81f 0910               	ora #$10		; CLK = H (0V)
  5129  f821 8d4fde             	sta via2+pra
  5130                          ; small delay to prevent false frame errors
  5131  f824 eaeaeaeaeaea       	+IECDelay (CLOCK-1)*2
  5132                          
  5133  f82a 2c4fde             	bit via2+pra		; DATA line = H (0V)?
  5134  f82d 3003               	bmi jsberr		; no, -> error
  5135                          
  5136  f82f 58                 	cli			; enable interrrupts
  5137  f830 18                 	clc			; good exit
  5138  f831 60                 	rts
  5139                          ; error
  5140  f832 4ccff4             jsberr:	jmp frmerr		; no -> framing error
  5141                          ; ########################################### JIFFY ###############################################
  5142                          ; Encoding table for lower nibble of the byte to be send to a JiffyDOS device.
  5143                          jdLoNibbleEnc:
  5144  f835 008020a040c060e0   !byte $00, $80, $20, $A0, $40, $C0, $60, $E0
  5145  f83d 109030b050d070f0   !byte $10, $90, $30, $B0, $50, $D0, $70, $F0
  5146                          }
  5147                          ; -------------------------------------------------------------------------------------------------
  5148                          ; alocat - alocatate space
  5149                          ;  entry:
  5150                          ;    .x- low # of bytes needed
  5151                          ;    .y- high # of bytes needed
  5152                          ;  exit :
  5153                          ;    c-clr  no problem alocatating space
  5154                          ;     .x,.y is start address of alocatated space
  5155                          ;    c-set  problem with alocatation
  5156                          ;     if .a =$ff then alocatation refused (cannot cross segment boundrys)
  5157                          ;     if .a =$4x then top of memory needs to be changed
  5158                          ;     return to language
  5159                          ;-----------------------------------------------------------------------
  5160                          alocat:
  5161  f845 8a                 tttop:	txa			; calc new hiadr
  5162  f846 38                 	sec
  5163  f847 49ff               	eor #$ff		; invert
  5164  f849 6d5403             	adc hiadr		; sub low from end of system RAM
  5165  f84c aa                 	tax
  5166  f84d 98                 	tya
  5167  f84e 49ff               	eor #$ff
  5168  f850 6d5503             	adc hiadr+1		; sub high
  5169  f853 a8                 	tay
  5170  f854 b006               	bcs top010
  5171  f856 a9ff               refuse:	lda #$ff		; allocation refused...crossed boundry
  5172  f858 0940               topbad:	ora #$40		; want top of memory changed
  5173  f85a 38                 	sec			; c=1 Not enough memory available 
  5174  f85b 60                 	rts			; return unsuccessful
  5175                          
  5176  f85c cc5903             top010:	cpy memsiz+1		; compare new high address with user memory high
  5177  f85f 90f7               	bcc topbad		; branch if new high lower = not enough memory alocatatable
  5178  f861 d005               	bne topxit		; branch to memoryok if new high > 
  5179  f863 ec5803             	cpx memsiz		; if higbyte equal compare low
  5180  f866 90f0               	bcc topbad		; branch if lower = not enough memory alocatatable
  5181  f868 8e5403             topxit:	stx hiadr		; store new end of system memory ($)
  5182  f86b 8c5503             	sty hiadr+1
  5183  f86e 18                 	clc
  5184  f86f 60                 	rts
  5185                          ; -------------------------------------------------------------------------------------------------
  5186                          ; ##### channelio #####
  5187                          ;*****************************************
  5188                          ;* getin -- get character from channel   *
  5189                          ;*      channel is determined by dfltn.  *
  5190                          ;* if device is 0, keyboard queue is     *
  5191                          ;* examined and a character removed if   *
  5192                          ;* available.  devices 1,3-31 advance to *
  5193                          ;* basin.                                *
  5194                          ;*                                       *
  5195                          ;* exit:  .a = character                 *
  5196                          ;*        cy = 1, stop key error for cas-*
  5197                          ;*                cassetes and rs232     *
  5198                          ;*           = 0, otherwise.             *
  5199                          ;*        z  = 1, if kbd and queue empty.*
  5200                          ;*****************************************
  5201                          ; F444
  5202  f870 a5a0               ngetin:	lda dfltn		; check device
  5203  f872 d00c               	bne gn10		; not keyboard
  5204                          
  5205  f874 a5d8               	lda ndx			; queue index
  5206  f876 05dd               	ora kyndx		; check function key que
  5207  f878 f009               	beq gn20		; nobody there...exit
  5208                          
  5209  f87a 78                 	sei
  5210  f87b 2007e0             	jsr jlp2		; go remove a character
  5211  f87e 18                 	clc
  5212  f87f 60                 	rts
  5213                          
  5214                          ; Check for input from device 2 = RS232
  5215                          gn10:
  5216                          ;	cmp #2			; is it rs-232
  5217                          ;	beq gn232
  5218  f880 4ccfff             	jmp basin		; no...use basin
  5219                          
  5220                          ; getin RS232
  5221                          gn232:
  5222                          ;	sty xsav		; save .y...
  5223                          ;	stx savx		; ..and .x
  5224                          ;	ldy ridbs		; get last byte address
  5225                          ;	cpy ridbe		; see if buffer emptyy
  5226                          ;	bne gn15		; rs232 buffer not empty...
  5227                          ;
  5228                          ;	lda acia+cdr		; make sure receiver is on
  5229                          ;	and #$FD
  5230                          ;	ora #$01		; bits(10) = 01 now
  5231                          ;	sta acia+cdr
  5232                          ;	lda rsstat		; set empty input buffer condition
  5233                          ;	ora #$10
  5234                          ;	sta rsstat
  5235                          ;	beq gnexit		; always
  5236                          
  5237                          ; Get one byte from RS232 input buffer
  5238                          gn15:
  5239                          ;	lda rsstat		; clear empty buffer status
  5240                          ;	and #$ef
  5241                          ;	sta rsstat
  5242                          ;	ldx i6509
  5243                          ;	lda ribuf+2
  5244                          ;	sta i6509		; point at buffer
  5245                          ;	lda (ribuf),y		; get last char
  5246                          ;	stx i6509		; restore
  5247                          ;	inc ridbs		; inc to next posistion
  5248                          ;	bit sa			; check for ascii flag
  5249                          ;	bpl gnexit		; not on...
  5250                          ;	jsr tocbm		; convert to cbm code
  5251                          gnexit:
  5252                          ;	ldy xsav		; restore .y
  5253                          ;	ldx savx
  5254  f883 18                 gn20:	clc			; good return
  5255  f884 60                 	rts
  5256                          ; -------------------------------------------------------------------------------------------------
  5257                          ;***************************************
  5258                          ;* basin-- input character from channel*
  5259                          ;*     input differs from get on device*
  5260                          ;* #0 function which is keyboard. the  *
  5261                          ;* screen editor makes ready an entire *
  5262                          ;* line which is passed char by char   *
  5263                          ;* up to the carriage return.          *
  5264                          ;* other devices are:                  *
  5265                          ;*      0 -- keyboard                  *
  5266                          ;*      2 -- usb                       *
  5267                          ;*      3 -- screen                    *
  5268                          ;*   4-31 -- iec   bus                *
  5269                          ;*                                     *
  5270                          ;* exit: cy=1, error for  usb.         *
  5271                          ;*       cy=0, otherwise.              *
  5272                          ;*                                     *
  5273                          ;*       all other errors must be de-  *
  5274                          ;*       tected by checking status !   *
  5275                          ;***************************************
  5276  f885 a5a0               nbasin:	lda dfltn		; check device
  5277  f887 d00b               	bne bn10		; is not keyboard...
  5278                          ; input from keyboard
  5279  f889 a5d2               	lda pntr		; save current...
  5280  f88b 85d5               	sta lstp		; ... cursor column
  5281  f88d a5d1               	lda tblx		; save current...
  5282  f88f 85d6               	sta lsxp		; ... line number
  5283  f891 4ca5f8             	jmp bn15		; blink cursor until return
  5284                          
  5285  f894 c903               bn10:	cmp #3			; is input from screen?
  5286  f896 d012               	bne bn20		; no...
  5287                          ; screen
  5288  f898 05d7               	ora crsw
  5289  f89a 85d7               	sta crsw		; fake a carriage return
  5290  f89c a918               	lda #scymax
  5291  f89e 8d9803             	sta lintmp		; remember bootom line no
  5292  f8a1 a5ed               	lda scxmax		; moved to patch to make space
  5293  f8a3 85dc               	sta indx		; ...up on this line
  5294  f8a5 200ae0             bn15:	jsr jloop5		; pick up characters
  5295  f8a8 18                 	clc
  5296  f8a9 60                 	rts
  5297                          
  5298  f8aa b007               bn20:	bcs bn30		; devices >3
  5299  f8ac c902               	cmp #2			; usb?
  5300  f8ae f00e               	beq bn50
  5301                          
  5302  f8b0 4c7cfc             	jmp error5		; illegal device
  5303                          
  5304                          ; input from iec bus
  5305  f8b3 a59b               bn30:	lda status		; status from last
  5306  f8b5 f004               	beq bn35		; was good
  5307  f8b7 a90d               bn31:	lda #cr			; bad...all done
  5308  f8b9 18                 bn32:	clc			; valid data
  5309  f8ba 60                 bn33:	rts
  5310                          
  5311                          !if JIFFY = 1{			; ##### JIFFY #####
  5312  f8bb 4cd5f6             bn35:	jmp jdIecByteIn
  5313                          } else{
  5314                          bn35:	jmp acptr		; good...handshake
  5315                          }
  5316                          ; input from USB
  5317  f8be ad4fde             bn50:	lda via2+pra		; get usb status
  5318  f8c1 4a                 	lsr			; shift RXF bit#1 to carry
  5319  f8c2 b004               	bcs bn55		; branch if high = no data
  5320  f8c4 ad00dd             	lda usb			; load data
  5321  f8c7 2c                 	!byte $2c		; skip next
  5322                          ; no data
  5323  f8c8 a900               bn55:	lda #0			; return 0
  5324  f8ca 18                 	clc			; good return
  5325  f8cb 60                 	rts
  5326                          ; -------------------------------------------------------------------------------------------------
  5327                          ;***************************************
  5328                          ;* bsout -- out character to channel   *
  5329                          ;*     determined by variable dflto:   *
  5330                          ;*     0 -- invalid                    *
  5331                          ;*     2 -- usb                        *
  5332                          ;*     3 -- screen                     *
  5333                          ;*  4-31 -- iec   bus                 *
  5334                          ;*                                     *
  5335                          ;* exit:  cy=1, error for usb.         *
  5336                          ;*        cy=0, otherwise.             *
  5337                          ;*                                     *
  5338                          ;*       note, other errors must be de-*
  5339                          ;*       tected by checking status !   *
  5340                          ;***************************************
  5341  f8cc 48                 nbsout:	pha			; preserve .a
  5342  f8cd a5a1               	lda dflto		; check device
  5343  f8cf c903               	cmp #3			; is it the screen?
  5344  f8d1 d006               	bne bo10		; no...
  5345                          ; print to crt
  5346  f8d3 68                 	pla			; restore data
  5347  f8d4 200de0             	jsr jprt		; print on crt
  5348  f8d7 18                 	clc
  5349  f8d8 60                 	rts
  5350                          
  5351  f8d9 9004               bo10:	bcc bo20		; device 0, 1 or 2
  5352                          ; print to iec bus
  5353  f8db 68                 	pla
  5354  f8dc 4ca8ff             	jmp ciout
  5355                          
  5356  f8df c902               bo20:	cmp #2			; is it usb?
  5357  f8e1 f004               	beq bo50
  5358  f8e3 68                 	pla
  5359  f8e4 4c7cfc             	jmp error5		; illegal device
  5360                          
  5361  f8e7 ad4fde             bo50:	lda via2+pra		; get usb status
  5362  f8ea 4a                 	lsr			; shift TXE bit#1 to carry
  5363  f8eb 4a                 	lsr
  5364  f8ec b0f9               	bcs bo50		; wait for TXE = low
  5365  f8ee 68                 	pla
  5366  f8ef 8d00dd             	sta usb
  5367  f8f2 60                 	rts
  5368                          ; -------------------------------------------------------------------------------------------------
  5369                          ; ##### openchannel #####
  5370                          ;***************************************
  5371                          ;* nchkin -- open channel for input    *
  5372                          ;*                                     *
  5373                          ;* the number of the logical file to be*
  5374                          ;* opened for input is passed in .x.   *
  5375                          ;* chkin searches the logical file     *
  5376                          ;* to look up device and command info. *
  5377                          ;* errors are reported if the device   *
  5378                          ;* was not opened for input ,(e.g.     *
  5379                          ;* cassette write file), or the logical*
  5380                          ;* file has no reference in the tables.*
  5381                          ;* device 0, (keyboard), and device 3  *
  5382                          ;* (screen), require no table entries  *
  5383                          ;* and are handled separate.           *
  5384                          ;***************************************
  5385  f8f3 20d2f9             nchkin:	jsr lookup		; see if file known
  5386  f8f6 f003               	beq jx310		; yup...
  5387                          
  5388  f8f8 4c76fc             	jmp error3		; no...file not open
  5389                          
  5390  f8fb 20e4f9             jx310:	jsr jz100		; extract file info
  5391  f8fe a59e               	lda fa
  5392  f900 f022               	beq jx320		; is keyboard...done.
  5393                          
  5394                          ; could be screen, keyboard, or serial
  5395  f902 c903               	cmp #3
  5396  f904 f01e               	beq jx320		; is screen...done.
  5397  f906 b020               	bcs jx330		; is serial...address it
  5398  f908 c902               	cmp #2			; rs232?
  5399  f90a d012               	bne jx315		; no...
  5400                          
  5401                          ; rs232 channel
  5402  f90c a59f               	lda sa
  5403  f90e 2902               	and #02			; check for input
  5404  f910 f00f               	beq jx316		; not input file
  5405                          ;	and acia+cdr		; check if running
  5406  f912 f006               	beq jx312		; is...done ?? (rceiver on => yes)
  5407  f914 49ff               	eor #$FF		; flip all bits
  5408                          ;	and acia+cdr		; turn on...
  5409  f916 0901               	ora #$01		; turn on dtr ;bits(10)=01
  5410  f918 48                 	pha
  5411                          ;	jsr rst232		; reset rs232 status
  5412  f919 68                 	pla
  5413                          ;	sta acia+cdr		; set command
  5414  f91a a902               jx312:	lda #2			; device
  5415  f91c d006               	bne jx320		; bra...done
  5416                          
  5417                          ; some extra checks for tape
  5418  f91e 4c7cfc             jx315:	jmp error5		; illegal device
  5419                          
  5420  f921 4c7ffc             jx316:	jmp error6		; not input file
  5421                          
  5422  f924 85a0               jx320:	sta dfltn		; all input come from here
  5423                          
  5424  f926 18                 	clc			; good exit
  5425  f927 60                 	rts
  5426                          
  5427                          ; an serial device has to be a talker
  5428  f928 aa                 jx330:	tax			; device # for dflto
  5429  f929 20b4ff             	jsr talk		; tell him to talk
  5430                          
  5431  f92c a59f               	lda sa			; a second?
  5432  f92e 1006               	bpl jx340		; yes...send it
  5433  f930 20ebf4             	jsr tkatn		; no...let go
  5434  f933 4c39f9             	jmp jx350
  5435                          
  5436  f936 2096ff             jx340:	jsr tksa		; send second
  5437                          
  5438  f939 8a                 jx350:	txa
  5439  f93a 249b               	bit status		; did he listen?
  5440  f93c 10e6               	bpl jx320		; yes
  5441                          
  5442  f93e 4c7cfc             	jmp error5		; device not present
  5443                          ; -------------------------------------------------------------------------------------------------
  5444                          ;***************************************
  5445                          ;* chkout -- open channel for output   *
  5446                          ;*                                     *
  5447                          ;* the number of the logical file to be*
  5448                          ;* opened for output is passed in .x.  *
  5449                          ;* chkout searches the logical file    *
  5450                          ;* to look up device and command info. *
  5451                          ;* errors are reported if the device   *
  5452                          ;* was not opened for input ,(e.g.     *
  5453                          ;* keyboard), or the logical file has  *
  5454                          ;* reference in the tables.            *
  5455                          ;* device 0, (keyboard), and device 3  *
  5456                          ;* (screen), require no table entries  *
  5457                          ;* and are handled separate.           *
  5458                          ;***************************************
  5459  f941 20d2f9             nckout:	jsr lookup		; is file in table?
  5460  f944 f003               	beq ck5			; yes...
  5461                          
  5462  f946 4c76fc             	jmp error3		; no...file not open
  5463                          
  5464  f949 20e4f9             ck5:	jsr jz100		; extract table info
  5465  f94c a59e               	lda fa			; is it keyboard?
  5466  f94e d003               	bne ck10		; no...something else.
  5467                          
  5468  f950 4c82fc             ck20:	jmp error7		; yes...not output file
  5469                          
  5470                          ;could be screen,serial,or tapes
  5471  f953 c903               ck10:	cmp #3
  5472  f955 f012               	beq ck30		; is screen...done
  5473  f957 b014               	bcs ck40		; is serial...address it
  5474  f959 c902               	cmp #2			; rs232?
  5475  f95b d009               	bne ck15
  5476                          
  5477                          ; rs232 output
  5478  f95d a59f               	lda sa			; check if output file
  5479  f95f 4a                 	lsr
  5480  f960 90ee               	bcc ck20		; not so...
  5481                          ;	jsr rst232		; reset rs232 status
  5482                          ;	jsr xon232		; make sure transmit is on
  5483  f962 a902               	lda #2			; device#
  5484  f964 d003               	bne ck30		; bra...done
  5485                          
  5486                          ; special tape channel handling
  5487  f966 4c7cfc             ck15:	jmp error5		; illegal device
  5488                          
  5489  f969 85a1               ck30:	sta dflto		; all output goes here
  5490                          
  5491  f96b 18                 	clc			; good exit
  5492  f96c 60                 	rts
  5493                          
  5494  f96d aa                 ck40:	tax			; save device for dflto
  5495  f96e 20b1ff             	jsr listn		; tell him to listen
  5496                          
  5497  f971 a59f               	lda sa			; is there a second?
  5498  f973 1005               	bpl ck50		; yes...
  5499                          
  5500  f975 20ddf4             	jsr scatn		; no...release lines
  5501  f978 d003               	bne ck60		; branch always
  5502                          
  5503  f97a 2093ff             ck50:	jsr secnd		; send second...
  5504                          
  5505  f97d 8a                 ck60:	txa
  5506  f97e 249b               	bit status		; did he listen?
  5507  f980 10e7               	bpl ck30		; yes...finish up
  5508                          
  5509  f982 4c7cfc             	jmp error5		; no...device not present
  5510                          ; -------------------------------------------------------------------------------------------------
  5511                          ; ##### close #####
  5512                          ;*************************************
  5513                          ;* nclose -- close logical file      *
  5514                          ;*                                   *
  5515                          ;* enter:                            *
  5516                          ;*     cy =1 ,transmit close to dev- *
  5517                          ;*            ice.                   *
  5518                          ;*     cy =0 ,only remove from kernal*
  5519                          ;*            tables.                *
  5520                          ;*                                   *
  5521                          ;*     the logical file number of the*
  5522                          ;* file to be closed is passed in .a.*
  5523                          ;* keyboard, screen, and files not   *
  5524                          ;* open pass straight through. tape  *
  5525                          ;* files open for write are closed by*
  5526                          ;* dumping the last buffer and       *
  5527                          ;* conditionally writing an end of   *
  5528                          ;* tape block.serial files are closed*
  5529                          ;* by sending a close file command if*
  5530                          ;* a secondary address was specified *
  5531                          ;* in its open command.              *
  5532                          ;*************************************
  5533  f985 08                 nclose:	php			; save cy flag
  5534  f986 20d7f9             	jsr jltlk		; look file up
  5535  f989 f003               	beq jx110		; was open...continue
  5536  f98b 28                 	plp
  5537  f98c 18                 	clc			; was never open...no error
  5538  f98d 60                 	rts
  5539                          
  5540  f98e 20e4f9             jx110:	jsr jz100		; extract table data
  5541  f991 28                 	plp			; retrieve cy flag
  5542  f992 8a                 	txa			; save table index
  5543  f993 48                 	pha
  5544  f994 901b               	bcc jx150		; close out table entries only
  5545                          
  5546  f996 a59e               	lda fa			; check device number
  5547  f998 f017               	beq jx150		; is keyboard...done
  5548  f99a c903               	cmp #3
  5549  f99c f013               	beq jx150		; is screen...done
  5550  f99e b00e               	bcs jx120		; is iec...process
  5551  f9a0 c902               	cmp #2			; rs232?
  5552  f9a2 d003               	bne jx115		; no...
  5553                          
  5554                          ; close rs-232
  5555  f9a4 4cb1f9             cls232:	jmp jx150		; jmp...remove file
  5556                          
  5557                          ; close cassette file
  5558  f9a7 68                 jx115:	pla			; cassette now closes the channel...
  5559  f9a8 20b2f9             	jsr jx151		; before transmitting out the final data
  5560  f9ab 4c7cfc             	jmp error5		; illegal device
  5561                          
  5562                          ; close an iec file
  5563  f9ae 202cfc             jx120:	jsr clsei
  5564                          
  5565                          ; entry to remove a give logical file from table of logical, primary, and secondary addresses
  5566  f9b1 68                 jx150:	pla			; get table index off stack
  5567  f9b2 aa                 jx151:	tax			; entry for cassette special
  5568  f9b3 ce5c03             	dec ldtnd
  5569  f9b6 ec5c03             	cpx ldtnd		; is deleted file at end?
  5570  f9b9 f015               	beq jx160		; yes...done
  5571                          
  5572                          ; delete entry in middle by moving last entry to that position.
  5573  f9bb ac5c03             	ldy ldtnd
  5574  f9be b93403             	lda lat,y
  5575  f9c1 9d3403             	sta lat,x
  5576  f9c4 b93e03             	lda fat,y
  5577  f9c7 9d3e03             	sta fat,x
  5578  f9ca b94803             	lda sat,y
  5579  f9cd 9d4803             	sta sat,x
  5580  f9d0 18                 jx160:	clc
  5581  f9d1 60                 jx170:	rts			; close exit
  5582                          
  5583                          ; lookup tablized logical file data
  5584  f9d2 a900               lookup:	lda #0
  5585  f9d4 859b               	sta status
  5586  f9d6 8a                 	txa
  5587  f9d7 ae5c03             jltlk:	ldx ldtnd
  5588  f9da ca                 jx600:	dex
  5589  f9db 302d               	bmi lkups4
  5590  f9dd dd3403             	cmp lat,x
  5591  f9e0 d0f8               	bne jx600
  5592  f9e2 18                 	clc
  5593  f9e3 60                 	rts
  5594                          
  5595                          ; routine to fetch table entries
  5596  f9e4 bd3403             jz100:	lda lat,x
  5597  f9e7 859d               	sta la
  5598  f9e9 bd3e03             	lda fat,x
  5599  f9ec 859e               	sta fa
  5600  f9ee bd4803             	lda sat,x
  5601  f9f1 859f               	sta sa
  5602  f9f3 60                 jz101:	rts
  5603                          
  5604                          ; sa is passed in .y
  5605                          ; routine looks for match in tables
  5606                          ; carry set if not present
  5607                          ; carry clear:
  5608                          ; .a=la,.x=fa,.y=sa
  5609  f9f4 98                 lkupsa:	tya
  5610  f9f5 ae5c03             	ldx ldtnd
  5611  f9f8 ca                 lkups2:	dex
  5612  f9f9 300f               	bmi lkups4
  5613  f9fb dd4803             	cmp sat,x
  5614  f9fe d0f8               	bne lkups2
  5615  fa00 18                 	clc
  5616  fa01 20e4f9             lkups3:	jsr jz100		; get table data
  5617  fa04 a8                 	tay
  5618  fa05 a59d               	lda la
  5619  fa07 a69e               	ldx fa
  5620  fa09 60                 	rts
  5621  fa0a 38                 lkups4:	sec
  5622  fa0b 60                 	rts			; not found exit
  5623                          
  5624                          ; la is passed in .a
  5625                          ; routine looks for match in tables
  5626                          ; carry set if not found
  5627                          ; carry clear:
  5628                          ; .a=la,.x=fa,.y=sa
  5629  fa0c aa                 lkupla:	tax
  5630  fa0d 20d2f9             	jsr lookup
  5631  fa10 90ef               	bcc lkups3
  5632  fa12 60                 	rts
  5633                          ; -------------------------------------------------------------------------------------------------
  5634                          ; ##### clall #####
  5635                          ;******************************************
  5636                          ;* nclall -- close all logical files      *
  5637                          ;*      deletes all table entries and     *
  5638                          ;* restores default i/o channels          *
  5639                          ;* and clears iec port devices           *
  5640                          ;******************************************
  5641                          ;------------------------------------------
  5642                          ; new ncall
  5643                          ;  closes all files untill done or an
  5644                          ;  error occurs.
  5645                          ;  entry:
  5646                          ;    c-clr => close all files
  5647                          ;    c-set => .a = fa (device to be closed)
  5648                          ;------------------------------------------
  5649                          ; Close all logical files
  5650  fa13 6e9303             nclall:	ror xsav		; save carry
  5651  fa16 8d9403             	sta savx		; save .a
  5652  fa19 ae5c03             ncl010:	ldx ldtnd		; scan index
  5653  fa1c ca                 ncl020:	dex
  5654  fa1d 301b               	bmi nclrch		; all done...clear channels (dclose patch 5/31/83)
  5655  fa1f 2c9303             	bit xsav		; check for fixed fa
  5656  fa22 1008               	bpl ncl030		; none...
  5657  fa24 ad9403             	lda savx
  5658  fa27 dd3e03             	cmp fat,x
  5659  fa2a d0f0               	bne ncl020		; no match...
  5660  fa2c bd3403             ncl030:	lda lat,x		; close this la
  5661  fa2f 38                 	sec			; c-set required to close
  5662  fa30 20c3ff             	jsr close
  5663  fa33 90e4               	bcc ncl010
  5664                          
  5665  fa35 a900               ncl040:	lda #0			; original entry for nclall
  5666  fa37 8d5c03             	sta ldtnd		; forget all files
  5667                          ; -------------------------------------------------------------------------------------------------
  5668                          ;********************************************
  5669                          ;* nclrch -- clear channels                 *
  5670                          ;*   unlisten or untalk iec devices, but   *
  5671                          ;* leave others alone.  default channels    *
  5672                          ;* are restored.                            *
  5673                          ;********************************************
  5674  fa3a a203               nclrch:	ldx #3
  5675  fa3c e4a1               	cpx dflto		; is output channel iec?
  5676  fa3e b003               	bcs jx750		; no...
  5677                          
  5678  fa40 20aeff             	jsr unlsn		; yes...unlisten it
  5679                          
  5680  fa43 e4a0               jx750:	cpx dfltn		; is input channel iec?
  5681  fa45 b003               	bcs clall2		; no...
  5682                          
  5683  fa47 20abff             	jsr untlk		; yes...untalk it
  5684                          
  5685                          ; restore default values
  5686  fa4a a203               clall2:	ldx #3
  5687  fa4c 86a1               	stx dflto		; output chan=3=screen
  5688  fa4e a900               	lda #0
  5689  fa50 85a0               	sta dfltn		; input chan=0=keyboard
  5690  fa52 60                 	rts
  5691                          ; -------------------------------------------------------------------------------------------------
  5692                          ; ##### open #####
  5693                          ;***********************************
  5694                          ;*                                 *
  5695                          ;* open function                   *
  5696                          ;*                                 *
  5697                          ;* enter: cy=1, transmit command to*
  5698                          ;*              device.            *
  5699                          ;*        cy=0, perform open opera-*
  5700                          ;*              tion.              *
  5701                          ;*                                 *
  5702                          ;* la, fa, sa must be set up prior *
  5703                          ;* to the call to this routine, as *
  5704                          ;* well as the file name descript- *
  5705                          ;* tor.                            *
  5706                          ;*                                 *
  5707                          ;***********************************
  5708                          ; F6C6
  5709  fa53 9003               nopen:	bcc     op000		; do open
  5710  fa55 4ccdfa             	jmp     tranr		; do transmit
  5711                          
  5712                          ;***********************************
  5713                          ;*                                 *
  5714                          ;* create an entry in the logical  *
  5715                          ;* files tables consisting of      *
  5716                          ;* logical file number--la, device *
  5717                          ;* number--fa, and secondary cmd-- *
  5718                          ;* sa.                             *
  5719                          ;*                                 *
  5720                          ;* a file name descriptor, fnadr & *
  5721                          ;* fnlen, is passed to this routine*
  5722                          ;*                                 *
  5723                          ;***********************************
  5724                          ; F6CB
  5725  fa58 a69d               op000:	ldx la			; check file #
  5726                          
  5727                          ; bne op98 ;is not the keyboard
  5728                          ; jmp error6 ;not input file...
  5729                          
  5730  fa5a 20d2f9             op98:	jsr lookup		; see if in table
  5731  fa5d d003               	bne op100		; not found...o.k.
  5732                          
  5733  fa5f 4c73fc             	jmp error2		; file open
  5734                          
  5735  fa62 ae5c03             op100:	ldx ldtnd		; logical device table end
  5736  fa65 e00a               	cpx #10			; maximum # of open files
  5737  fa67 9003               	bcc op110		; less than 10...o.k.
  5738                          
  5739  fa69 4c70fc             	jmp error1		; too many files
  5740                          
  5741  fa6c ee5c03             op110:	inc ldtnd		; new file
  5742  fa6f a59d               	lda la
  5743  fa71 9d3403             	sta lat,x		; store logical file #
  5744  fa74 a59f               	lda sa
  5745  fa76 0960               	ora #$60		; make sa an iec command
  5746  fa78 859f               	sta sa
  5747  fa7a 9d4803             	sta sat,x		; store command #
  5748  fa7d a59e               	lda fa
  5749  fa7f 9d3e03             	sta fat,x		; store device #
  5750                          
  5751                          ; perform device specific open tasks
  5752  fa82 f015               	beq op175		; is keyboard...done.
  5753  fa84 c903               	cmp #3
  5754  fa86 f011               	beq op175		; is screen...done.
  5755  fa88 9005               	bcc op150		; are cassettes 1 & 2
  5756                          
  5757  fa8a 209bfa             	jsr openi		; is on iec...open it
  5758  fa8d 900a               	bcc op175		; branch always...done
  5759                          
  5760                          ; perform tape open stuff
  5761  fa8f c902               op150:	cmp #2
  5762  fa91 d003               	bne op152
  5763                          
  5764                          ; USB - nothing to do
  5765  fa93 4c99fa             	jmp op175
  5766                          
  5767  fa96 4c7cfc             op152:	jmp error5		; illegal device
  5768                          
  5769  fa99 18                 op175:	clc			; flag good open
  5770  fa9a 60                 op180:	rts			; exit in peace
  5771                          
  5772  fa9b a59f               openi:	lda sa
  5773  fa9d 302c               	bmi op50		; no sa...done
  5774                          
  5775  fa9f a49c               	ldy fnlen
  5776  faa1 f028               	beq op50		; no file name...done
  5777                          
  5778  faa3 a59e               	lda fa
  5779  faa5 20b1ff             	jsr listn		; device la to listen
  5780                          
  5781  faa8 a59f               	lda sa
  5782  faaa 09f0               	ora #$f0
  5783  faac 2093ff             openib:	jsr secnd
  5784                          
  5785  faaf a59b               	lda status		; anybody home? (set by nodev)
  5786  fab1 1005               	bpl op35		; yes...continue
  5787                          
  5788  fab3 68                 	pla
  5789  fab4 68                 	pla
  5790  fab5 4c7cfc             	jmp error5		; device not present
  5791                          
  5792  fab8 a59c               op35:	lda fnlen
  5793  faba f00c               	beq op45		; no name...done sequence
  5794                          
  5795                          ; send file name over iec
  5796  fabc a000               	ldy #0
  5797  fabe b190               op40:	lda (fnadr),y
  5798  fac0 20a8ff             	jsr ciout
  5799  fac3 c8                 	iny
  5800  fac4 c49c               	cpy fnlen
  5801  fac6 d0f6               	bne op40
  5802                          
  5803  fac8 20aeff             op45:	jsr unlsn
  5804                          
  5805  facb 18                 op50:	clc			; no  error
  5806  facc 60                 	rts
  5807                          ; -------------------------------------------------------------------------------------------------
  5808                          ;*****************************************
  5809                          ;*  transmit command to device           *
  5810                          ;*                                       *
  5811                          ;*   fnlen,fnadr must be set up already  *
  5812                          ;*   to contain the command string.      *
  5813                          ;*   fa must be set for the device.      *
  5814                          ;*****************************************
  5815                          ; F741
  5816  facd a59e               tranr:  lda fa
  5817  facf 20b1ff             	jsr listn
  5818  fad2 a96f               	lda #$6F
  5819  fad4 859f               	sta sa
  5820  fad6 4cacfa             	jmp openib
  5821                          ; -------------------------------------------------------------------------------------------------
  5822                          ; ##### load #####
  5823                          ;**************************************
  5824                          ;* load ram function     10/30/81     *
  5825                          ;*                                    *
  5826                          ;*  loads from iec bus devices        *
  5827                          ;*  >=4 to 31 as determined by        * 
  5828                          ;*  contents of variable fa.          *
  5829                          ;* entry:                             *
  5830                          ;*   .a(bit 7)=0 performs load        *
  5831                          ;*   .a(bit 7)=1 performs verify      *
  5832                          ;*   .a(bits 0-3)=RAM0 bank           *
  5833                          ;*   .x=start address low             *
  5834                          ;*   .y=start address high            *
  5835                          ;*   if .x=$ff & .y=$ff => fixed load *
  5836                          ;* exit:                              *
  5837                          ;*   .a(bits 0-3)=RAM0 bank           *
  5838                          ;*   .x=end address low               *
  5839                          ;*   .y=end address high              *
  5840                          ;*                                    *
  5841                          ;**************************************
  5842  fad9 8e5e03             nload:	stx relsal		; save alt address
  5843  fadc 8c5f03             	sty relsah
  5844  fadf 8d5b03             	sta verck		; set verify flag (n)
  5845  fae2 290f               	and #%00001111		; isolate bank bits #0-3
  5846  fae4 8d6003             	sta relsab		; save bank
  5847  fae7 a900               	lda #0			; clear status
  5848  fae9 859b               	sta status
  5849                          
  5850  faeb a59e               	lda fa			; check device number
  5851  faed c904               	cmp #4
  5852  faef b003               	bcs ld20
  5853                          
  5854  faf1 4c88fc             	jmp error9		; bad device #
  5855                          
  5856                          ; load from cbm iec device
  5857  faf4 a960               ld20:	lda #$60		; special load command
  5858  faf6 859f               	sta sa
  5859                          
  5860  faf8 a49c               	ldy fnlen		; must have file name
  5861  fafa d003               	bne ld25		; yes...ok
  5862                          
  5863  fafc 4c85fc             	jmp error8		; missing file name
  5864                          
  5865  faff 208ffb             ld25:	jsr luking		; tell user looking
  5866  fb02 209bfa             	jsr openi		; open the file
  5867                          
  5868  fb05 a59e               	lda fa
  5869  fb07 20b4ff             	jsr talk		; establish the channel
  5870  fb0a a59f               	lda sa
  5871  fb0c 2096ff             	jsr tksa		; tell it to load
  5872                          
  5873  fb0f 20a5ff             	jsr acptr		; get first byte
  5874  fb12 8594               	sta eal
  5875  fb14 8596               	sta stal
  5876                          
  5877  fb16 a59b               	lda status		; test status for error
  5878  fb18 4a                 	lsr
  5879  fb19 4a                 	lsr
  5880  fb1a 9003               	bcc ld30		; file  found...
  5881                          
  5882  fb1c 4c79fc             	jmp error4		; file not found error
  5883                          
  5884                          ld30:
  5885                          !if JIFFY = 1{			; ##### JIFFY #####
  5886  fb1f 206af7             	jsr jdIecByteIn2
  5887                          } else{
  5888                          	jsr acptr
  5889                          }
  5890  fb22 8595               	sta eah
  5891  fb24 8597               	sta stah
  5892                          
  5893                          ; test for fixed or moveable load
  5894  fb26 ad5e03             	lda relsal
  5895  fb29 2d5f03             	and relsah
  5896  fb2c c9ff               	cmp #$ff
  5897  fb2e f00e               	beq ld35		; fixed load
  5898                          
  5899  fb30 ad5e03             	lda relsal
  5900  fb33 8594               	sta eal
  5901  fb35 8596               	sta stal
  5902  fb37 ad5f03             	lda relsah
  5903  fb3a 8595               	sta eah
  5904  fb3c 8597               	sta stah
  5905  fb3e 2050fc             ld35:	jsr SwitchBank		; switch to new bank
  5906                          !if JIFFY = 1{			; ##### JIFFY #####
  5907  fb41 4c03f6             	jmp jdLOAD
  5908                          
  5909  fb44 20e1ff             ld40:	jsr stop		; STOP key?
  5910  fb47 d006               	bne ld45		; no, -> continue
  5911                          
  5912  fb49 2064fc             	jsr RestoreBank
  5913  fb4c 4c1ffc             	jmp break
  5914                          
  5915  fb4f 20d5f6             ld45:	jsr jdIecByteIn
  5916                          	
  5917  fb52 a59b               	lda status
  5918  fb54 29fd               	and #$fd
  5919  fb56 c59b               	cmp status		; Read timeout?
  5920  fb58 859b               	sta status
  5921  fb5a d0e8               	bne ld40		; yes -> repeat
  5922                          
  5923  fb5c a000               	ldy #0
  5924  fb5e a6a4               	ldx r2d2		; save JiffyDOS flag
  5925  fb60 a5a5               	lda bsour1
  5926  fb62 2c5b03             	bit verck		; performing verify?
  5927  fb65 1008               	bpl ld50		; no...load
  5928                          
  5929  fb67 d194               	cmp (eal),y		; compare OK?
  5930  fb69 f006               	beq ld55		; yes, -> continue
  5931  fb6b 2085f7             	jsr SetStatusBit4	; error
  5932  fb6e 2c                 	!byte $2C		; skip next store
  5933                          
  5934  fb6f 9194               ld50:	sta (eal),y		; store in memory
  5935                          
  5936  fb71 86a4               ld55:	stx r2d2		; restore JiffyDOS flag
  5937                          } else{
  5938                          	jsr loding		; tell user loading
  5939                          
  5940                          ld40:	lda #$fd		; mask off timeout
  5941                          	and status
  5942                          	sta status
  5943                          
  5944                          	jsr stop		; stop key?
  5945                          	bne ld45		; no...
  5946                          
  5947                          	jsr RestoreBank
  5948                          	jmp break		; stop key pressed
  5949                          
  5950                          ld45:	jsr acptr		; get byte off iec
  5951                          	tax
  5952                          	lda status		; was there a timeout?
  5953                          	lsr
  5954                          	lsr
  5955                          	bcs ld40		; yes...try again
  5956                          	txa
  5957                          	ldy #0
  5958                          	bit verck		; performing verify?
  5959                          	bpl ld50		; no...load
  5960                          	sta sal			; use as a temp
  5961                          	lda (eal),y
  5962                          	cmp sal
  5963                          	beq ld60		; okay
  5964                          	lda #sperr		; no good...verify error
  5965                          	jsr udst		; update status
  5966                          	!byte $ad		; skip next store
  5967                          
  5968                          ld50:	sta (eal),y
  5969                          }
  5970  fb73 e694               ld60:	inc eal			; increment store addr
  5971  fb75 d002               	bne ld64
  5972  fb77 e695               	inc eah
  5973  fb79 249b               ld64:	bit status		; eoi?
  5974  fb7b 50c7               	bvc ld40		; no...continue load
  5975                          
  5976  fb7d 2064fc             	jsr RestoreBank		; switch to old RAM0 bank
  5977                          !if JIFFY = 1{			; ##### JIFFY #####
  5978                          ; close file and exit
  5979                          jdCloseFile:
  5980                          }
  5981  fb80 20abff             	jsr untlk		; close channel
  5982  fb83 202cfc             	jsr clsei		; close the file
  5983                          ; exit iec load
  5984  fb86 18                 	clc			; good exit
  5985  fb87 ad6003             	lda relsab		; set up end load address
  5986  fb8a a694               	ldx eal
  5987  fb8c a495               	ldy eah
  5988  fb8e 60                 ld190:	rts
  5989                          
  5990                          ; subroutine to print to console: searching [for name]
  5991  fb8f 2c5d03             luking:	bit msgflg		; supposed to print?
  5992  fb92 101e               	bpl ld115
  5993  fb94 a00c               	ldy #ms5-ms1		; "searching"
  5994  fb96 20dbf3             	jsr spmsg
  5995  fb99 a59c               	lda fnlen
  5996  fb9b f015               	beq ld115
  5997  fb9d a017               	ldy #ms6-ms1		; "for"
  5998  fb9f 20dbf3             	jsr spmsg
  5999                          
  6000                          ; subroutine to output file name
  6001  fba2 a49c               outfn:	ldy fnlen		; is there a name?
  6002  fba4 f00c               	beq ld115		; no...done
  6003  fba6 a000               	ldy #0
  6004  fba8 b190               ld110:	lda (fnadr),y
  6005  fbaa 20d2ff             	jsr bsout
  6006  fbad c8                 	iny
  6007  fbae c49c               	cpy fnlen
  6008  fbb0 d0f6               	bne ld110
  6009  fbb2 60                 ld115:	rts
  6010                          
  6011                          ; subroutine to print: loading/verifing
  6012  fbb3 a01b               loding:	ldy #ms10-ms1		; assume 'loading'
  6013  fbb5 ad5b03             	lda verck		; check flag
  6014  fbb8 1002               	bpl ld410		; are doing load
  6015  fbba a02b               	ldy #ms21-ms1		; are 'verifying'
  6016  fbbc 4cdbf3             ld410:	jmp spmsg
  6017                          
  6018                          ; rsr  fix segmentation 10/15/81
  6019                          ; rsr  6509 changes  10/15/81
  6020                          ; -------------------------------------------------------------------------------------------------
  6021                          ; ##### save #####
  6022                          ;***************************************
  6023                          ;* nsave              10/30/81         *
  6024                          ;*                                     *
  6025                          ;* saves to iec devices 4>=n>=31 as    *
  6026                          ;* selected by variable fa.            *
  6027                          ;*                                     *
  6028                          ;* .a = RAM0 bank                      *
  6029                          ;* .x => zpage address of start vector *
  6030                          ;* .y => zpage address of end vector   *
  6031                          ;***************************************
  6032  fbbf 8d6003             nsave:	sta relsab		; bank
  6033  fbc2 b500               	lda zp,x		; get start vector
  6034  fbc4 8596               	sta stal
  6035  fbc6 b501               	lda zp+1,x
  6036  fbc8 8597               	sta stah
  6037  fbca 98                 	tya
  6038  fbcb aa                 	tax
  6039  fbcc b500               	lda zp,x		; get end vector
  6040  fbce 8594               	sta eal
  6041  fbd0 b501               	lda zp+1,x
  6042  fbd2 8595               	sta eah
  6043                          
  6044  fbd4 a59e               	lda fa 			; check device number
  6045  fbd6 c904               	cmp #4
  6046  fbd8 b003               	bcs sv20
  6047                          
  6048  fbda 4c88fc             	jmp error9		; bad device #
  6049                          
  6050  fbdd a961               sv20:	lda #$61		; special save command
  6051  fbdf 859f               	sta sa
  6052  fbe1 a49c               	ldy fnlen
  6053  fbe3 d003               	bne sv25
  6054                          
  6055  fbe5 4c85fc             	jmp error8		; missing file name
  6056                          
  6057  fbe8 209bfa             sv25:	jsr openi
  6058  fbeb 2043fc             	jsr saving
  6059  fbee a59e               	lda fa
  6060  fbf0 20b1ff             	jsr listn
  6061  fbf3 a59f               	lda sa
  6062  fbf5 2093ff             	jsr secnd
  6063                          
  6064  fbf8 2050fc             	jsr SwitchBank		; switch to new bank
  6065                          
  6066  fbfb 2051ff             	jsr rd300
  6067  fbfe a592               	lda sal
  6068  fc00 20a8ff             	jsr ciout
  6069  fc03 a593               	lda sah
  6070  fc05 20a8ff             	jsr ciout
  6071                          
  6072  fc08 a000               	ldy #0
  6073  fc0a 205aff             sv30:	jsr cmpste		; compare start to end
  6074  fc0d b017               	bcs sv50		; have reached end
  6075  fc0f b192               	lda (sal),y
  6076  fc11 20a8ff             	jsr ciout
  6077  fc14 2064ff             	jsr incsal
  6078  fc17 20e1ff             	jsr stop
  6079  fc1a d0ee               	bne sv30
  6080                          
  6081  fc1c 2064fc             	jsr RestoreBank		; switch to old RAM0 bank
  6082  fc1f 202cfc             break:	jsr clsei
  6083  fc22 a900               	lda #0
  6084  fc24 38                 	sec
  6085  fc25 60                 	rts
  6086                          
  6087  fc26 2064fc             sv50:	jsr RestoreBank		; switch to old RAM0 bank
  6088  fc29 20aeff             	jsr unlsn
  6089                          
  6090  fc2c 249f               clsei:	bit sa
  6091  fc2e 3011               	bmi clsei2
  6092  fc30 a59e               	lda fa
  6093  fc32 20b1ff             	jsr listn
  6094  fc35 a59f               	lda sa
  6095  fc37 29ef               	and #$ef
  6096  fc39 09e0               	ora #$e0
  6097  fc3b 2093ff             	jsr secnd
  6098  fc3e 20aeff             	jsr unlsn
  6099                          
  6100                          clsei2:
  6101  fc41 18                 sv110:	clc
  6102  fc42 60                 sv115:	rts
  6103                          
  6104                          ; subroutine to output: 'saving <file name>'
  6105  fc43 ad5d03             saving:	lda msgflg
  6106  fc46 10fa               	bpl sv115		; no print
  6107                          
  6108  fc48 a023               	ldy #ms11-ms1		; 'saving'
  6109  fc4a 20dbf3             	jsr spmsg
  6110  fc4d 4ca2fb             	jmp outfn		; <file name>
  6111                          ; -------------------------------------------------------------------------------------------------
  6112                          ; switch to new RAM0 bank
  6113                          SwitchBank:
  6114  fc50 ad40de             	lda via2+prb		; get MMU reg
  6115  fc53 290f               	and #%00001111		; isolate RAM0 bank
  6116  fc55 8d9603             	sta temp		; and remember
  6117  fc58 a9f0               	lda #%11110000		; clear RAM0 bank
  6118  fc5a 2d40de             	and via2+prb
  6119  fc5d 0d6003             	ora relsab		; set RAM0 bank
  6120  fc60 8d40de             	sta via2+prb
  6121  fc63 60                 	rts
  6122                          ; -------------------------------------------------------------------------------------------------
  6123                          ; Restore RAM0 Bank
  6124                          RestoreBank:
  6125  fc64 a9f0               	lda #%11110000		; clear RAM0 bank
  6126  fc66 2d40de             	and via2+prb
  6127  fc69 0d9603             	ora temp
  6128  fc6c 8d40de             	sta via2+prb		; restore old RAM bank
  6129  fc6f 60                 	rts
  6130                          ; -------------------------------------------------------------------------------------------------
  6131                          ; ##### errorhandler #####
  6132                          ;************************************
  6133                          ;* error handler                    *
  6134                          ;*  restores i/o channels to default*
  6135                          ;*  prints kernal error message if  *
  6136                          ;*  bit 6 of msgflg set.  returns   *
  6137                          ;*  with error # in .a and carry.   *
  6138                          ;************************************
  6139  fc70 a901               error1:	lda #1			; too many files
  6140  fc72 2c                 	!byte $2c
  6141  fc73 a902               error2:	lda #2			; file open
  6142  fc75 2c                 	!byte $2c
  6143  fc76 a903               error3:	lda #3			; file not open
  6144  fc78 2c                 	!byte $2c
  6145  fc79 a904               error4:	lda #4			; file not found
  6146  fc7b 2c                 	!byte $2c
  6147  fc7c a905               error5:	lda #5			; device not present
  6148  fc7e 2c                 	!byte $2c
  6149  fc7f a906               error6:	lda #6			; not input file
  6150  fc81 2c                 	!byte $2c
  6151  fc82 a907               error7:	lda #7			; not output file
  6152  fc84 2c                 	!byte $2c
  6153  fc85 a908               error8:	lda #8			; missing file name
  6154  fc87 2c                 	!byte $2c
  6155  fc88 a909               error9:	lda #9			; bad device #
  6156                          
  6157  fc8a 48                 errorx:	pha			; error number on stack
  6158  fc8b 20ccff             	jsr clrch		; restore i/o channels
  6159                          
  6160  fc8e a000               	ldy #ms1-ms1
  6161  fc90 2c5d03             	bit msgflg		; are we printing error?
  6162  fc93 500a               	bvc erexit		; no...
  6163                          
  6164  fc95 20e0f3             	jsr msg			; print "cbm i/o error #"
  6165  fc98 68                 	pla
  6166  fc99 48                 	pha
  6167  fc9a 0930               	ora #$30		; make error # ascii
  6168  fc9c 20d2ff             	jsr bsout		; print it
  6169                          
  6170  fc9f 68                 erexit:	pla
  6171  fca0 38                 	sec
  6172  fca1 60                 	rts
  6173                          ; -------------------------------------------------------------------------------------------------
  6174                          ;***************************************
  6175                          ;* stop -- check stop key flag and     *
  6176                          ;* return z flag set if flag true.     *
  6177                          ;* also closes active channels and     *
  6178                          ;* flushes keyboard queue.             *
  6179                          ;* also returns key downs from last    *
  6180                          ;* keyboard row in .a.                 *
  6181                          ;***************************************
  6182                          ; Check the stop key
  6183  fca2 a5a2               nstop:	lda stkey		; value of last row
  6184  fca4 c97f               	cmp #$7f		; check stop key position
  6185  fca6 d007               	bne stop2		; not down
  6186  fca8 08                 	php
  6187  fca9 20ccff             	jsr clrch		; clear channels
  6188  fcac 85d8               	sta ndx			; flush queue (.a already 0 from clrch)
  6189  fcae 28                 	plp
  6190  fcaf 60                 stop2:	rts
  6191                          ; -------------------------------------------------------------------------------------------------
  6192                          ;***********************************
  6193                          ;*     udtim-- update time.        *
  6194                          ;*     called every 64th second.   *
  6195                          ;*     update the stop key location*
  6196                          ;*     bit0 of stkey=0 for key down*
  6197                          ;***********************************
  6198                          ; interrupts are coming from the 6522 timer
  6199  fcb0 a200               udtim:	ldx #0			; pre-load for later
  6200                          ; here we proceed with an increment of the time register.
  6201  fcb2 e601               	inc tick		; inc 1/64th
  6202  fcb4 a501               	lda tick
  6203  fcb6 c940               	cmp #HZ			; one second full?
  6204  fcb8 d039               	bne ud60		; no
  6205  fcba 8601               	stx tick
  6206  fcbc f8                 	sed			; set decimal mode
  6207  fcbd a59a               	lda time+2
  6208  fcbf 18                 	clc
  6209  fcc0 6901               	adc #1
  6210  fcc2 859a               	sta time+2
  6211  fcc4 c960               	cmp #$60		; next minute?
  6212  fcc6 d02a               	bne ud50		; no
  6213  fcc8 869a               	stx time+2
  6214  fcca a599               	lda time+1
  6215  fccc 18                 	clc
  6216  fccd 6901               	adc #1
  6217  fccf 8599               	sta time+1
  6218  fcd1 c960               	cmp #$60		; next hour?
  6219  fcd3 d01d               	bne ud50		; no
  6220  fcd5 8699               	stx time+1
  6221  fcd7 a598               	lda time
  6222  fcd9 18                 	clc
  6223  fcda 6901               	adc #1
  6224  fcdc 8598               	sta time
  6225  fcde 297f               	and #$7f		; clear pm flag
  6226  fce0 c912               	cmp #$12		; 12 hours full?
  6227  fce2 d00e               	bne ud50		; no
  6228  fce4 a598               	lda time		; get hours again		
  6229  fce6 2980               	and #$80		; clear hours except pm flag
  6230  fce8 4980               	eor #$80		; toggle pm flag
  6231  fcea 8598               	sta time
  6232  fcec 8699               	stx time+1
  6233  fcee 869a               	stx time+2
  6234  fcf0 8601               	stx tick
  6235  fcf2 d8                 ud50:	cld
  6236                          ; set stop key flag here
  6237  fcf3 ad00de             ud60:	lda via1+prb		; wait for it to settle
  6238  fcf6 cd00de             	cmp via1+prb
  6239  fcf9 d0f8               	bne ud60		; still bouncing
  6240  fcfb aa                 	tax			; set flags...
  6241  fcfc 3013               	bmi ud80		; no stop key...exit  stop key=$7f
  6242  fcfe a2bd               	ldx #$ff-$42		; check for a shift key (c64 keyboard)
  6243  fd00 8e0fde             	stx via1+pra
  6244  fd03 ae00de             ud70:	ldx via1+prb		; wait to settle...
  6245  fd06 ec00de             	cpx via1+prb
  6246  fd09 d0f8               	bne ud70
  6247  fd0b 8d0fde             	sta via1+pra		; !!!!!watch out...stop key .a=$7f...same as colms was...
  6248  fd0e e8                 	inx			; any key down aborts
  6249  fd0f d002               	bne ud90		; leave same as before...
  6250  fd11 85a2               ud80:	sta stkey		; save for other routines
  6251  fd13 60                 ud90:	rts
  6252                          ; read time
  6253                          ;  .y = (bit7=pm,bit6/5=t8/t4,bits4-0 hrs)
  6254                          ;  .x = (bit7=t2,bits6-0 minutes)
  6255                          ;  .a = (bit7=t1,bits6-0 seconds)
  6256                          ; last digit is 1/8 seconds because of 1/64 tick
  6257  fd14 78                 rdtim:	sei			; keep time from rolling
  6258  fd15 a501               	lda tick		; get 64th
  6259  fd17 2920               	and #%00100000		; isolate t4 of 64th
  6260  fd19 0598               	ora time
  6261  fd1b a8                 	tay			; hours
  6262  fd1c a501               	lda tick		; get 64th
  6263  fd1e 0a                 	asl			; t2 of 64th to bit#7
  6264  fd1f 0a                 	asl
  6265  fd20 0a                 	asl
  6266  fd21 48                 	pha			; remember
  6267  fd22 2980               	and #$80		; clear except t2
  6268  fd24 0599               	ora time+1
  6269  fd26 aa                 	tax			; minutes
  6270  fd27 68                 	pla			; restore
  6271  fd28 0a                 	asl			; t1 of 64th to bit#7
  6272  fd29 2980               	and #$80		; clear except t1
  6273  fd2b 059a               	ora time+2		; seconds
  6274  fd2d 58                 	cli
  6275  fd2e 60                 	rts
  6276                          ; set time
  6277  fd2f 78                 settim:	sei			; keep time from changing
  6278  fd30 48                 	pha			; remember seconds
  6279  fd31 297f               	and #$7f		; clear 8th bit#7
  6280  fd33 859a               	sta time+2		; store seconds
  6281  fd35 68                 	pla
  6282  fd36 2980               	and #$80		; isolate t1
  6283  fd38 8501               	sta tick		; store	64th
  6284  fd3a 8a                 	txa
  6285  fd3b 297f               	and #$7f		; clear 8th bit#7
  6286  fd3d 8599               	sta time+1		; store minutes
  6287  fd3f 8a                 	txa
  6288  fd40 0a                 	asl			; t2 to carry
  6289  fd41 a501               	lda tick
  6290  fd43 6a                 	ror			; shift t2 to 64th 
  6291  fd44 4a                 	lsr			; 1/8 to correct position bit#3+4
  6292  fd45 4a                 	lsr
  6293  fd46 4a                 	lsr
  6294  fd47 8501               	sta tick
  6295  fd49 98                 	tya
  6296  fd4a 299f               	and #%10011111		; clear 8th bit#5+6
  6297  fd4c 8598               	sta time		; store hours incl. pm flag
  6298  fd4e 98                 	tya
  6299  fd4f 2920               	and #%00100000		; isolate t4
  6300  fd51 0501               	ora tick
  6301  fd53 8501               	sta tick
  6302  fd55 58                 	cli
  6303  fd56 60                 	rts
  6304                          ; rsr 8/21/80 remove crfac change stop
  6305                          ; rsr 3/29/82 add shit key check for commodore 64
  6306                          ; -------------------------------------------------------------------------------------------------
  6307                          ; ##### init #####
  6308                          ;------------------------------------------------
  6309                          ; start - system reset routine
  6310                          ;  kernal checks only at $8000 for ROM
  6311                          ;    if no occurance then $e000 is used for vector
  6312                          ;    $e000 => monitor start
  6313                          ;  kernal expects:
  6314                          ;    $x000 - jmp init  (cold start)
  6315                          ;    $x003 - jmp winit (warm start)
  6316                          ;    $x006 - 'c'(+$80)=> kernal cold start first
  6317                          ;    $x007 - 'b'+$80
  6318                          ;    $x008 - 'm'+$80
  6319                          ;    $x009 - 'x'  x=4k bank (1-8)
  6320                          ;------------------------------------------------
  6321                          ; test bytes for ROMs
  6322  fd57 c2cd               patall: !byte $c2,$cd		; $x004 rom pattern
  6323                          ; reset entry
  6324  fd59 a2fe               start:	ldx #$fe		; init stack
  6325  fd5b 78                 	sei
  6326  fd5c 9a                 	txs
  6327  fd5d d8                 	cld
  6328                          ; check for warm start
  6329  fd5e a9a5               	lda #warm
  6330  fd60 cdfa03             	cmp evect+2		; check warm flag ?
  6331  fd63 d007               	bne scold		; no -> cold start
  6332  fd65 adfb03             	lda evect+3
  6333  fd68 c95a               	cmp #winit		; check winit ?
  6334  fd6a f04b               	beq swarm		; yes -> warm start
  6335                          ; cold start
  6336  fd6c a906               scold:	lda #6			; set up indirect to $0006 = position ROM ident bytes
  6337  fd6e 8594               	sta eal
  6338  fd70 a970               	lda #$70		; start at $8000 ($10 added below)
  6339  fd72 8595               	sta eah
  6340  fd74 a900               	lda #0
  6341  fd76 8df803             	sta evect		; set low byte of vector warm start to $00
  6342  fd79 a237               	ldx #$37		; existance flag 4. rom ident byte compare value to '0'
  6343  fd7b a003               sloop0: ldy #3			; set counter to 4th ROM ident byte
  6344  fd7d a595               	lda eah
  6345  fd7f c9c0               	cmp #$c0		; last allowed rom position reached?
  6346  fd81 f018               	beq sloop2		; no roms but this one... -> monitor cold boot
  6347  fd83 18                 	clc			; calc new test point
  6348  fd84 6910               	adc #$10                ; 4k steps
  6349  fd86 8595               	sta eah
  6350  fd88 e8                 	inx			; next 4. byte compare value $31, $32, $33...
  6351  fd89 8a                 	txa
  6352  fd8a d194               	cmp (eal),y		; compare if 4. byte $31 at address $1006+3, $32 at $2006...
  6353  fd8c d0ed               	bne sloop0		; 4. byte does not mach - > next ROM pos. $2000, $3000...
  6354  fd8e 88                 	dey			; check next byte backwards if 4th byte matches
  6355  fd8f b194               sloop1: lda (eal),y		; load 3., 2., 1. byte
  6356  fd91 88                 	dey
  6357  fd92 300a               	bmi sloop3		; all done...correctly - 2.+3. byte matches -> autostart ROM found!
  6358  fd94 d957fd             	cmp patall,y		; compare test bytes 'M', 'B'
  6359  fd97 f0f6               	beq sloop1		; 3. byte OK -> check 2. byte
  6360  fd99 d0e0               	bne sloop0		; no good... 2. or 3. ident byte does not mach
  6361                          
  6362                          ; monitor (could be test for keydown ***)
  6363  fd9b a0e0               sloop2: ldy #$e0                ; monitor vector
  6364  fd9d 2c                 	!byte $2c		; skip two bytes
  6365  fd9e a495               sloop3: ldy eah
  6366  fda0 8cf903             	sty evect+1             ; set high byte of vector
  6367                          
  6368  fda3 aa                 	tax                     ; move 1. ident byte to x to set N-flag
  6369  fda4 1011               	bpl swarm               ; don't use kernal initilization
  6370                          				;   jump to warm start if value is positive ('c'=$43)
  6371                          
  6372                          ; kernal cold start
  6373  fda6 20bafd             	jsr ioinit              ; initilize i/o, MMU -> (VIA1, VIA2)
  6374  fda9 2005fe             	jsr ramtas              ; ram-test and set
  6375  fdac 20d4fe             	jsr restor              ; operationg system vectors (copies $0300 Vector Table)
  6376  fdaf 2004e0             	jsr jcint               ; screen editor init -> cint (editor, VDP)
  6377  fdb2 a9a5               	lda #warm		; Kernal initilize done flag
  6378  fdb4 8dfa03             	sta evect+2             ; save first warm start flag $A5
  6379                          ; warm start entry
  6380  fdb7 6cf803             swarm:  jmp (evect)             ; start exit -> basic warm start
  6381                          ; -------------------------------------------------------------------------------------------------
  6382                          ; ioinit - initilize i/o system, MMU
  6383                          ;   must be entered with irq's disabled
  6384                          ;------------------------------------------
  6385                          ; 6522 VIA1, VIA2 initilization code
  6386  fdba a97f               ioinit: lda #$7f		; kill interrupts
  6387  fdbc 8d0ede             	sta via1+ier
  6388  fdbf 8d4ede             	sta via2+ier
  6389                          ; timers, aux lines
  6390  fdc2 a940               	lda  #%01000000         ; via1+2: free running t1, t2 oneshot
  6391  fdc4 8d0bde             	sta  via1+acr		;   via1 t1 = system IRQ (freerun), t2 = IEC (oneshot)
  6392  fdc7 8d4bde             	sta  via2+acr
  6393  fdca a976               	lda  #%01110110         ; via1: ca2+cb2 independent input mode,ca1 neg,cb1 pos
  6394  fdcc 8d0cde             	sta  via1+pcr
  6395  fdcf a9fe               	lda  #%11111110         ; via2: ca2 high, cb2 high, ca1 neg,cb1 pos
  6396  fdd1 8d4cde             	sta  via2+pcr		;   MMU: ca2+cb2 = ROM enabled, ca1 = restore key
  6397                          ; configure ports	
  6398  fdd4 a2ff               	ldx #$ff
  6399  fdd6 8e0fde             	stx via1+pra		; keyboard out 0-7=1
  6400  fdd9 8e03de             	stx via1+ddra		; keyboard cols are outputs
  6401  fddc e8                 	inx			; $00
  6402  fddd 8e02de             	stx via1+ddrb		; keyboard rows are inputs
  6403  fde0 8e4fde             	stx via2+pra		; set IEC, MMU, Busy (6309)
  6404  fde3 a938               	lda #%00111000		; set ddr IEC in/out, Busy in, USB RXF+TXF in
  6405  fde5 8d43de             	sta via2+ddra
  6406                          !if V11PCB128K = 1{
  6407                          	ldx #%10000000		; PCB v.1.1 with 128KB RAM1 chip
  6408                          }
  6409  fde8 8e40de             	stx via2+prb		; set MMU RAM0+1 = bank 0
  6410                          !if V10PCB = 1{
  6411                          	ldx #%00001111		; PCB v.1.0: only 2x2 bit RAM banks (max. 128kB chips)
  6412                          } else{
  6413  fdeb a2ff               	ldx #%11111111		; >= PCB v.1.1: .x=$ff
  6414                          }
  6415  fded 8e42de             	stx via2+ddrb		; set ddr MMU RAM bank = output
  6416                          ; restore key NMI
  6417  fdf0 a982               	lda  #$82		; enable panic button
  6418  fdf2 8d4ede             	sta  via2+ier
  6419                          ; start timer
  6420  fdf5 a9c0               	lda  #$c0		; enable t1 interrupts
  6421  fdf7 8d0ede             	sta  via1+ier
  6422  fdfa a924               	lda  #<sixty		; ...at 64 hz rate
  6423  fdfc 8d04de             	sta  via1+t1lo
  6424  fdff a9f4               	lda  #>sixty
  6425  fe01 8d05de             	sta  via1+t1hi
  6426  fe04 60                 	rts
  6427                          
  6428                          sixty    =  1000000*CLOCK/HZ	; sixty hertz value (64 Hz, because 16bit is max for 4 MHz clock)
  6429                          ; -------------------------------------------------------------------------------------------------
  6430                          ; ramtas - initilize lower ram with $00 and test all system ram
  6431                          ;   set ram limits
  6432                          ;   alocatate initial buffer space
  6433                          ;-----------------------------------------
  6434                          ; RAM-test / vector init
  6435  fe05 a900               ramtas: lda #0			; init value a = $00, counter x = 0
  6436  fe07 aa                 	tax
  6437  fe08 9500               px1:    sta zp,x		; clear ZP
  6438  fe0a 9d0002             	sta buf,x		; clear basic input buffer from $0200       
  6439  fe0d 9df802             	sta evect-$100,x	; clear kernal RAM till evct $03f8
  6440  fe10 e8                 	inx
  6441  fe11 d0f5               	bne px1			; clear next byte
  6442                          
  6443                          ; memory size check
  6444  fe13 a8                 	tay			; move 0 to y
  6445  fe14 a904               	lda #$04		; memory start page
  6446  fe16 8d5703             	sta memstr+1		; set bottom of user memory
  6447  fe19 8d5303             	sta lowadr+1		; ...and system memory
  6448  fe1c 8593               	sta sah			; set high inital index
  6449                          ; memsiz,sal,lowadr are zeroed above
  6450  fe1e b192               siz100: lda (sal),y
  6451  fe20 aa                 	tax			; save memory value in x 
  6452  fe21 a955               	lda #$55		; test with $55
  6453  fe23 9192               	sta (sal),y
  6454  fe25 b192               	lda (sal),y
  6455  fe27 c955               	cmp #$55		; check if $55 
  6456  fe29 d011               	bne size		; end test if different
  6457  fe2b 0a                 	asl			; test with $aa
  6458  fe2c 9192               	sta (sal),y
  6459  fe2e d192               	cmp (sal),y		; check if $aa
  6460  fe30 d00a               	bne size		; end test if different
  6461  fe32 8a                 	txa
  6462  fe33 9192               	sta (sal),y		; restore old memory value from x
  6463  fe35 c8                 	iny
  6464  fe36 d0e6               	bne siz100		; test next byte
  6465  fe38 e693               	inc sah
  6466  fe3a d0e2               	bne siz100		; test next page
  6467                          ; set top of memory
  6468                          ;   sah,y = first bad RAM byte
  6469  fe3c 98                 size:   tya			; low to x
  6470  fe3d aa                 	tax
  6471  fe3e a493               	ldy sah			; high in y
  6472  fe40 ca                 	dex			; 1 byte down
  6473  fe41 e0ff               	cpx #$ff		; crossed page?
  6474  fe43 d001               	bne siz110		; no...skip
  6475  fe45 88                 	dey			; dec hi
  6476  fe46 8e5403             siz110:	stx hiadr
  6477  fe49 8c5503             	sty hiadr+1
  6478                          ; reserve 2 pages (512by) for sprite colors	
  6479  fe4c 88                 	dey
  6480  fe4d 88                 	dey
  6481                          ; allocate 1 page (256funcs)
  6482  fe4e 88                 	dey
  6483  fe4f 18                 	clc
  6484  fe50 20b6fe             	jsr memtop              ; set user top of memory
  6485  fe53 60                 	rts
  6486                          ; -------------------------------------------------------------------------------------------------
  6487                          ; standard vector table - initialized at boot from restor sub to cinv $0300
  6488                          jmptab:
  6489  fe54 13ff               	!word yirq		; cinv	
  6490  fe56 21ef               	!word timb		; cbinv....brk goes to monitor
  6491  fe58 22ff               	!word panic		; no.....nminv !!!!!
  6492  fe5a 53fa               	!word nopen		; open file
  6493  fe5c 85f9               	!word nclose		; close file
  6494  fe5e f3f8               	!word nchkin		; open channel in
  6495  fe60 41f9               	!word nckout		; open channel out
  6496  fe62 3afa               	!word nclrch		; close channel
  6497  fe64 85f8               	!word nbasin		; input from channel
  6498  fe66 ccf8               	!word nbsout		; output to channel
  6499  fe68 a2fc               	!word nstop		; scan stop key
  6500  fe6a 70f8               	!word ngetin		; scan keyboard
  6501  fe6c 13fa               	!word nclall		; close all files
  6502  fe6e d9fa               	!word nload		; load from file
  6503  fe70 bffb               	!word nsave		; save to file
  6504  fe72 78ef               	!word s0		; monitor command parser
  6505  fe74 1fe0               	!word jescrt		; esc key vector
  6506  fe76 1fe0               	!word jescrt		; user ctrl key vector
  6507  fe78 d8f4               	!word nsecnd		; IEC listen secondary address
  6508  fe7a e6f4               	!word ntksa		; IEC talk secondary address
  6509  fe7c 32f5               	!word nacptr		; IEC character in
  6510  fe7e fcf4               	!word nciout		; IEC character out
  6511  fe80 0ef5               	!word nuntlk		; IEC untalk bus
  6512  fe82 1df5               	!word nunlsn		; IEC unlisten bus
  6513  fe84 f2f3               	!word nlistn		; IEC listen a device
  6514  fe86 eff3               	!word ntalk		; IEC talk to a device
  6515                          tabend:
  6516                          ; -------------------------------------------------------------------------------------------------
  6517                          ; FB3D NMI entry, jumps indirect to NMI routine
  6518  fe88 6c0403             nmi:    jmp (nminv)             ; ($0304) default -> panic
  6519                          ; -------------------------------------------------------------------------------------------------
  6520                          ; Set file name address
  6521                          ; .a = filename length
  6522                          ; .x = zero page location of 3 byte address
  6523  fe8b 859c               setnam: sta fnlen		; store length
  6524  fe8d b500               	lda zp,x		; load and store address
  6525  fe8f 8590               	sta fnadr
  6526  fe91 b501               	lda zp+1,x
  6527  fe93 8591               	sta fnadr+1
  6528  fe95 b502               	lda zp+2,x
  6529  fe97 8592               	sta fnadr+2
  6530  fe99 60                 	rts
  6531                          ; -------------------------------------------------------------------------------------------------
  6532                          ; Set file paramaters
  6533                          ; .a = logical address
  6534                          ; .x = first address
  6535                          ; .y = secundary address
  6536  fe9a 859d               setlfs: sta la
  6537  fe9c 869e               	stx fa
  6538  fe9e 849f               	sty sa
  6539  fea0 60                 	rts
  6540                          ; -------------------------------------------------------------------------------------------------
  6541                          ; Read/write status
  6542                          ; carry set -- read device status into .a
  6543  fea1 900c               readst: bcc storst
  6544  fea3 b003               	bcs readss
  6545                          ; Set the system message flag
  6546  fea5 8d5d03             setmsg: sta msgflg
  6547  fea8 a59b               readss: lda status		; read status
  6548                          ; set status bit
  6549  feaa 059b               udst:   ora status		; set bit and store status
  6550  feac 859b               	sta status
  6551  feae 60                 	rts
  6552                          ; carry clear -- set device status with .a
  6553  feaf 859b               storst: sta status		; store status
  6554  feb1 60                 	rts
  6555                          ; -------------------------------------------------------------------------------------------------
  6556                          ; IEC timeout on/off
  6557  feb2 8d5a03             settmo: sta timout
  6558  feb5 60                 	rts
  6559                          ; -------------------------------------------------------------------------------------------------
  6560                          ; Read/set top of memory
  6561  feb6 9006               memtop: bcc settop
  6562                          
  6563                          ; carry set--read top of memory
  6564  feb8 ae5803             	ldx memsiz		; load user memory top in .x.y
  6565  febb ac5903             	ldy memsiz+1
  6566                          
  6567                          ; carry clear--set top of memory
  6568  febe 8e5803             settop: stx memsiz		; set user memory top
  6569  fec1 8c5903             	sty memsiz+1
  6570  fec4 60                 	rts
  6571                          ; -------------------------------------------------------------------------------------------------
  6572                          ; Manage bottom of memory
  6573  fec5 9006               membot: bcc setbot
  6574                          
  6575                          ; carry set--read bottom of memory
  6576  fec7 ae5603             	ldx memstr		; load bottom mem in .x.y
  6577  feca ac5703             	ldy memstr+1
  6578                          
  6579                          ; carry clear--set bottom of memory
  6580  fecd 8e5603             setbot: stx memstr		; set bottom mem
  6581  fed0 8c5703             	sty memstr+1
  6582  fed3 60                 	rts
  6583                          ; -------------------------------------------------------------------------------------------------
  6584                          ; Restore ram i/o vectors at $0300
  6585  fed4 a254               restor: ldx #<jmptab		; load vector table address in kernal
  6586  fed6 a0fe               	ldy #>jmptab
  6587  fed8 18                 	clc
  6588                          
  6589                          ; Manage ram i/o vectors
  6590  fed9 8692               vector: stx sal			; store address
  6591  fedb 8493               	sty sah
  6592  fedd 900a               	bcc vect50		; carry=0 -> set/restore table
  6593                          
  6594                          ; carry set--read vectors
  6595  fedf a033               	ldy #tabend-jmptab-1
  6596  fee1 b90003             vect20: lda cinv,y		; from ram table $F0300
  6597  fee4 9192               	sta (sal),y		; into user area
  6598  fee6 88                 	dey
  6599  fee7 10f8               	bpl vect20
  6600                          
  6601                          ; carry clear--set vectors
  6602  fee9 a033               vect50: ldy #tabend-jmptab-1
  6603  feeb b192               vect60: lda (sal),y		; from user area
  6604  feed 990003             	sta cinv,y		; into ram table $0300
  6605  fef0 88                 	dey
  6606  fef1 10f8               	bpl vect60
  6607                          
  6608  fef3 60                 	rts
  6609                          ; -------------------------------------------------------------------------------------------------
  6610                          ; vreset - reset vector flags and control
  6611                          ;   .x - low vector address  .y - high vector address
  6612  fef4 8ef803             vreset: stx evect
  6613  fef7 8cf903             	sty evect+1
  6614  fefa a95a               	lda #winit
  6615  fefc 8dfb03             	sta evect+3
  6616  feff 60                 	rts
  6617                          ; -------------------------------------------------------------------------------------------------
  6618                          ; ##### irq #####
  6619                          ;**********************************************
  6620                          ;* nirq - handler for:       10/30/81 rsr     *
  6621                          ;* 6522 irq's                                 *
  6622                          ;*   (timera, timerb)                         *
  6623                          ;* keyboard scan (50/60hz irq)                *
  6624                          ;**********************************************
  6625                          ; IRQ handler
  6626  ff00 48                 nirq:	pha			; save registers
  6627  ff01 8a                 	txa
  6628  ff02 48                 	pha
  6629  ff03 98                 	tya
  6630  ff04 48                 	pha
  6631  ff05 ba                 	tsx			; check for brk...
  6632  ff06 bd0401             	lda stack+4,x		; get old p status
  6633  ff09 2910               	and #$10		; break flag?
  6634  ff0b d003               	bne brkirq		; yes...
  6635  ff0d 6c0003             	jmp (cinv)		; via vector -> yirq
  6636  ff10 6c0203             brkirq: jmp (cbinv)		; yes...
  6637                          
  6638                          ; entry via indirect vector cinv
  6639  ff13 201ce9             yirq:   jsr scnkey
  6640  ff16 20b0fc             	jsr udtim		; set stopkey flag
  6641  ff19 2c04de             	bit via1+t1lo		; clear interupt flag
  6642                          
  6643  ff1c 68                 prend:	pla			; restore registers
  6644  ff1d a8                 	tay
  6645  ff1e 68                 	pla
  6646  ff1f aa                 	tax
  6647  ff20 68                 	pla
  6648  ff21 40                 	rti			; exit from irq routines
  6649                          
  6650                          ; Default NMI routine
  6651  ff22 78                 panic:	sei			; no irq's allowed...
  6652  ff23 48                 	pha			; save 6502 regs
  6653  ff24 8a                 	txa
  6654  ff25 48                 	pha
  6655  ff26 98                 	tya
  6656  ff27 48                 	pha
  6657                          !if NMI555 = 0{
  6658  ff28 ad4dde             	lda via2+ifr		; check if real nmi...
  6659  ff2b 1021               	bpl nmirti		; ...no
  6660                          
  6661  ff2d 2d4ede             	and via2+ier		; show only enables
  6662  ff30 aa                 	tax			; save in .x for later
  6663  ff31 2902               	and #$02		; check if restore key...
  6664  ff33 f014               	beq nnmi20		; ...no
  6665  ff35 2c41de             	bit  via2+prah		; clr ca1 flag
  6666                          }
  6667                          ; check for stop key down
  6668  ff38 20f3fc             	jsr  ud60
  6669  ff3b 20e1ff             	jsr  stop
  6670  ff3e d009               	bne  nnmi20		; no stop key
  6671                          ; stop/restore detected
  6672  ff40 20d4fe             	jsr  restor		; restore system indirects
  6673  ff43 20bafd             	jsr  ioinit		; restore i/o for basic
  6674  ff46 6cf803             	jmp  (evect)		; ...no, so basic warm start
  6675                          ; not restore NMI
  6676  ff49 a97f               nnmi20:	lda #$7f		; kill all NMI's
  6677  ff4b 8d4dde             	sta via2+ifr
  6678  ff4e 58                 nmirti:	cli
  6679  ff4f d0cb               	bne prend		; always
  6680                          ; -------------------------------------------------------------------------------------------------
  6681                          ; some needed routines
  6682                          ; sta -> sa
  6683  ff51 a597               rd300:	lda stah
  6684  ff53 8593               	sta sah
  6685  ff55 a596               	lda stal
  6686  ff57 8592               	sta sal
  6687  ff59 60                 	rts
  6688                          ; sa - ea
  6689  ff5a 38                 cmpste: sec
  6690  ff5b a592               	lda sal
  6691  ff5d e594               	sbc eal
  6692  ff5f a593               	lda sah
  6693  ff61 e595               	sbc eah
  6694  ff63 60                 	rts
  6695                          ; increse sal
  6696  ff64 e692               incsal: inc sal
  6697  ff66 d002               	bne incr20
  6698  ff68 e693               	inc sah
  6699                          ffrts:
  6700  ff6a 60                 incr20:	rts
  6701                          ; -------------------------------------------------------------------------------------------------
  6702                          ; ##### vectors #####
  6703                          ; Jump table kernal functions
  6704                          !zone vectors
  6705                          *= $ff6f
  6706                          ; also used in basic! Equal to table at end of Basic 4+
  6707  ff6f 4cf4fe             	jmp vreset		; Power-on/off vector reset
  6708  ff72 4cd4ec             ipcgov:	jmp vmode		; VDP: set mode, backdrop color
  6709  ff75 4c22e0             	jmp jfunky		; Function key vector
  6710  ff78 4c5ced             	jmp vclear		; VDP: clear screen with background color
  6711  ff7b 4cbafd             	jmp ioinit		; I/O initialization
  6712  ff7e 4c04e0             	jmp jcint		; Screen initialization
  6713  ff81 4c45f8             	jmp alocat		; Allocation routine
  6714  ff84 4c8bee             	jmp waitcmd		; VDP: Wait for VDP command
  6715  ff87 4cd4fe             	jmp restor		; restore I/O vectors
  6716  ff8a 4cf4f9             	jmp lkupsa		; Match sa--return sa,fa
  6717  ff8d 4c0cfa             	jmp lkupla		; Match la--return sa,fa
  6718  ff90 4ca5fe             	jmp setmsg		; Control o.s. messages
  6719  ff93 6c2403             secnd:	jmp (isecnd)		; Send sa after listen
  6720  ff96 6c2603             tksa:	jmp (itksa)		; Send sa after talk
  6721  ff99 4cb6fe             	jmp memtop		; set/read top of memory
  6722  ff9c 4cc5fe             	jmp membot		; set/read bottom of memory
  6723  ff9f 4c13e0             	jmp jkey		; Scan keyboard
  6724  ffa2 4cb2fe             	jmp settmo		; set timeout in IEC
  6725  ffa5 6c2803             acptr:	jmp (iacptr)		; Handshake IEC byte in
  6726  ffa8 6c2a03             ciout:	jmp (iciout)		; Handshake IEC byte out
  6727  ffab 6c2c03             untlk:	jmp (iuntlk)		; Send untalk out IEC
  6728  ffae 6c2e03             unlsn:	jmp (iunlsn)		; Send unlisten out IEC
  6729  ffb1 6c3003             listn:	jmp (ilistn)		; Send listen out IEC
  6730  ffb4 6c3203             talk:	jmp (italk)		; Send talk out IEC
  6731  ffb7 4ca1fe             	jmp readst		; read/write I/O status byte
  6732  ffba 4c9afe             	jmp setlfs		; set la, fa, sa
  6733  ffbd 4c8bfe             	jmp setnam		; set length and fn adr
  6734  ffc0 6c0603             open:	jmp (iopen)		; Open logical file/transmit command
  6735  ffc3 6c0803             close:	jmp (iclose)		; Close logical file
  6736  ffc6 6c0a03             chkin:	jmp (ichkin)		; Open channel in
  6737  ffc9 6c0c03             ckout:	jmp (ickout)		; Open channel out
  6738  ffcc 6c0e03             clrch:	jmp (iclrch)		; Close I/O channel
  6739  ffcf 6c1003             basin:	jmp (ibasin)		; Input from channel
  6740  ffd2 6c1203             bsout:	jmp (ibsout)		; Output to channel
  6741  ffd5 6c1a03             load:	jmp (iload)		; Load from file
  6742  ffd8 6c1c03             save:	jmp (isave)		; Save to file
  6743  ffdb 4c2ffd             	jmp settim		; Set internal clock
  6744  ffde 4c14fd             	jmp rdtim		; read internal clock
  6745  ffe1 6c1403             stop: 	jmp (istop)		; scan stop key
  6746  ffe4 6c1603             getin:	jmp (igetin)		; Get char from q
  6747  ffe7 6c1803             clall:	jmp (iclall)		; Close all files
  6748  ffea 4cb0fc             	jmp udtim		; increment clock
  6749  ffed 4c10e0             	jmp jscror		; Screen org
  6750  fff0 4c19e0             	jmp jplot		; read/set x,y coord
  6751  fff3 4cd4c6             	jmp bdoscmd		; BASIC DOS command
  6752                          
  6753                          *= $fffa
  6754                          ; -------------------------------------------------------------------------------------------------
  6755                          ; Hardware vectors
  6756                          !zone hardvectors
  6757  fffa 88fe               hwnmi:  !word nmi		; Program defineable
  6758  fffc 59fd               	!word start		; Initialization code
  6759  fffe 00ff               	!word nirq		; Interrupt handler
