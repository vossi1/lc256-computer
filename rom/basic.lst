
; ******** Source: lc256_basic4.b
     1                          ; Commodore CBM2 Basic 4 plus
     2                          ; ported to LC256 by Vossi 09/2024, last update 10/2024
     3                          !cpu 65c02
     4                          !ct pet		; Standard text/char conversion table -> pet = petscii
     5                          !to "basic.bin", plain
     6                          ;
     7                          ; * constants
     8                          FILL	= $ff	; Fills free memory areas
     9                          ; shared VDP sources

; ******** Source: lc256_vdpeq.b
     1                          ; * switches
     2                          CLOCK = 4		; CPU clock in MHz for VDP waits
     3                          ; vdp
     4                          MODE = 7		; 6 = graphics 6: 512px/16colors / 7 = graphics 7: 256px/256colors
     5                          PAL = 0			; PAL=1 / NTSC=0 selects V9938/58 PAL RGB-output, NTSC has a higher picture
     6                          LINES = 212		; lines = 192 / 212
     7                          ; VDP speed parameter - don't change!
     8                          WAIT12 = 1 ; 2		; us 1. - 2. byte VDP
     9                          WAIT23 = 2 ; 5		; us 2. - 3. byte VDP
    10                          WAITVRAM1 = 5		; us vram 1.access
    11                          WAITVRAM = 5		; us vram loop 
    12                          ;
    13                          !if MODE=6{
    14                          TITLECOL		= 1	; Title message color
    15                          TITLE2COL		= 10	; Title message line 2 color
    16                          BYTESCOL		= 6	; Title bytes color
    17                          TEXTCOL			= 3	; Default text color:   0=black, 1=white, 10=lightred, 6=blue, 3=cyan
    18                          BGRCOL			= 0	; background color
    19                          EXTCOL			= 0	; exterior color
    20                          }else {
    21                          TITLECOL		= $ff	; Title message color
    22                          TITLE2COL		= $3e	; Title message line 2 color
    23                          BYTESCOL		= $43	; Title bytes color
    24                          TEXTCOL			= $e7	; Default text color: $00=black, $ff=white, $3e=pink, $22=darkblue, $43=blue, $e7=cyan
    25                          BGRCOL			= $00	; background color
    26                          EXTCOL			= $00	; exterior color
    27                          }
    28                          VDPREG0			= $0a	; VDP reg 0 base value mode 6/7
    29                          VDPREG1			= $02	; VDP reg 1 value mode 6+7 (mode M1+M2, screen disabled, sprites 16x16)
    30                          VDPREG18		= $0d	; VDP reg 18 value (V/H screen adjust, $0d = Sony PVM 9")
    31                          !if LINES=192 {VDPREG9	= $00	; VDP reg 9 value (bit #7 = 192 / 212 lines, bit#1 = NTSC / PAL)
    32                          	}else {VDPREG9	= $80}
    33                          SIZEX6			= 512		; x size mode6
    34                          SIZEX7			= 256		; x size mode7
    35                          SIZEY			= LINES		; y size
    36                          COLORS6			= 16		; mode6 colors
    37                          SPRITES			= 32		; number of sprites
    38                          SPRX			= 16		; sprite x size 
    39                          SPRY			= 16		; sprite y size
    40                          PATTERNS		= 64		; sprite patterns, color patterns
    41                          FONTH			= 8		; userfont height
    42                          FONTW			= 6		; userfont width
    43                          !if LINES=192 {nrows	= 24		; screen rows
    44                          	}else {nrows	= 25}
    45                          COLUMNS7		= 40		; screen columns mode 7
    46                          COLUMNS6		= 80		; screen columns mode 6
    47                          ; vdp commands
    48                          HMMV			= $c0		; highspeed fill
    49                          HMMM			= $d0		; highspeed VRAM copy
    50                          YMMM			= $e0		; highspeed VRAM y copy
    51                          LINE			= $70		; line
    52                          ; ***************************************** ZEROPAGE **********************************************
    53                          ; kernal zero page / equates (outsourced)
    54                          !addr	ddisk		= $b7		; Default disk unit # for monitor/basic
    55                          !addr	color		= $cf		; Character color
    56                          !addr	sedsal		= $c1 ; 2by	; Scroll ptr
    57                          !addr	sedeal		= $c3 ; 2by	; Scroll ptr
    58                          	mxbank	=15+1			; 1st RAM bank out of range
    59                          ;
    60                          ; VDP zero page
    61                          *= $ea
    62                          !addr	mode		*=*+1		; graphics mode: bit#7=1: 7, bit#7=0: 6 (512px/16 colors)
    63                          !addr	lastvbank	*=*+1		; last vram bank
    64                          !addr	columns		*=*+1		; screen columns
    65                          !addr	scxmax		*=*+1		; Max column number
    66                          !addr	bgcolor		*=*+1		; background color
    67                          !addr	bgcolor_left	*=*+1		; background color for left pixel
    68                          !addr	temp1		*=*+1		; temp	
    69                          !addr	temp2		*=*+1		; temp
    70                          !addr	y0		*=*+1		; 8bit y
    71                          !addr	y1		*=*+1		; 8bit y1 (target)
    72                          !addr	cy				; cy (only in circle)
    73                          !addr	temp3		*=*+1		; temp
    74                          !addr	dy				; 8bit dy
    75                          !addr	temp4		*=*+1		; temp for circle, print, spritedata
    76                          ; $f6 16bit
    77                          !addr	zero				; zero value for command macro parameter (lo of sizex = 0)
    78                          !addr	sizex		*=*+2		; 16bit screen size
    79                          !addr	x0		*=*+2		; 16bit x
    80                          !addr	x1		*=*+2		; 16bit x1 (target)
    81                          !addr	tx				; 16bit tx (only in circle)
    82                          !addr	dx		*=*+2		; 16bit dx
    83                          !addr	sprite_colors 	*=*+2		; pointer to $7e00 64x 8by with 16 spriteline color nibbles
    84                          ; sedsal, sedeal only used in function keys, scroll routines
    85                          !addr	source_pointer	= sedsal	; pointer to source
    86                          !addr	pointer1	= sedeal	; pointer
    87                          ; ***************************************** ABSOLUTE **********************************************
    88                          ; VDP sprites
    89                          !addr	sprite_flags	= $0361 ; 32by	; 32x sprite flags EC, CC, IC
    90                          ; VDP absolute
    91                          !addr	bgcolor_del	= $038b		; double background color for vdp commands
    92                          !addr	arg		= $038c		; command arg
    93                          !addr	userfont_adr	= $038d	; 2by	; userfont address
    94                          !addr	wtemp		= $038f	; 2by	; 16bit temp
    95                          ; **************************************** ADDRESSES **********************************************
    96                          ; I/O addresses
    97                          VDPWriteAdr	= $dc00		; Port#0 RamWrite, #1 Control, #2 Palette, #3 Indirect
    98                          VDPReadAdr	= $dc80		; Port#0 RamRead, #1 Status
    99                          ; sprite_colors 200 bytes at $7e00 - $7fff 	64x 8 bytes with 16 spriteline color nibbles
   100                          ; VDP ports
   101                          !addr	VDPRamWrite	= VDPWriteAdr
   102                          !addr	VDPControl	= VDPWriteAdr+1
   103                          !addr	VDPPalette	= VDPWriteAdr+2
   104                          !addr	VDPIndirect	= VDPWriteAdr+3
   105                          !addr	VDPRamRead	= VDPReadAdr
   106                          !addr	VDPStatus	= VDPReadAdr+1
   107                          SpritePatternTable	= $f000
   108                          SpriteAttributeTable	= $fa00
   109                          SpriteColorTable	= SpriteAttributeTable - $200	; always $200 below sprite attribute table
   110                          

; ******** Source: lc256_basic4.b
    10                          

; ******** Source: lc256_vdpmacro.b
     1                          ; ******************************************* MACROS **********************************************
     2                          ; VDP macros
     3                          !macro VdpWait .u, .c{		; *** us wait - cycles already present - for VDP access
     4                          	!set .t = (.u*10-(.c*10/CLOCK))*CLOCK/20
     5                          	!do while .t > 0{
     6                          		nop			; each nop needs 2 cycles
     7                          		!set .t = .t -1}
     8                          }
     9                          !macro VdpSetReg .r{		; *** set VDP Register
    10                          	sta VDPControl			; first writes data in A to control port #1
    11                          	lda #.r | $80			; writes register no. with bit#7 = 1 to Port #1
    12                          	+VdpWait WAIT12,5-1
    13                          	sta VDPControl
    14                          }
    15                          !macro VdpWriteAddress{		; *** set VDP write vram address-pointer to AAXX
    16                          	stx VDPControl
    17                          	ora #$40			; bit#6 = 1 write
    18                          	+VdpWait WAIT12,5-1
    19                          	sta VDPControl
    20                          } 
    21                          			; *** execute VDP Command
    22                          !macro VdpCommand .sx, .sxhi, .sy, .dx, .dxhi, .dy, .nx, .nxhi, .ny, .clr, .arg, .cmr{
    23                          	lda #32				; first command register
    24                          	+VdpSetReg 17			; set register indirect
    25                          ; 32
    26                          	lda .sx
    27                          	+VdpWait WAIT23,6		; wait for DVP
    28                          	sta VDPIndirect
    29                          	lda .sxhi
    30                          	+VdpWait WAIT23,5-1
    31                          	sta VDPIndirect
    32                          	lda .sy
    33                          	+VdpWait WAIT23,6
    34                          	sta VDPIndirect
    35                          	lda #$00
    36                          	+VdpWait WAIT23,5-1
    37                          	sta VDPIndirect
    38                          ; 36
    39                          	lda .dx
    40                          	+VdpWait WAIT23,6
    41                          	sta VDPIndirect
    42                          	lda .dxhi
    43                          	+VdpWait WAIT23,5-1
    44                          	sta VDPIndirect
    45                          	lda .dy
    46                          	+VdpWait WAIT23,6
    47                          	sta VDPIndirect
    48                          	lda #$00
    49                          	+VdpWait WAIT23,5-1
    50                          	sta VDPIndirect
    51                          ; 40
    52                          	lda .nx
    53                          	+VdpWait WAIT23,6
    54                          	sta VDPIndirect
    55                          	lda .nxhi
    56                          	+VdpWait WAIT23,6
    57                          	sta VDPIndirect
    58                          	lda .ny
    59                          	+VdpWait WAIT23,6
    60                          	sta VDPIndirect
    61                          	lda #$00
    62                          	+VdpWait WAIT23,5-1
    63                          	sta VDPIndirect
    64                          ; 44
    65                          	lda .clr
    66                          	+VdpWait WAIT23,6
    67                          	sta VDPIndirect
    68                          	lda .arg
    69                          	+VdpWait WAIT23,6
    70                          	sta VDPIndirect
    71                          	lda #.cmr
    72                          	+VdpWait WAIT23,5-1
    73                          	sta VDPIndirect
    74                          }
    75                          !macro VdpSpriteBank{		; *** Switch to bank $C000-$FFFF for fast sprite access
    76                          	bit lastvbank			; bit#6 -> V, bit#7 -> N
    77                          	bpl .j
    78                          	bvs .k
    79                          .j	lda #SpritePatternTable>>14	; A14+15 = VDP bank
    80                          	+VdpSetReg 14			; writes VRAM bank
    81                          	lda #>SpritePatternTable&$c0	; isolate A14+15
    82                          	sta lastvbank

; ******** Source: lc256_basic4.b
    11                          
    12                          ; ########################################### INFO ################################################
    13                          ; modded by vossi 11/24 for LC256, IEC/Jiffy, RAM0 bank switching 0-15
    14                          ; TI$ with 1/8 seconds as last digit
    15                          ; Workaround for THEN + ELSE:
    16                          ;   Write ':' after each THEN and ELSE !!!
    17                          ; USB receive only with GET# - INPUT# does not work!
    18                          ; **************************************** DISCLAIMER *********************************************
    19                          ; *****************************************
    20                          ; *                                       *
    21                          ; *       commodore pet basic             *
    22                          ; *                                       *
    23                          ; *           version 4.0                 *
    24                          ; *     copyright 1979,  1980,  by        *
    25                          ; *    commodore international limited    *
    26                          ; *                                       *
    27                          ; *****************************************
    28                          ;
    29                          ; version 1 - august 1977
    30                          ; original microsoft release
    31                          ;
    32                          ; version 2 - august 1978
    33                          ; fixed many bugs some are
    34                          ; 1) arrays limited to 255
    35                          ; 2) non-interruptable code
    36                          ; 3) garbage collect strings
    37                          ;
    38                          ; version 3 - may 1979
    39                          ; faster garbage collect
    40                          ;
    41                          ; version 4 - july 1979
    42                          ; 1) expand reserved words
    43                          ; 2) add disk commands
    44                          ; 3) add disk status vars.
    45                          ;
    46                          ; version 4x - may, 1980
    47                          ; 1) separate out kernal
    48                          ; 2) set-up kernal interface
    49                          ; 3) remove all kernal direct cell usage
    50                          ;
    51                          ; version 4.7 - october, 1981
    52                          ; 1) bank related commands
    53                          ; 2) copy literal strings to string space
    54                          ; 3) indirect input buffer
    55                          ; 4) copy fbuffr to strings
    56                          ; 5) chrgot by indirect
    57                          ; 6) print messages direct
    58                          ;
    59                          ;
    60                          ; version 4.73 - november, 1981
    61                          ; *** 64k version ***
    62                          ; 1) floating point move & bank mapping routines
    63                          ; 2) temp string descriptor pointers moved to
    64                          ;    top of "user" memory.
    65                          ; 3) ds$ string area allocated permanently at
    66                          ;    top of "user" memory.
    67                          ; 4) three byte pointers (third byte is bank#)
    68                          ;    for:
    69                          ;     string descriptor pointers(back links too)
    70                          ;     string pointers
    71                          ;     variable pointers
    72                          ;    string descriptor pointers.
    73                          ; 5) user memory copy of "zero" occupies 4 null
    74                          ;    bytes preceding user text area.
    75                          ;
    76                          ;
    77                          ; version 4.74 - december, 1981
    78                          ; 1) user-defined functions: formal param.
    79                          ;    ptr uses 3 bytes
    80                          ; 2) ti$,ti with new kernal interface
    81                          ;
    82                          ; version 4.75 - january 7,1982
    83                          ; 1) extensions for 64k,128k,192k,256k
    84                          ; ****************************************** EQUATES **********************************************
    85                          	false	=0
    86                          	true	=255
    87                          ; assembly constants and parameters
    88                          	cr	=$d			; carriage return
    89                          	lf	=$a			; line feed
    90                          	clrscr	=147			; clear pet screen
    91                          	home	=197			; home pet screen
    92                          	eom	=$80			; indicate end of message
    93                          
    94                          	forsiz	=19
    95                          	numlev	=26			; maximum number of calls to getstk
    96                          	bufsiz	=161
    97                          	addprc	=1
    98                          	addpr2	=addprc+addprc
    99                          	addpr4	=addpr2+addpr2
   100                          	addpr8	=addpr4+addpr4
   101                          	clmwid	=10
   102                          	pi	=$ff
   103                          	strsiz	=4			; # of locs per str descriptor
   104                          	ptrsiz	=3			; # of locs per pointer
   105                          	numtmp	=3			; # of string temporaries
   106                          ; dos interface equates.
   107                          	dosfnl	=16+2			; filename length
   108                          	dosdsk	=8			; disk device #
   109                          	doslfn	=14			; dos internal logical file number
   110                          	dosctl	=21			; dos directory lines before prompt
   111                          	doslst	=dosfnl+dosfnl+dosfnl+16; (dosfnl+2)*3+10 --transmit buffer length
   112                          ; ******************************************** IO *************************************************
   113                          !addr	via2	= $de40		; via2 base
   114                          	prb	= $0		; Port reg b
   115                          !addr	logodata= $c000		; logo data
   116                          ; ****************************************** BDEFINE **********************************************
   117                          ; 'page zero storage definitions'
   118                          *=2
   119                          usrpok	*=*+3			; set up orgin by init
   120                          tmhour	*=*+1			; for ti$ calculations
   121                          tmmin	*=*+1
   122                          tmsec	*=*+1
   123                          tmten	*=*+1
   124                          
   125                          form	*=*+ptrsiz		; format pointer
   126                          
   127                          integr				; one-byte integer from qint
   128                          charac	*=*+1			; a delimiting char
   129                          endchr	*=*+1			; other delimiting char
   130                          count	*=*+1			; general counter
   131                          xcnt	*=*+1			; dos loop counter
   132                          
   133                          ; flags
   134                          ; dimflg, valtyp and intflg must be
   135                          ; consecutive locations.
   136                          dimflg	*=*+1			; in getting a pointer to a variable
   137                          ; it is important to remember whether
   138                          ; it is being done for dim or not.
   139                          valtyp	*=*+1			; the type indicator 0=numeric, 1=string
   140                          intflg	*=*+1			; tells if integer
   141                          
   142                          garbfl				; whether to do garbage collection
   143                          dores	*=*+1			; whether can or can't crunch res'd word.
   144                          ; turned on when data being scanned by
   145                          ; crunch so unquoted strs won't be crunched.
   146                          
   147                          subflg	*=*+1			; flag whether sub'd variable allowed.
   148                          ; for and user-defined function pointer
   149                          ; fetching turn this on before calling
   150                          ; ptrget so arrays won't be detected.
   151                          ; stkini and ptrget clear it.
   152                          ; also disallows integers there.
   153                          
   154                          inpflg	*=*+1			; flags whether we are doing input or read.
   155                          
   156                          dsdesc	*=*+strsiz		; disk status string
   157                          channl	*=*+1			; holds channel number
   158                          poker
   159                          linnum	*=*+2			; location to store line # + ; 16bit return value of getpin
   160                          
   161                          ; pointers to temporary string descriptors.
   162                          temppt	*=*+1			; temppst relative offset to 1st free temp descr
   163                          lastpt	*=*+2			; pointer to last-used str temporary
   164                          tempst	*=*+2			; pointer to storage for 3 temporary descriptors.
   165                          
   166                          index
   167                          index1	*=*+ptrsiz		; direct cells for 1st indexing usage
   168                          index2	*=*+ptrsiz		; direct cells for 2nd indexing usage
   169                          
   170                          ;
   171                          resho	*=*+1			; result of multiplier and divider
   172                          resmoh	*=*+1
   173                          addend				; temp used by umult
   174                          resmo	*=*+1
   175                          reslo	*=*+1
   176                          	*=*+1			; overflow previous cells
   177                          
   178                          ; pointers into dynamic data structures
   179                          ; all are 2-byte offsets into fixed banks
   180                          ; the following always mark the beginning of an area:
   181                          ;    txttab, vartab
   182                          ;    arytab, memtop
   183                          ; these will have unchangeable values in versions
   184                          ; where the areas they mark are equal to the "bottom"
   185                          ; (or "top" for memtop) of a bank.
   186                          ; additional variables:
   187                          ;     txtend, varend, aryend
   188                          ; are used to mark the end of an area, when the start
   189                          ; of the "next" area is in a different bank (i.e.,
   190                          ; the end isn't bordered by another area.)
   191                          
   192                          ; highst is used to store the offset value from a basic
   193                          ; startup call to get the top of memory.
   194                          
   195                          ; the limit of growth in an area must also be kept.
   196                          ; in the different versions, the following are used:
   197                          
   198                          txttab	*=*+2			; pointer to beginning of text and
   199                          ; doesn't change after being setup
   200                          ; by init
   201                          
   202                          txtend	*=*+2			; pointer to end of text (except 64k)
   203                          
   204                          vartab	*=*+2			; pointer to start of simple variable space.
   205                          
   206                          varend	*=*+2			; pointer to end of simple vars (256k only)
   207                          
   208                          arytab	*=*+2			; pointer to start of array table
   209                          
   210                          strend	*=*+2			; end of storage in use.
   211                          
   212                          fretop	*=*+2			; top of str free space
   213                          frespc	*=*+2			; pointer to new str
   214                          memtop	*=*+ptrsiz		; highest location in memory
   215                          
   216                          ; line numbers and textual pointers
   217                          curlin	*=*+2			; current line number
   218                          oldlin	*=*+2			; old line number (setup by stop or
   219                          ; end in a program)
   220                          oldtxt	*=*+ptrsiz		; old text pointer
   221                          
   222                          datlin	*=*+2			; data line number
   223                          datptr	*=*+2			; pointer to data. initialized to point
   224                          ; at the zero infront of (txttab) by
   225                          ; clr command.
   226                          ; updated by execution of a read.
   227                          inpptr	*=*+2			; remembers where input is coming from.
   228                          
   229                          ; stuff used in evaluations
   230                          
   231                          varnam	*=*+2			; variable's name
   232                          
   233                          fdecpt				; pointer into power of tens table.
   234                          varpnt	*=*+ptrsiz		; pointer to variable in memory
   235                          
   236                          forpnt				; a variable's pointer for for loops
   237                          ; and let statements (3 bytes).
   238                          lstpnt	*=*+ptrsiz		; pointer to list string (3 bytes).
   239                          
   240                          vartxt				; save current txtptr on read.
   241                          opptr	*=*+ptrsiz		; pointer to current op's entry in optab.
   242                          
   243                          opmask	*=*+1			; mask created by current operation.
   244                          
   245                          ; temporary floating result registers (5bytes each):
   246                          ; tempf1,tempf2,tempf3
   247                          
   248                          tempf3				; temp float reg
   249                          grbpnt				; pointer used in garbage collection.
   250                          defpnt	*=*+ptrsiz		; pointer used in function definition.
   251                          
   252                          dscpnt	*=*+ptrsiz		; pointer to a string descriptor.
   253                          
   254                          jmper	*=*+2			; three bytes long
   255                          oldov	*=*+1			; the old overflow.
   256                          
   257                          tempf1				; temp float reg
   258                          ptarg1	=tempf1 			; multiply def'd for use by instr$
   259                          ptarg2	=tempf1+3
   260                          str1	=tempf1+6
   261                          str2	=tempf1+10
   262                          tmppos	=tempf1+14
   263                          positn	=tempf1+15
   264                          match	=tempf1+16
   265                          arypnt				; pointer used in array building.
   266                          highds	*=*+ptrsiz		; destination of highest element in blt.
   267                          hightr	*=*+ptrsiz		; source of highest element to move.
   268                          
   269                          tempf2				; temp float reg (5bytes)
   270                          lowds	*=*+1			; location of last byte transfered (3 bytes).
   271                          deccnt	*=*+1			; number of places before decimal point.
   272                          tenexp	*=*+1			; base ten exponent
   273                          
   274                          grbtop				; pointer used in garbage collection.(3 bytes)
   275                          lowtr	*=*+1			; last thing to move in blt (3 bytes).
   276                          dptflg	*=*+1			; has a dpt been input
   277                          expsgn	*=*+1			; sign of exponent
   278                          
   279                          ; the floating accumulator
   280                          dsctmp	*=*+1			; temporary descriptors are built here.
   281                                				; dsctmp overlaps up to facmoh.
   282                          fac	;$6f			; fac#1
   283                          facexp	*=*+1			; exponent
   284                          facho	*=*+1			; most significant byte of mantissa.
   285                          facmoh	*=*+1
   286                          inth				; high byte of word from qint (used by VDP routines)
   287                          indice				; used by qint.
   288                          facmo	*=*+1
   289                          intl				; low byte of word from qint (used by VDP routines)
   290                          faclo	*=*+1
   291                          facsgn	*=*+1			; signum
   292                          degree				; count used by polynomials.
   293                          sgnflg	*=*+1
   294                          bits	*=*+1			; cell for shiftr to use.
   295                          
   296                          ; the floating argument (unpacked)
   297                          t1	=*			; temporaries --uses fp buffer
   298                          t2	=t1+1
   299                          t3	=t1+2
   300                          t4	=t1+3
   301                          
   302                          argexp	*=*+1
   303                          argho	*=*+1
   304                          argmoh	*=*+1
   305                          argmo	*=*+1
   306                          arglo	*=*+1
   307                          argsgn	*=*+1
   308                          strng1
   309                          arisgn	*=*+1			; a sign reflecting the result
   310                          facov	*=*+1			; overflow byte of the fac
   311                          	*=*+1
   312                          
   313                          strng2				; -> to str or desc
   314                          polypt				; -> to polynomial coefficients
   315                          curtol				; absolute linear index is formed here
   316                          fbufpt	*=*+ptrsiz		; -> into fbuffr used by fout
   317                          txtptr	*=*+ptrsiz ;$83		; pointer to current term
   318                          buffpt	*=*+ptrsiz		; ^input buffer
   319                          
   320                          noze				; using's leading zero counter
   321                          parsts	*=*+1			; dos std parser word
   322                          point				; using's pointer to decimal point
   323                          parstx	*=*+1			; dos aux parser word
   324                          
   325                          seedpt	*=*+2
   326                          errnum	*=*+1
   327                          
   328                          ; string area available for copy.  this area is used
   329                          ; by fout as a buffer and must have dosspc contiguous
   330                          ; bytes.
   331                          ; 
   332                          ; in addition this area is used to store temporaries
   333                          ; used by the dos interface routines. note, declaration
   334                          ; order of locations dosofl-dossa must be preserved.
   335                          ; ****************************************** ABSOLUTE *********************************************
   336                          !addr	zp	= $00		; zeropage start
   337                          !addr	stack	= $0100		; Stack
   338                          !addr	memend	= $ffff
   339                          !addr	vecorg	= $ff6f		; kernal jump vector table
   340                          ; Basic's ROM page work area
   341                          * =$200
   342                          fbuffr
   343                          vspbuf				; buffer used to interface with vsp
   344                          	*=*+16			; reserve 16 bytes for filename 1
   345                          dosf1l	*=*+1			; dos file name 1 length
   346                          dosds1	*=*+1			; dos disk drive 1
   347                          dosf1a	*=*+2			; dos file name 1 address
   348                          dosf1b	*=*+1			; dos file name 1 bank
   349                          
   350                          dosf2l	*=*+1			; dos file name 2 length
   351                          dosds2	*=*+1			; dos disk drive 2
   352                          dosf2a	*=*+2			; dos file name 2 address
   353                          dosf2b	*=*+1			; dos file name 2 bank
   354                          
   355                          dosbnk	*=*+1			; dos bank number
   356                          dosofl	*=*+2			; dos low offset  (bsave,bload)
   357                          dosofh	*=*+2			; dos high offset (bsave)
   358                          
   359                          dosla	*=*+1			; dos logical address
   360                          dosfa	*=*+1			; dos physical address
   361                          dossa	*=*+1			; dos secondary address
   362                          dosrcl	*=*+1			; dos record length
   363                          
   364                          dosdid	*=*+2			; dos disk identifier (2 chars)
   365                          didchk	*=*+1			; dos did flag
   366                          
   367                          dosstr	*=*+1			; dos output string buffer
   368                          dosspc=*-fbuffr			; spaced used by dos routines
   369                          
   370                          * =*+46
   371                          trmpos				; cursor column on crt
   372                          andmsk	*=*+1			; mask used by wait
   373                          eormsk	*=*+1			; mask used by wait
   374                          
   375                          dfbank	*=*+1			; default bank number
   376                          dolu  	*=*+1			; default output lu (0=> not std output) keeps ds + dir ok
   377                          
   378                          domask
   379                          tansgn	*=*+1			; used in determining sign of tan
   380                          
   381                          ldaabs	*=*+1			; lda abs routine (see initat)
   382                          tttemp				; temporary store
   383                          ldaadr	*=*+2			; modifiable address
   384                          	*=*+1			; return opcode
   385                          
   386                          ;declarations for print using
   387                          
   388                          hulp	*=*+1			; counter
   389                          bnr	*=*+1			; pointer to begin no
   390                          enr	*=*+1			; pointer to end no
   391                          dolr	*=*+1			; dollar flag
   392                          flag	*=*+1			; comma flag
   393                          swe	*=*+1			; counter
   394                          usgn	*=*+1			; sign exponent
   395                          uexp	*=*+1			; pointer to exponent
   396                          vn	*=*+1			; # digits before decimal point
   397                          chsn	*=*+1			; justify flag
   398                          vf	*=*+1			; # pos before dec point (field)
   399                          nf	*=*+1			; # pos after dec point (field)
   400                          posp	*=*+1			; +/- flag (field)
   401                          fesp	*=*+1			; exponent flag (field)
   402                          etof	*=*+1			; switch
   403                          cform	*=*+1			; char counter (field)
   404                          sno	*=*+1			; sign no
   405                          blfd	*=*+1			; blank/star flag
   406                          begfd	*=*+1			; pointer to begin of field
   407                          lfor	*=*+1			; length of for]at
   408                          endfd	*=*+1			; pointer to end of field
   409                          puchrs
   410                          pufill	*=*+1			; print using fill symbol
   411                          pucoma	*=*+1			; print using comma symbol
   412                          pudot	*=*+1			; print using decimal point symbol
   413                          pumony	*=*+1			; print using monetary symbol
   414                          ; -------------------------------------------------------------------------------------------------
   415                          ; Basic RAM vectors
   416                          *=$280
   417                          ;    basic indirects
   418                          
   419                          ierror	*=*+2			; error routine, output err in .x
   420                          imain	*=*+2			; main - interpreter main loop
   421                          icrnch	*=*+2			; cruncher - tokenization routine
   422                          iqplop	*=*+2			; qplop - token output expander routine
   423                          igone	*=*+2			; dispatcher
   424                          ieval	*=*+2			; eval routine
   425                          ifrmev	*=*+2			; frmevl routine
   426                          ichrgo	*=*+2			; chrgot routine
   427                          ichrge	*=*+2			; chrget routine
   428                          adray1	*=*+2			; convert float -> integer
   429                          adray2	*=*+2			; convert integer -> float
   430                          
   431                          ; error trapping declarations
   432                          
   433                          trapno	*=*+2			; error trap vector
   434                          errlin	*=*+2			; holds line # of last error
   435                          errtxt	*=*+2			; text pointer at time of error
   436                          oldstk	*=*+1			; stack pointer before execution of last instruction
   437                          tmptrp	*=*+1			; used to save hi byte of trap line >trap & <resume
   438                          dsptmp	*=*+1			; temporary for dispose
   439                          oldtok	*=*+1			;     "      "     "
   440                          tmpdes	*=*+6			; temporary for instr$
   441                          
   442                          highst	*=*+2			; max offset for any user bank
   443                          
   444                          msiism	*=*+1			; used to save length of string to be added in garb collect
   445                          ; ******************************************* TOKENS **********************************************
   446                          !initmem FILL			; All unused memory filled with $ff
   447                          ; 'tables, reserved words, and error texts'
   448                          *=$8000
   449                          ; entry name and entry point jump
   450  8000 4c19b4             bentry:	jmp init 		; entry point for start
   451  8003 4c0bb5             	jmp warm 		; warm start re-entry point
   452  8006 c3c2cd38           	!byte $c3,$c2,$cd,'8'	; cmb8 ($80 or'd in 1st 3 chars)
   453                          ; -------------------------------------------------------------------------------------------------
   454                          ; statment dispatch table
   455  800a 8e8b               stmdsp:	!word end-1
   456  800c 7b8a               	!word for-1
   457  800e ed8a               	!word next-1
   458  8010 bf8c               	!word data-1
   459  8012 118f               	!word inputn-1
   460  8014 2f8f               	!word input-1
   461  8016 d790               	!word dim-1
   462  8018 ac8f               	!word read-1
   463  801a 648d               	!word let-1
   464  801c 688c               	!word goto-1
   465  801e eb8b               	!word run-1
   466  8020 268c               	!word if-1
   467  8022 608b               	!word restor-1
   468  8024 098c               	!word gosub-1
   469  8026 9c8c               	!word return-1
   470  8028 5b8c               	!word rem-1
   471  802a 8c8b               	!word stop-1
   472  802c 058d               	!word ongoto-1
   473  802e 2a91               	!word fnwait-1
   474  8030 a391               	!word cload-1
   475  8032 ea91               	!word csave-1
   476  8034 9791               	!word cverf-1
   477  8036 e190               	!word defn-1
   478  8038 1191               	!word poke-1
   479  803a 488e               	!word printn-1
   480  803c 6b8e               	!word print-1
   481  803e cd8b               	!word cont-1
   482  8040 6a89               	!word list-1
   483  8042 318a               	!word clear-1
   484  8044 4e8e               	!word cmd-1
   485  8046 a790               	!word csys-1
   486  8048 0e92               	!word copen-1
   487  804a 6292               	!word cclos-1
   488  804c dc8e               	!word get-1
   489  804e 158a               	!word scrath-1
   490  8050 608c               	!word go-1
   491                          
   492                          ; disk commands, added 79-june 28
   493  8052 0495               	!word concat-1
   494  8054 3893               	!word dopen-1
   495  8056 7493               	!word dclose-1
   496  8058 5c94               	!word record-1
   497  805a f093               	!word format-1
   498  805c d194               	!word colect-1
   499  805e 1e95               	!word backup-1
   500  8060 e894               	!word dcopy-1
   501  8062 4993               	!word append-1
   502  8064 8e93               	!word dsave-1
   503  8066 9993               	!word dload-1
   504  8068 7cb5               	!word dunit-1
   505  806a 1095               	!word rename-1
   506  806c 2894               	!word scratc-1
   507  806e 6c92               	!word dcat-1			; directory == catalog
   508                          
   509                          ; disk clear command added for toi
   510  8070 c894               	!word dclear-1
   511                          
   512                          ; multi-bank related commands
   513  8072 a993               	!word chbank-1
   514  8074 d793               	!word bload-1
   515  8076 b793               	!word bsave-1
   516                          
   517                          ; function key command
   518  8078 5a91               	!word fkey-1
   519  807a cbad               	!word delete-1
   520  807c 5b8c               	!word rem-1			; else stmt
   521  807e f08c               	!word trap-1
   522  8080 988d               	!word resume-1
   523  8082 f28d               	!word dispos-1
   524  8084 cea6               	!word puctrl-1
   525                          
   526  8086 2ea1               fundsp:	!word sgn
   527  8088 caa1               	!word int
   528  808a 4da1               	!word abs
   529                          
   530  808c 0200               usrloc:	!word usrpok
   531  808e 519c               	!word fre
   532  8090 7a9c               	!word pos
   533  8092 49a4               	!word sqr
   534  8094 6ca5               	!word rnd
   535  8096 fc9e               	!word log
   536  8098 c5a4               	!word exp
   537  809a b5a5               	!word cos
   538  809c bca5               	!word sin
   539  809e 07a6               	!word tan
   540  80a0 a0a6               	!word atn
   541  80a2 339d               	!word peek
   542  80a4 faa9               	!word len
   543  80a6 e5a6               	!word strd
   544  80a8 1aaa               	!word val
   545  80aa 09aa               	!word asc
   546  80ac 54a9               	!word chrd
   547  80ae 68a9               	!word leftd
   548  80b0 99a9               	!word rightd
   549  80b2 b6a9               	!word midd
   550                          ; -------------------------------------------------------------------------------------------------
   551                          ; floating point functions
   552  80b4 79                 optab:	!byte 121
   553  80b5 7e9d               	!word faddt-1
   554                          
   555  80b7 79                 	!byte 121
   556  80b8 619d               	!word fsubt-1
   557                          
   558  80ba 7b                 	!byte 123
   559  80bb 3c9f               	!word fmultt-1
   560                          
   561  80bd 7b                 	!byte 123
   562  80be 13a0               	!word fdivt-1
   563                          
   564  80c0 7f                 	!byte 127
   565  80c1 52a4               	!word fpwrt-1
   566                          
   567  80c3 50                 	!byte 80
   568  80c4 0898               	!word andop-1
   569                          
   570  80c6 46                 	!byte 70
   571  80c7 0598               	!word orop-1
   572                          
   573  80c9 7d                 negtab:	!byte 125
   574  80ca 8ba4               	!word negop-1
   575                          
   576  80cc 5a                 nottab:	!byte 90
   577  80cd b196               	!word notop-1
   578                          
   579  80cf 64                 ptdorl:	!byte 100
   580  80d0 4298               	!word dorel-1
   581                          ; -------------------------------------------------------------------------------------------------
   582                          ; reserved word list
   583                          reslst:
   584                          tkend=$80
   585  80d2 454ec4             	!scr "EN",$c4     		;  end
   586                          tkfor=tkend+1
   587  80d5 464fd2             	!scr "FO",$d2     		;  for
   588                          tknext=tkfor+1
   589  80d8 4e4558d4           	!scr "NEX",$d4    		;  next
   590                          tkdata=tknext+1
   591  80dc 444154c1           	!scr "DAT",$c1    		;  data
   592  80e0 494e505554a3       	!scr "INPUT",$a3  		;  input#
   593  80e6 494e5055d4         	!scr "INPU",$d4   		;  input
   594  80eb 4449cd             	!scr "DI",$cd     		;  dim
   595  80ee 524541c4           	!scr "REA",$c4    		;  read
   596  80f2 4c45d4             	!scr "LE",$d4     		;  let
   597                          tkgoto=tkdata+6
   598  80f5 474f54cf           	!scr "GOT",$cf    		;  goto
   599                          tkrun=tkgoto+1
   600  80f9 5255ce             	!scr "RU",$ce     		;  run
   601  80fc 49c6               	!scr "I",$c6      		;  if
   602                          tkrest=tkrun+2
   603  80fe 524553544f52c5     	!scr "RESTOR",$c5 		;  restore
   604                          tkgosu=tkrest+1
   605  8105 474f5355c2         	!scr "GOSU",$c2   		;  gosub
   606  810a 5245545552ce       	!scr "RETUR",$ce  		;  return
   607                          tkrem=tkgosu+2
   608  8110 5245cd             	!scr "RE",$cd     		;  rem
   609  8113 53544fd0           	!scr "STO",$d0    		;  stop
   610                          tkon=tkrem+2
   611  8117 4fce               	!scr "O",$ce      		;  on
   612  8119 574149d4           	!scr "WAI",$d4    		;  wait
   613  811d 4c4f41c4           	!scr "LOA",$c4    		;  load
   614  8121 534156c5           	!scr "SAV",$c5    		;  save
   615  8125 5645524946d9       	!scr "VERIF",$d9  		;  verify
   616  812b 4445c6             	!scr "DE",$c6     		;  def
   617  812e 504f4bc5           	!scr "POK",$c5    		;  poke
   618  8132 5052494e54a3       	!scr "PRINT",$a3  		;  print#
   619                          tkprin=tkon+8
   620  8138 5052494ed4         	!scr "PRIN",$d4   		;  print
   621  813d 434f4ed4           	!scr "CON",$d4    		;  cont
   622  8141 4c4953d4           	!scr "LIS",$d4    		;  list
   623  8145 434cd2             	!scr "CL",$d2     		;  clr
   624  8148 434dc4             	!scr "CM",$c4     		;  cmd
   625  814b 5359d3             	!scr "SY",$d3     		;  sys
   626  814e 4f5045ce           	!scr "OPE",$ce    		;  open
   627  8152 434c4f53c5         	!scr "CLOS",$c5   		;  close
   628  8157 4745d4             	!scr "GE",$d4     		;  get
   629                          tkscra=tkprin+9
   630  815a 4e45d7             	!scr "NE",$d7     		;  new
   631                          tktab=tkscra+1
   632  815d 544142a8           	!scr "TAB",$a8    		;  tab(
   633                          tkto=tktab+1
   634  8161 54cf               	!scr "T",$cf      		;  to
   635                          tkfn=tkto+1
   636  8163 46ce               	!scr "F",$ce      		;  fn
   637                          tkspc=tkfn+1
   638  8165 535043a8           	!scr "SPC",$a8    		;  spc(
   639                          tkthen=tkspc+1
   640  8169 544845ce           	!scr "THE",$ce    		;  then
   641                          tknot=tkthen+1
   642  816d 4e4fd4             	!scr "NO",$d4     		;  not
   643                          tkstep=tknot+1
   644  8170 535445d0           	!scr "STE",$d0    		;  step
   645                          tkplus=tkstep+1
   646  8174 ab                 	!byte   $ab          		;  "+"
   647                          tkminu=tkplus+1
   648  8175 ad                 	!byte $ad          		;  "-"
   649  8176 aa                 	!byte $aa          		;  "*"
   650  8177 af                 	!byte $af          		;  "/"
   651  8178 de                 	!byte $de          		;  "^"
   652  8179 414ec4             	!scr "AN",$c4     		;  and
   653  817c 4fd2               	!scr "O",$d2      		;  or
   654                          tkgrea=tkminu+6
   655  817e be                 	!byte $be          		;  ">"
   656                          tkequl=tkgrea+1
   657  817f bd                 	!byte $bd          		;  "="
   658                          tkless=tkequl+1
   659  8180 bc                 	!byte $bc          		;  "<"
   660                          tkonef=tkless+1
   661  8181 5347ce             	!scr "SG",$ce     		;  sgn
   662  8184 494ed4             	!scr "IN",$d4     		;  int
   663  8187 4142d3             	!scr "AB",$d3     		;  abs
   664  818a 5553d2             	!scr "US",$d2     		;  usr
   665  818d 4652c5             	!scr "FR",$c5     		;  fre
   666  8190 504fd3             	!scr "PO",$d3     		;  pos
   667  8193 5351d2             	!scr "SQ",$d2     		;  sqr
   668  8196 524ec4             	!scr "RN",$c4     		;  rnd
   669  8199 4c4fc7             	!scr "LO",$c7     		;  log
   670  819c 4558d0             	!scr "EX",$d0     		;  exp
   671  819f 434fd3             	!scr "CO",$d3     		;  cos
   672  81a2 5349ce             	!scr "SI",$ce     		;  sin
   673  81a5 5441ce             	!scr "TA",$ce     		;  tan
   674  81a8 4154ce             	!scr "AT",$ce     		;  atn
   675  81ab 504545cb           	!scr "PEE",$cb    		;  peek
   676  81af 4c45ce             	!scr "LE",$ce     		;  len
   677  81b2 535452a4           	!scr "STR",$a4    		;  str$
   678  81b6 5641cc             	!scr "VA",$cc     		;  val
   679  81b9 4153c3             	!scr "AS",$c3     		;  asc
   680                          tklasn=tkonef+19
   681  81bc 434852a4           	!scr "CHR",$a4    		;  chr$
   682  81c0 4c454654a4         	!scr "LEFT",$a4   		;  left$
   683  81c5 5249474854a4       	!scr "RIGHT",$a4  		;  right$
   684  81cb 4d4944a4           	!scr "MID",$a4    		;  mid$
   685                          tkgo=tklasn+4
   686  81cf 47cf               	!scr "G",$cf      		;  go
   687  81d1 434f4e4341d4       	!scr "CONCA",$d4  		;  concat
   688  81d7 444f5045ce         	!scr "DOPE",$ce   		;  dopen
   689  81dc 44434c4f53c5       	!scr "DCLOS",$c5  		;  dclose
   690  81e2 5245434f52c4       	!scr "RECOR",$c4  		;  record
   691  81e8 4845414445d2       	!scr "HEADE",$d2  		;  header
   692  81ee 434f4c4c4543d4     	!scr "COLLEC",$d4 		;  collect
   693  81f5 4241434b55d0       	!scr "BACKU",$d0  		;  backup
   694  81fb 434f50d9           	!scr "COP",$d9    		;  copy
   695  81ff 415050454ec4       	!scr "APPEN",$c4  		;  apppend
   696  8205 44534156c5         	!scr "DSAV",$c5   		;  dsave
   697  820a 444c4f41c4         	!scr "DLOA",$c4   		;  dload
   698  820f 554e49d4           	!scr "UNI",$d4 			;  unit
   699  8213 52454e414dc5       	!scr "RENAM",$c5  		;  rename
   700  8219 534352415443c8     	!scr "SCRATC",$c8 		;  scratch
   701  8220 4449524543544f52...	!scr "DIRECTOR",$d9		;  directory
   702  8229 44434c4541d2       	!scr "DCLEA",$d2  		;  dclear
   703  822f 42414ecb           	!scr "BAN",$cb    		;  bank
   704  8233 424c4f41c4         	!scr "BLOA",$c4   		;  bload
   705  8238 42534156c5         	!scr "BSAV",$c5   		;  bsave
   706  823d 4b45d9             	!scr "KE",$d9     		;  key
   707  8240 44454c4554c5       	!scr "DELET",$c5  		;  delete
   708                          tkelse=tkgo+22
   709  8246 454c53c5           	!scr "ELS",$c5    		;  else
   710                          tktrap=tkelse+1
   711  824a 545241d0           	!scr "TRA",$d0    		;  trap
   712                          tkresu=tktrap+1
   713  824e 524553554dc5       	!scr "RESUM",$c5  		;  resume
   714  8254 444953504f53c5     	!scr "DISPOS",$c5 		;  dispose
   715  825b 50554445c6         	!scr "PUDE",$c6   		;  pudef
   716                          tkusin=tkresu+3
   717  8260 5553494ec7         	!scr "USIN",$c7   		;  using
   718                          tkerrd=tkusin+1
   719  8265 455252a4           	!scr "ERR",$a4    		;  err$
   720                          tkinst=tkerrd+1
   721  8269 494e5354d2         	!scr "INST",$d2   		;  instr
   722  826e 00                 	!byte 0            		;  end of reserved word list
   723                          ; -------------------------------------------------------------------------------------------------
   724                          ; message vectors
   725                          ebase                   	;base for error messages
   726                          ms0 =*-ebase
   727  826f c782               	!word ams0
   728                          ms1 =*-ebase
   729  8271 d982               	!word ams1
   730                          ms2 =*-ebase
   731  8273 e882               	!word ams2
   732                          ms3 =*-ebase
   733  8275 f282               	!word ams3
   734                          ms4 =*-ebase
   735  8277 0083               	!word ams4
   736                          ms5 =*-ebase
   737  8279 0f83               	!word ams5
   738                          ms6 =*-ebase
   739  827b 2283               	!word ams6
   740                          ms7 =*-ebase
   741  827d 3183               	!word ams7
   742                          ms8 =*-ebase
   743  827f 4183               	!word ams8
   744                          ms9 =*-ebase
   745  8281 5383               	!word ams9
   746                          msg30 =*-ebase
   747  8283 6983               	!word ams30
   748                          msg31 =*-ebase
   749  8285 7983               	!word ams31
   750                          
   751                          msrdy =*-ebase
   752  8287 be84               	!word reddy
   753                          intxt =*-ebase
   754  8289 b984               	!word aintxt
   755                          brktxt =*-ebase
   756  828b c784               	!word abrktx
   757                          exignt =*-ebase
   758  828d ce84               	!word aexi
   759                          tryagn =*-ebase
   760  828f dd84               	!word atry
   761                          fbptr =*-ebase
   762  8291 0002               	!word fbuffr
   763                          mremsg =*-ebase
   764  8293 ee84               	!word aremsg
   765                          asigon =*-ebase
   766  8295 95b4               	!word signon
   767                          awords =*-ebase
   768  8297 c1b4               	!word words
   769                          
   770                          errnf =*-ebase
   771  8299 8583               	!word aernf
   772                          errsn =*-ebase
   773  829b 9683               	!word aersn
   774                          errrg =*-ebase
   775  829d a383               	!word aerrg
   776                          errod =*-ebase
   777  829f b883               	!word aerod
   778                          errfc =*-ebase
   779  82a1 c483               	!word aerfc
   780                          errov =*-ebase
   781  82a3 d583               	!word aerov
   782                          errom =*-ebase
   783  82a5 de83               	!word aerom
   784                          errus =*-ebase
   785  82a7 ec83               	!word aerus
   786                          errbs =*-ebase
   787  82a9 0084               	!word aerbs
   788                          errdd =*-ebase
   789  82ab 0e84               	!word aerdd
   790                          errdvo =*-ebase
   791  82ad 1c84               	!word aerdvo
   792                          errid =*-ebase
   793  82af 2d84               	!word aerid
   794                          errtm =*-ebase
   795  82b1 3c84               	!word aertm
   796                          errls =*-ebase
   797  82b3 4a84               	!word aerls
   798                          errbd =*-ebase
   799  82b5 5a84               	!word aerbd
   800                          errst =*-ebase
   801  82b7 6484               	!word aerst
   802                          errcn =*-ebase
   803  82b9 7884               	!word aercn
   804                          erruf =*-ebase
   805  82bb 8884               	!word aeruf
   806                          errld =*-ebase
   807  82bd 9b84               	!word aerld
   808                          errvr =*-ebase
   809  82bf a984               	!word aervr
   810                          erros =*-ebase
   811  82c1 f484               	!word aeros
   812                          errcr =*-ebase
   813  82c3 0185               	!word aercr
   814                          errdi =*-ebase
   815  82c5 1285               	!word aerdi
   816                          errbln=*-ebase
   817                          ; -------------------------------------------------------------------------------------------------
   818                          ; kernal error messages.
   819  82c7 53544f50204b4559...ams0:	!scr "STOP KEY DETECTED",0
   820  82d9 544f4f204d414e59...ams1:	!scr "TOO MANY FILES",0
   821  82e8 46494c45204f5045...ams2:	!scr "FILE OPEN",0
   822  82f2 46494c45204e4f54...ams3:	!scr "FILE NOT OPEN",0
   823  8300 46494c45204e4f54...ams4:	!scr "FILE NOT FOUND",0
   824  830f 444556494345204e...ams5:	!scr "DEVICE NOT PRESENT",0
   825  8322 4e4f5420494e5055...ams6:	!scr "NOT INPUT FILE",0
   826  8331 4e4f54204f555450...ams7:	!scr "NOT OUTPUT FILE",0
   827  8341 4d495353494e4720...ams8:	!scr "MISSING FILE NAME",0
   828  8353 494c4c4547414c20...ams9:	!scr "ILLEGAL DEVICE "
   829  8362 4e554d42455200     	!scr "NUMBER",0
   830                          
   831                          ; basic error messages.
   832  8369 0d41524520594f55...ams30:	!scr cr,"ARE YOU SURE ?",0
   833  8379 0d42414420444953...ams31:	!scr cr,"BAD DISK ",cr,0
   834                          
   835  8385 4e45585420574954...aernf:	!scr "NEXT WITHOUT FOR",0
   836  8396 53594e5441582045...aersn:	!scr "SYNTAX ERROR",0
   837  83a3 52455455524e2057...aerrg:	!scr "RETURN WITHOUT GOSUB",0
   838  83b8 4f5554204f462044...aerod:	!scr "OUT OF DATA",0
   839  83c4 494c4c4547414c20...aerfc:	!scr "ILLEGAL QUANTITY",0
   840  83d5 4f564552464c4f57...aerov:	!scr "OVERFLOW",0
   841  83de 4f5554204f46204d...aerom:	!scr "OUT OF MEMORY",0
   842  83ec 554e444546494e45...aerus:	!scr "UNDEFINED STATEMENT",0
   843  8400 4241442053554253...aerbs:	!scr "BAD SUBSCRIPT",0
   844  840e 524544494d274420...aerdd:	!scr "REDIM",$27,"D ARRAY",0
   845  841c 4449564953494f4e...aerdvo:	!scr "DIVISION BY ZERO",0
   846  842d 494c4c4547414c20...aerid:	!scr "ILLEGAL DIRECT",0
   847  843c 54595045204d4953...aertm:	!scr "TYPE MISMATCH",0
   848  844a 535452494e472054...aerls:	!scr "STRING TOO LONG",0
   849  845a 46494c4520444154...aerbd:	!scr "FILE DATA",0
   850  8464 464f524d554c4120...aerst:	!scr "FORMULA TOO COMPLEX",0
   851  8478 43414e4e4f542043...aercn:	!scr "CANNOT CONTINUE",0
   852  8488 554e444546494e45...aeruf:	!scr "UNDEFINED FUNCTION",0
   853  849b 0d3f4c4f41442045...aerld:	!scr cr,"?LOAD ERROR",cr,0
   854  84a9 0d3f564552494659...aervr:	!scr cr,"?VERIFY ERROR",cr,0
   855                          
   856  84b9 20494e2000         aintxt:	!scr " IN ",0
   857  84be 0d52454144592e0d...reddy:	!scr cr,"READY.",cr,0
   858  84c7 0d425245414b00     abrktx:	!scr cr,"BREAK",0
   859                          
   860  84ce 4558545241204947...aexi:	!scr "EXTRA IGNORED",cr,0
   861  84dd 5245444f2046524f...atry:	!scr "REDO FROM START",cr,0
   862  84ee 4d4f52450d00       aremsg:	!scr "MORE",cr,0
   863  84f4 4f5554204f462053...aeros:	!scr "OUT OF STACK",0
   864  8501 554e41424c452054...aercr:	!scr "UNABLE TO RESUME",0
   865  8512 554e41424c452054...aerdi:	!scr "UNABLE TO DISPOSE",0
   866                          ; ******************************************* CONTRL **********************************************
   867                          ; 'output error code and start again'
   868  8524 a236               omerr:	ldx #errom		; out of memory
   869                          
   870                          ;   entry: x= offset from errtable
   871  8526 6c8002             error:	jmp (ierror)
   872                          
   873  8529 868d               nerror:	stx errnum		; save error index
   874  852b e038               	cpx #errus		; don't trap undefined statement errors
   875  852d f034               	beq errisd
   876  852f 209e9c             	jsr tstdir		; don't trap if in direct mode
   877  8532 f02f               	beq errisd
   878  8534 ac9702             	ldy trapno+1		; is trap vector set?
   879  8537 c8                 	iny
   880  8538 f029               	beq errisd		; not if $ff
   881  853a 88                 	dey			; restore trapno+1
   882  853b 841c               	sty linnum+1
   883  853d 8c9d02             	sty tmptrp		; save until a resume is executed
   884  8540 ac9602             	ldy trapno		; finish vector
   885  8543 841b               	sty linnum
   886  8545 a0ff               	ldy #$ff
   887  8547 8c9702             	sty trapno+1		; marks no more traps until a 'resume' or 'trap'
   888  854a a201               	ldx #1
   889                          
   890  854c b540               sots:	lda curlin,x
   891  854e 9d9802             	sta errlin,x
   892  8551 b544               	lda oldtxt,x
   893  8553 9d9a02             	sta errtxt,x
   894  8556 ca                 	dex
   895  8557 10f3               	bpl sots
   896  8559 ae9c02             	ldx oldstk
   897  855c 9a                 	txs
   898  855d 20858c             	jsr luk4it		; set up pointers
   899  8560 4c5887             	jmp nstt9		; and goto that line
   900                          
   901  8563 a51a               errisd:	lda channl
   902  8565 f007               	beq error2		; close non-terminal channel.
   903  8567 20ccff             	jsr clrch		; close it
   904  856a a900               	lda #0
   905  856c 851a               	sta channl
   906  856e 20908e             error2:	jsr ocrlf		; output new line
   907  8571 20c9ae             	jsr outqst		; output '?'
   908  8574 a68d               	ldx errnum		; restore offset
   909                          
   910  8576 20d5a2             	jsr msg			; output message
   911                          
   912  8579 205d8a             	jsr stkini		; reset stk and flags
   913                          
   914  857c a441               errfin:	ldy curlin+1
   915  857e c0fa               	cpy #$fa
   916  8580 b00c               	bcs ready		; if # = 64000, don't type line #
   917  8582 a21a               	ldx #intxt
   918  8584 20d5a2             	jsr msg
   919  8587 a541               	lda curlin+1
   920  8589 a640               	ldx curlin
   921                          
   922  858b 20c6a2             	jsr linprt		; list line
   923  858e a218               ready:	ldx #msrdy
   924  8590 20d5a2             	jsr msg			; ready.
   925  8593 a980               	lda #$80		; turn off messages
   926  8595 2090ff             	jsr setmsg
   927                          ; *************************************************************************************************
   928                          ; main loop for basic
   929                          ;
   930                          ; LOAD -> fini
   931                          ;
   932  8598 6c8202             main:	jmp (imain)
   933                          
   934  859b a2ff               nmain:	ldx #255
   935  859d 8641               	stx curlin+1
   936  859f 8e9802             	stx errlin
   937  85a2 8e9902             	stx errlin+1		; flag no errors yet
   938  85a5 868d               	stx errnum
   939  85a7 20c186             	jsr inlin		; get a line from terminal
   940  85aa 8583               	sta txtptr		; txtptr:=^to input buffer
   941  85ac 8484               	sty txtptr+1
   942  85ae 207eb3             	jsr chrget
   943  85b1 aa                 	tax
   944  85b2 f0e4               	beq main		; if end of line
   945  85b4 9013               	bcc main1		; if line number
   946  85b6 c940               	cmp #'@'		; check DOS command?
   947  85b8 d006               	bne main0
   948  85ba 20f3ff             	jsr doscmd		; dos command
   949  85bd 4c8e85             	jmp ready
   950                          
   951  85c0 209188             main0:	jsr crunch
   952  85c3 2081b3             	jsr chrgot		; get command
   953  85c6 4c2f87             	jmp xeqdir		; execute command
   954                          
   955  85c9 20298d             main1:	jsr linget		; read line # into linnum
   956  85cc 209188             	jsr crunch
   957  85cf 840e               	sty count		; retain char count
   958  85d1 20f786             	jsr fndlin
   959  85d4 9047               	bcc nodel		; no match, so don't delete
   960  85d6 a001               	ldy #1
   961  85d8 b16b               	lda (lowtr),y
   962  85da 8523               	sta index1+1
   963                          
   964  85dc a531               	lda vartab		; text end (64k)
   965  85de 8522               	sta index1
   966  85e0 a56c               	lda lowtr+1		; set xfer to
   967  85e2 8526               	sta index2+1
   968  85e4 88                 	dey
   969  85e5 b16b               	lda (lowtr),y		;  compute length
   970  85e7 18                 	clc
   971  85e8 e56b               	sbc lowtr
   972  85ea 49ff               	eor #$ff		;  make it negative
   973  85ec 18                 	clc
   974  85ed 6531               	adc vartab		; compute new text end
   975  85ef 8531               	sta vartab
   976  85f1 8525               	sta index2		; set low of xfer to
   977  85f3 a532               	lda vartab+1
   978  85f5 69ff               	adc #255
   979  85f7 8532               	sta vartab+1		; compute high of text end
   980  85f9 e56c               	sbc lowtr+1		; compute # of blocks to move
   981  85fb aa                 	tax
   982  85fc 38                 	sec
   983  85fd a56b               	lda lowtr
   984  85ff e531               	sbc vartab		; compute offset
   985  8601 a8                 	tay
   986  8602 b003               	bcs qdect1		; if vartab <= lowtr
   987  8604 e8                 	inx			; dec due to carry and
   988  8605 c626               	dec index2+1		; dec store so carry works
   989  8607 18                 qdect1:	clc
   990  8608 6522               	adc index1
   991  860a 9003               	bcc mloop
   992  860c c623               	dec index1+1
   993  860e 18                 	clc
   994  860f b122               mloop:	lda (index1),y
   995  8611 9125               	sta (index2),y
   996  8613 c8                 	iny
   997  8614 d0f9               	bne mloop
   998  8616 e623               	inc index1+1
   999  8618 e626               	inc index2+1
  1000  861a ca                 	dex
  1001  861b d0f2               	bne mloop
  1002  861d 20348a             nodel:	jsr clearc
  1003  8620 208286             	jsr lnkprg
  1004  8623 a000               	ldy #0
  1005  8625 b183               	lda (txtptr),y		; delete line?
  1006  8627 d003               	bne nodele		; no...
  1007  8629 4c9885             	jmp main
  1008                          
  1009  862c 18                 nodele:	clc			; no...something to insert
  1010                          
  1011  862d a531               	lda vartab
  1012  862f a432               	ldy vartab+1
  1013  8631 8565               	sta hightr
  1014  8633 8466               	sty hightr+1		; top of block to move
  1015                          
  1016  8635 650e               	adc count		; length of characters in line
  1017  8637 9001               	bcc nodel1
  1018  8639 c8                 	iny
  1019  863a 18                 nodel1:	clc
  1020  863b 6904               	adc #4 			; plus link and line #
  1021  863d 9001               	bcc nodelc
  1022  863f c8                 	iny
  1023  8640 8562               nodelc:	sta highds		; destination of top
  1024  8642 8463               	sty highds+1
  1025                          
  1026                          ; low block address is lowtr
  1027                          ; where it was left in the call to fndlin
  1028  8644 200488             	jsr bltu
  1029                          
  1030                          ; make links non-null to fool chead
  1031  8647 a000               	ldy #0
  1032  8649 a901               	lda #1
  1033  864b 916b               	sta (lowtr),y
  1034  864d c8                 	iny
  1035  864e 916b               	sta (lowtr),y
  1036                          
  1037                          ; put line number in text
  1038  8650 c8                 	iny
  1039  8651 a51b               	lda linnum
  1040  8653 916b               	sta (lowtr),y
  1041  8655 a51c               	lda linnum+1
  1042  8657 c8                 	iny
  1043  8658 916b               	sta (lowtr),y
  1044                          
  1045                          ; advance lowtr to start of line
  1046  865a c8                 	iny
  1047  865b 98                 	tya
  1048  865c 18                 	clc
  1049  865d 656b               	adc lowtr
  1050  865f 856b               	sta lowtr
  1051  8661 9002               	bcc main2
  1052  8663 e66c               	inc lowtr+1
  1053                          
  1054  8665 a537               main2:	lda strend		; 64k only
  1055  8667 a438               	ldy strend+1
  1056  8669 8531               	sta vartab
  1057  866b 8432               	sty vartab+1
  1058                          
  1059                          ; block move line to text
  1060  866d a40e               	ldy count
  1061  866f 88                 	dey
  1062  8670 b183               stolop:	lda (txtptr),y
  1063  8672 916b               	sta (lowtr),y
  1064  8674 88                 	dey
  1065  8675 c60e               	dec count
  1066  8677 d0f7               	bne stolop
  1067  8679 208286             fini:	jsr lnkprg
  1068  867c 202d8a             	jsr runc
  1069  867f 4c9885             	jmp main
  1070                          
  1071  8682 a52d               lnkprg:	lda txttab
  1072  8684 a42e               	ldy txttab+1
  1073  8686 8522               	sta index
  1074  8688 8423               	sty index+1
  1075  868a 18                 	clc 
  1076  868b a000               chead:	ldy #0
  1077  868d b122               	lda (index),y		; check for null link
  1078  868f d005               	bne chea3
  1079  8691 c8                 	iny
  1080  8692 b122               	lda (index),y
  1081  8694 f01c               	beq lnkrts
  1082  8696 a004               chea3:	ldy #4
  1083  8698 c8                 czloop:	iny
  1084  8699 b122               	lda (index),y
  1085  869b d0fb               	bne czloop
  1086  869d c8                 	iny
  1087  869e 98                 	tya
  1088  869f 6522               	adc index
  1089  86a1 aa                 	tax
  1090  86a2 a000               	ldy #0
  1091  86a4 9122               	sta (index),y
  1092  86a6 98                 	tya
  1093  86a7 6523               	adc index+1
  1094  86a9 c8                 	iny
  1095  86aa 9122               	sta (index),y
  1096  86ac 8622               	stx index
  1097  86ae 8523               	sta index+1
  1098  86b0 90d9               	bcc chead		; always
  1099  86b2 18                 lnkrts:	clc
  1100  86b3 a522               	lda index		; set pointer to end of text
  1101  86b5 a423               	ldy index+1
  1102  86b7 6902               	adc #2
  1103  86b9 9001               	bcc *+3
  1104  86bb c8                 	iny
  1105  86bc 8533               	sta varend
  1106  86be 8434               	sty varend+1
  1107  86c0 60                 	rts
  1108                          ; -------------------------------------------------------------------------------------------------
  1109                          ; line input routine
  1110                          ;   enter: buffpt is used as pointer to start of input buffer.
  1111                          ;   exit:  regs contain pointer to byte preceding buffer
  1112                          ;   index1 also has this pointer value.
  1113                          ;   .a, .y = offset
  1114                          
  1115  86c1 a586               inlin:	lda buffpt
  1116  86c3 a487               	ldy buffpt+1
  1117  86c5 8522               	sta index1
  1118  86c7 8423               	sty index1+1
  1119  86c9 a000               	ldy #0
  1120  86cb 840e               inlinc:	sty count
  1121  86cd 202ab5             	jsr basin
  1122  86d0 c90d               	cmp #cr
  1123  86d2 f00c               	beq fininl
  1124  86d4 a40e               	ldy count
  1125  86d6 9122               	sta (index1),y
  1126  86d8 c8                 	iny
  1127  86d9 c0a1               	cpy #bufsiz
  1128  86db 90ee               	bcc inlinc
  1129  86dd 4c0db1             	jmp errlen		; string too long
  1130  86e0 a40e               fininl:	ldy count
  1131  86e2 a900               	lda #0
  1132  86e4 9122               	sta (index1),y		; line terminator
  1133  86e6 a51a               	lda channl
  1134  86e8 d003               	bne *+5
  1135  86ea 20908e             	jsr ocrlf
  1136  86ed a423               	ldy index1+1
  1137  86ef a622               	ldx index1
  1138  86f1 d001               	bne *+3
  1139  86f3 88                 	dey
  1140  86f4 ca                 	dex
  1141  86f5 8a                 	txa
  1142  86f6 60                 	rts
  1143                          ; -------------------------------------------------------------------------------------------------
  1144                          ; searches program text for the line whose number is passed in 'linnum'.
  1145                          ;   exit:
  1146                          ;   cbit set: lowtr -> to the link field in the line which is the one searched for.
  1147                          ;   cbit clear: line not found. (lowtr) -> line in the program > the one sough after
  1148                          ;   always assume text bank should be used
  1149  86f7 a52d               fndlin:	lda txttab
  1150  86f9 a62e               	ldx txttab+1
  1151  86fb 856b               fndlnc:	sta lowtr
  1152  86fd 866c               	stx lowtr+1
  1153  86ff a000               	ldy #0
  1154  8701 b16b               	lda (lowtr),y		; check for null link
  1155  8703 d005               	bne fndln3
  1156  8705 c8                 	iny
  1157  8706 b16b               	lda (lowtr),y
  1158  8708 f00a               	beq flnrt
  1159  870a a003               fndln3:	ldy #3
  1160  870c b16b               	lda (lowtr),y
  1161  870e c51c               	cmp linnum+1
  1162  8710 f004               	beq fndl20		; look at low bytes
  1163  8712 900b               	bcc affrts		; if not equal,try next
  1164  8714 18                 flnrt:	clc			; didn't find it
  1165  8715 60                 flnrts:	rts
  1166                          
  1167  8716 88                 fndl20:	dey
  1168  8717 b16b               	lda (lowtr),y
  1169  8719 c51b               	cmp linnum
  1170  871b f0f8               	beq flnrts		; if number found
  1171  871d b0f5               	bcs flnrt		; if above number
  1172  871f a001               affrts:	ldy #1
  1173  8721 b16b               	lda (lowtr),y
  1174  8723 aa                 	tax
  1175  8724 88                 	dey
  1176  8725 b16b               	lda (lowtr),y
  1177  8727 90d2               	bcc fndlnc		; always
  1178                          ; -------------------------------------------------------------------------------------------------
  1179                          ; here for new statment.
  1180                          ;   character -> by txtptr is ':' or eol. the adr of this loc is left on the stack when a statement
  1181                          ;   is executed so that it can merely do a rts when it is done.
  1182                          ;   get char, exit via xeqcm3, and return to newstt
  1183                          ; MAIN LOOP -> xeqdir (now routed form new main loop)
  1184                          ; FOR -> newstt
  1185                          ; NERROR -> nstt9 
  1186                          ; GOSUB -> newstt
  1187                          ; IF THEN ELSE -> xeqcm3 (write a ':' after THEN and ELSE as workaround)
  1188                          ; ON GOTO -> xeqcm2
  1189                          xeqcm:
  1190  8729 6c8802             gone:	jmp (igone)
  1191  872c 207eb3             ngone:	jsr chrget		; get statement type
  1192  872f 208087             xeqdir:	jsr xeqcm3
  1193                          
  1194  8732 20e1ff             newstt:	jsr kstop
  1195  8735 d01c               	bne nstt1		; if stop not requested
  1196  8737 38                 	sec			; brk msg desired
  1197  8738 4c948b             	jmp stopc		; if stop requested
  1198                          
  1199  873b b183               sav42:	lda (txtptr),y		; make sure it's not end-of-text
  1200  873d d008               	bne nstt4
  1201  873f c8                 	iny
  1202  8740 b183               	lda (txtptr),y		; end of text storage?
  1203  8742 d003               	bne nstt4		; no...go to next line
  1204  8744 4c8e85             nstt3:	jmp ready			; yes...finished
  1205                          
  1206  8747 a003               nstt4:	ldy #3			; new line, update pointers
  1207  8749 b183               	lda (txtptr),y 		; extract line# lo byte
  1208  874b 8540               	sta curlin
  1209  874d c8                 	iny
  1210  874e b183               	lda (txtptr),y		; extract line # hi byte
  1211  8750 8541               	sta curlin+1
  1212  8752 60                 ffrts1:	rts
  1213                          
  1214  8753 209e9c             nstt1:	jsr tstdir		; are we in direct mode?
  1215  8756 f00c               	beq nstt2		; yes...
  1216                          
  1217                          ; in run mode...
  1218                          ; save txtptr for cont command
  1219  8758 a583               nstt9:  lda txtptr		; entry point for error trapping
  1220  875a a484               	ldy txtptr+1
  1221  875c 8544               	sta oldtxt
  1222  875e 8445               	sty oldtxt+1
  1223  8760 ba                 	tsx
  1224  8761 8e9c02             	stx oldstk		; save in case of error
  1225                          
  1226  8764 a000               nstt2:	ldy #0
  1227  8766 b183               	lda (txtptr),y		; end of the line?
  1228  8768 d043               	bne morsts		; no...end of statement
  1229                          
  1230  876a 209e9c             	jsr tstdir		; in direct mode?
  1231  876d f0d5               	beq nstt3		; yes...finished execution
  1232                          
  1233                          ; in run mode...
  1234                          ; look for start of next line
  1235  876f a001               	ldy #1
  1236  8771 203b87             	jsr sav42
  1237  8774 98                 	tya 			; y=4
  1238  8775 18                 	clc
  1239  8776 6583               	adc txtptr 		; point @ character before line start
  1240  8778 8583               	sta txtptr
  1241  877a 90ad               	bcc xeqcm
  1242  877c e684               	inc txtptr+1
  1243  877e d0a9               	bne xeqcm		; always...execute new line
  1244                          
  1245                          ; set up for command processing and set processor address on stack, exit via jmp to chrget
  1246  8780 f0d0               xeqcm3:	beq ffrts1
  1247  8782 c9ff               xeqcm2:	cmp #pi
  1248  8784 f02e               	beq snerr1
  1249  8786 38                 	sec
  1250  8787 e980               	sbc #tkend
  1251  8789 901f               	bcc glet
  1252  878b c923               	cmp #tkscra-tkend+1
  1253  878d 900e               	bcc nstt6
  1254  878f c94b               	cmp #tkgo-tkend
  1255  8791 9021               	bcc snerr1
  1256                          ;
  1257  8793 c969               	cmp #TKVDP-tkend	; token >= $e9
  1258  8795 b020               	bcs VdpStmt		; -> vdp statement
  1259                          ;
  1260  8797 c967               	cmp #tkerrd-tkend
  1261  8799 b019               	bcs snerr1		; trap err$ & instr$
  1262  879b e927               	sbc #tkgo-tkscra-2
  1263  879d 0a                 nstt6:	asl
  1264  879e a8                 	tay
  1265  879f b90b80             	lda stmdsp+1,y
  1266  87a2 48                 	pha
  1267  87a3 b90a80             	lda stmdsp,y
  1268  87a6 48                 	pha			; process address on stack
  1269  87a7 4c7eb3             	jmp chrget		; process command
  1270                          
  1271  87aa 4c658d             glet:	jmp let
  1272                          
  1273  87ad c93a               morsts:	cmp #':'
  1274  87af d003               	bne snerr1
  1275  87b1 4c2987             	jmp xeqcm		; if ':', continue statement
  1276  87b4 4c0e97             snerr1:	jmp snerr		; -> syntax error, ready
  1277                          ;
  1278                          VdpStmt:
  1279  87b7 e969               	sbc #TKVDP-tkend	; vdp commands 0-21 ($e9-$fe)
  1280  87b9 c916               	cmp #(VdpStmdspEnd-VdpStmdsp)/2
  1281  87bb b0f7               	bcs snerr1		; > last token -> error
  1282  87bd 0a                 	asl			; table position
  1283  87be a8                 	tay
  1284  87bf b940bf             	lda VdpStmdsp+1,y
  1285  87c2 48                 	pha
  1286  87c3 b93fbf             	lda VdpStmdsp,y
  1287  87c6 48                 	pha
  1288  87c7 4c7eb3             	jmp chrget
  1289                          ; -------------------------------------------------------------------------------------------------
  1290                          ; find a 'for' entry on the stack via varpnt
  1291                          ;   exit:
  1292                          ;   not found - z=0
  1293                          ;   found -  z=1, .x=stack offset to for entry
  1294                          ;   fndfor is also used by the return statement to clear off all loops activated during a gosub call. i.e.,
  1295                          ;   all for entries between tos and last gosub entry. register .a contains token value which ended the search.
  1296                          ;   when fndfor is used by a next statement for which no for-variable was given, forpnt shall contain values
  1297                          ;   impossible for actual variables.
  1298  87ca ba                 fndfor:	tsx			 ; load x with stk ptr.
  1299  87cb e8                 	inx
  1300  87cc e8                 	inx
  1301  87cd e8                 	inx
  1302  87ce e8                 	inx		 	; ignore adr (newstt) and rts adr.
  1303                          
  1304  87cf bd0101             ffloop:	lda stack+1,x		; get stack entry
  1305  87d2 c981               	cmp #tkfor
  1306  87d4 d02d               	bne ffrts		; if not 'for' token
  1307  87d6 a554               	lda forpnt+2		; test for real bank#
  1308  87d8 100f               	bpl cmpfor		; yes...
  1309  87da bd0201             	lda stack+2,x		; no, so assume this one
  1310  87dd 8552               	sta forpnt
  1311  87df bd0301             	lda stack+3,x
  1312  87e2 8553               	sta forpnt+1
  1313  87e4 bd0401             	lda stack+4,x
  1314  87e7 8554               	sta forpnt+2
  1315  87e9 dd0401             cmpfor:	cmp stack+4,x
  1316  87ec d00e               	bne addfrs
  1317  87ee a553               	lda forpnt+1
  1318  87f0 dd0301             	cmp stack+3,x
  1319  87f3 d007               	bne addfrs
  1320  87f5 a552               	lda forpnt
  1321  87f7 dd0201             	cmp stack+2,x
  1322  87fa f007               	beq ffrts
  1323  87fc 8a                 addfrs:	txa 
  1324  87fd 18                 	clc
  1325  87fe 6913               	adc #forsiz
  1326  8800 aa                 	tax
  1327  8801 d0cc               	bne ffloop
  1328  8803 60                 ffrts:	rts
  1329                          ; -------------------------------------------------------------------------------------------------
  1330                          ; block transfer routine(s).
  1331                          ;   make space by shoving everything forward.
  1332                          
  1333                          ;   this is done for two purposes:
  1334                          ;   1. to make room for new statements
  1335                          ;   2. to make room for new simple variables.
  1336                          
  1337                          ;   for the 64k version, a single block transfer routine (bltu)
  1338                          ;   serves both purposes. for the 128k, 192k, and 256k versions,
  1339                          ;   separate routines, bltut (for text) and bltuv (for vars),
  1340                          ;   are used as well as a general version of bltu.
  1341                          
  1342                          ;   the allocation of new space requires that checks be made
  1343                          ;   to see if enough memory exists. for the 64k version, the
  1344                          ;   routine, reason, is called. for the 128k, 192k, and 256k
  1345                          ;   versions, reason is called for variables and reasnt is
  1346                          ;   called for text.
  1347                          
  1348                          ;   entry: y,a = (highds)
  1349                          ;   (highds)= destination of high address
  1350                          ;   (lowtr) = lowest adr to be xferred
  1351                          ;   (hightr)= highest adr to be xferred
  1352                          
  1353                          ;
  1354                          ;   exit: (lowtr) = unchanged
  1355                          ;   (hightr)= (lowtr)-80h
  1356                          ;   (highds)= lowest adr xferred into minus 80h
  1357                          ;    high boundary set to new value:
  1358                          ; bltu(64k): strend
  1359                          ; bltut: text end
  1360                          ; bltuv: variable end (strend or varend)
  1361                          bltu:
  1362  8804 205888             	jsr reason		; 64k version
  1363  8807 8537               	sta strend
  1364  8809 8438               	sty strend+1
  1365  880b 38                 	sec			; (all versions) prepare to subract
  1366  880c a565               	lda hightr
  1367  880e e56b               	sbc lowtr		; compute # of things to move and save
  1368  8810 8522               	sta index
  1369  8812 a8                 	tay
  1370  8813 a566               	lda hightr+1
  1371  8815 e56c               	sbc lowtr+1
  1372  8817 aa                 	tax			; put it in a counter reg
  1373  8818 e8                 	inx			; so that cntr algorithm works
  1374  8819 98                 	tya			; see if low part of cnt is 0
  1375  881a f023               	beq decblt		; if 0, start moving blocks
  1376  881c a565               	lda hightr		; must justify base adr
  1377  881e 38                 	sec
  1378  881f e522               	sbc index
  1379  8821 8565               	sta hightr
  1380  8823 b003               	bcs blt1
  1381  8825 c666               	dec hightr+1
  1382  8827 38                 	sec
  1383  8828 a562               blt1:	lda highds
  1384  882a e522               	sbc index
  1385  882c 8562               	sta highds
  1386  882e b008               	bcs moren1
  1387  8830 c663               	dec highds+1
  1388  8832 9004               	bcc moren1
  1389  8834 b165               bltlp:	lda (hightr),y
  1390  8836 9162               	sta (highds),y
  1391  8838 88                 moren1:	dey
  1392  8839 d0f9               	bne bltlp
  1393  883b b165               	lda (hightr),y
  1394  883d 9162               	sta (highds),y
  1395  883f c666               decblt:	dec hightr+1
  1396  8841 c663               	dec highds+1
  1397  8843 ca                 	dex
  1398  8844 d0f2               	bne moren1
  1399  8846 60                 	rts
  1400                          ; -------------------------------------------------------------------------------------------------
  1401                          ; ascertain that a given number of locs remain available for the stack.
  1402                          ;   entry: lda #number of word entries needed
  1403                          ;   jsr getstk must be called by any routine which puts an arbitrary amount of stuff on the stack.
  1404                          ;   note: routines that merely use and free up the guaranteed numlev locations need not call getstk.
  1405                          ;   exit: a and x have been modified.
  1406  8847 0a                 getstk:	asl			; an entry is two bytes
  1407  8848 6934               	adc #numlev+numlev	; overhead required for maximum
  1408  884a b007               	bcs oserr
  1409  884c 8522               	sta index		; this much memory must be left
  1410  884e ba                 	tsx
  1411  884f e422               	cpx index 		; is it?
  1412  8851 b03d               	bcs rearts		; yes...
  1413                          
  1414  8853 a252               oserr:	ldx #erros		; out of stack space error
  1415  8855 4c2685             	jmp error
  1416                          
  1417                          reason:
  1418  8858 c43a               	cpy fretop+1
  1419  885a 9034               	bcc rearts
  1420  885c d004               	bne trymor
  1421  885e c539               	cmp fretop
  1422  8860 902e               	bcc rearts
  1423  8862 48                 trymor:	pha
  1424  8863 a209               	ldx #8+addprc
  1425  8865 98                 	tya
  1426  8866 48                 reasav:	pha
  1427  8867 b561               	lda highds-1,x
  1428  8869 ca                 	dex
  1429  886a 10fa               	bpl reasav
  1430  886c 20f8ab             	jsr garba2
  1431  886f a2f7               	ldx #248-addprc
  1432  8871 68                 reasto:	pla
  1433  8872 956b               	sta highds+8+addprc,x
  1434  8874 e8                 	inx
  1435  8875 30fa               	bmi reasto
  1436  8877 68                 	pla
  1437  8878 a8                 	tay
  1438  8879 68                 	pla
  1439  887a c43a               	cpy fretop+1
  1440  887c 9012               	bcc rearts
  1441  887e d004               	bne omerrc
  1442  8880 c539               	cmp fretop
  1443  8882 900c               	bcc rearts
  1444  8884 4c2485             omerrc:	jmp omerr		; out of memory error
  1445                          
  1446  8887 20c198             sav73:	jsr ptrget
  1447  888a 8552               sav74:	sta forpnt
  1448  888c 8453               	sty forpnt+1
  1449  888e 8654               	stx forpnt+2
  1450  8890 60                 rearts:	rts
  1451                          ; -------------------------------------------------------------------------------------------------
  1452                          ; crunch
  1453                          ;   entry:  txtptr points to start of text to crunch
  1454                          ;   exit:   txtptr points to start of crunched text
  1455                          ;   calls:  chrget, chrgot, reser, kloop, rem, data
  1456                          ;   collapses all reserved words to tokens.  does not alter data or rem.  removes all graphic
  1457                          ;   characters not in quoted strings
  1458                          
  1459  8891 6c8402             crunch:	jmp (icrnch)
  1460                          
  1461  8894 a583               ncrnch:	lda txtptr		; save old text loc
  1462  8896 48                 	pha
  1463  8897 a584               	lda txtptr+1
  1464  8899 48                 	pha
  1465  889a 2081b3             crun05:	jsr chrgot
  1466  889d 4ca388             	jmp crun20
  1467                          
  1468  88a0 207eb3             crun10:	jsr chrget
  1469  88a3 90fb               crun20:	bcc crun10		; don't crunch numbers
  1470  88a5 c900               	cmp #0			; end of line?
  1471  88a7 f059               	beq crun90		; yes...
  1472  88a9 c93a               	cmp #':'		; multi-stmt char?
  1473  88ab f0f3               	beq crun10
  1474  88ad c93f               	cmp #'?'		; print abreviation?
  1475  88af d008               	bne crun30		; no...
  1476  88b1 a999               	lda #tkprin		; substitute print token
  1477  88b3 a000               	ldy #0
  1478  88b5 9183               	sta (txtptr),y
  1479  88b7 f0e7               	beq crun10		; branch always
  1480  88b9 c980               crun30:	cmp #$80		; graphics?
  1481  88bb 900b               	bcc crun40		; no...
  1482  88bd c9ff               	cmp #pi			; yes...pi?
  1483  88bf f0df               	beq crun10		; o.k....leave alone
  1484  88c1 a001               	ldy #1
  1485  88c3 201189             	jsr kloop		; crunch out graphics
  1486  88c6 f0d2               	beq crun05		; branch always
  1487  88c8 c922               crun40:	cmp #$22 ; "		; quote string?
  1488  88ca d00d               	bne crun60		; no...
  1489  88cc 207eb3             crun50: jsr chrget
  1490  88cf c900               	cmp #$0			; end of line?
  1491  88d1 f02f               	beq crun90		; yes...
  1492  88d3 c922               	cmp #$22 ; "		; close quote?
  1493  88d5 f0c9               	beq crun10		; yes...
  1494  88d7 d0f3               	bne crun50		; no...
  1495  88d9 202989             crun60:	jsr reser		; reserved word?
  1496  88dc 90c2               	bcc crun10
  1497  88de c000               	cpy #0			; anything to move?
  1498  88e0 f003               	beq crun70		; no...
  1499  88e2 201189             	jsr kloop		; crunch it out
  1500  88e5 a50e               crun70:	lda count		; put token...
  1501  88e7 a000               	ldy #0
  1502  88e9 9183               	sta (txtptr),y		; in text
  1503  88eb c98f               	cmp #tkrem
  1504  88ed f00d               	beq crun80
  1505  88ef c983               	cmp #tkdata
  1506  88f1 d0ad               	bne crun10
  1507  88f3 207eb3             	jsr chrget
  1508  88f6 20c08c             	jsr data
  1509  88f9 4c9a88             	jmp crun05
  1510  88fc 207eb3             crun80:	jsr chrget
  1511  88ff 205c8c             	jsr rem
  1512                          
  1513                          ; no other statements can follow a rem
  1514  8902 a683               crun90:	ldx txtptr
  1515  8904 68                 	pla
  1516  8905 8584               	sta txtptr+1
  1517  8907 68                 	pla
  1518  8908 8583               	sta txtptr
  1519  890a 38                 	sec			; compute length of line
  1520  890b 8a                 	txa
  1521  890c e583               	sbc txtptr
  1522  890e a8                 	tay
  1523  890f c8                 	iny
  1524  8910 60                 	rts
  1525                          ; -------------------------------------------------------------------------------------------------
  1526                          ; kloop
  1527                          ;   crunch loop.  moves offset .y characters from txtptr to end of line
  1528  8911 18                 kloop:	clc			; compute source address
  1529  8912 98                 	tya
  1530  8913 6583               	adc txtptr
  1531  8915 8522               	sta index1
  1532  8917 a584               	lda txtptr+1
  1533  8919 6900               	adc #0
  1534  891b 8523               	sta index1+1
  1535  891d a000               	ldy #0
  1536  891f b122               kloop2:	lda (index1),y		; move source
  1537  8921 9183               	sta (txtptr),y		; to destination offset
  1538  8923 c8                 	iny
  1539  8924 c900               	cmp #0			; end of line?
  1540  8926 d0f7               	bne kloop2		; no...
  1541  8928 60                 	rts
  1542                          ; -------------------------------------------------------------------------------------------------
  1543                          ; reser
  1544                          ;   search reserved word list for a match
  1545                          ;   entry:  (txtptr) is first char of word to match
  1546                          ;   exit:   .y=length of word matched
  1547                          ;   .c=success/fail (set/clear) flag
  1548                          ;   count=token value
  1549  8929 a980               reser:	lda #>reslst		; start search here
  1550  892b a0d2               	ldy #<reslst
  1551  892d 8523               	sta index1+1
  1552  892f 8422               	sty index1
  1553  8931 a000               	ldy #0
  1554  8933 840e               	sty count
  1555  8935 88                 	dey
  1556  8936 c8                 rese10:	iny
  1557  8937 b183               rese20:	lda (txtptr),y
  1558  8939 38                 	sec
  1559  893a f122               	sbc (index1),y		; does letter match?
  1560  893c f0f8               	beq rese10		; yes...continue
  1561  893e c980               	cmp #eom		; no...end of word?
  1562  8940 f01a               	beq rese60		; yes...c set...done
  1563                          
  1564                          ; find next word
  1565  8942 b122               rese30:	lda (index1),y
  1566  8944 3003               	bmi rese40		; found end of current
  1567  8946 c8                 	iny
  1568  8947 d0f9               	bne rese30
  1569  8949 c8                 rese40:	iny			 ; start of next
  1570  894a e60e               	inc count		; value of token
  1571  894c 18                 	clc
  1572  894d 98                 	tya
  1573  894e 2090a9             	jsr sav14
  1574  8951 a000               	ldy #0
  1575  8953 b122               	lda (index1),y		;  end of list?
  1576                          	
  1577  8955 f00a               	beq rese70		; 0 = yes..start with vdplst
  1578  8957 c901               	cmp #1			; 1 = end of vdplst ?
  1579                          
  1580  8959 d0dc               	bne rese20		; no...
  1581  895b 18                 	clc
  1582                          ; yes...carry clear...fail
  1583  895c 050e               rese60:	ora count		; .a=$80 if match
  1584  895e 850e               	sta count		; token is formed
  1585  8960 60                 	rts
  1586                          
  1587  8961 a96b               rese70:	lda #<Vdplst		; set index to vdplst
  1588  8963 8522               	sta index
  1589  8965 a9bf               	lda #>Vdplst
  1590  8967 8523               	sta index+1
  1591  8969 d0cc               	bne rese20		; branch always
  1592                          ; ****************************************** BVERBS1 **********************************************
  1593                          ; LIST - process list verb
  1594                          
  1595  896b 2020ae             list:	jsr range		; set up line range
  1596  896e d001               	bne lstend		; ok...
  1597  8970 60                 	rts			; some bad params, do nothing
  1598                          
  1599  8971 68                 lstend:	pla
  1600  8972 68                 	pla
  1601                          
  1602  8973 a001               list4:	ldy #1
  1603  8975 8413               	sty dores
  1604  8977 b16b               	lda (lowtr),y
  1605  8979 d005               	bne list44
  1606  897b 88                 	dey
  1607  897c b16b               	lda (lowtr),y
  1608  897e f04c               	beq grody
  1609  8980 a001               list44:	ldy #1
  1610  8982 20e1ff             	jsr kstop
  1611  8985 d004               	bne list5		; if no stop requested
  1612  8987 18                 	clc			; no brk msg desired for...
  1613  8988 4c948b             	jmp stopc		; ...process stop
  1614                          
  1615  898b 20908e             list5:	jsr ocrlf		; new line
  1616  898e c8                 	iny
  1617  898f b16b               	lda (lowtr),y
  1618  8991 aa                 	tax
  1619  8992 c8                 	iny
  1620  8993 b16b               	lda (lowtr),y
  1621  8995 c51c               	cmp linnum+1
  1622  8997 d004               	bne tstdun
  1623  8999 e41b               	cpx linnum
  1624  899b f002               	beq typlin
  1625                          
  1626  899d b02d               tstdun:	bcs grody
  1627  899f 8452               typlin:	sty lstpnt
  1628  89a1 20c6a2             	jsr linprt
  1629  89a4 a920               	lda #$20
  1630  89a6 a452               prit4:	ldy lstpnt			; restore position y
  1631  89a8 297f               	and #$7f			; clear bi7t from last char of word
  1632  89aa 20cbae             ploop:	jsr ochr			; output char (first char after linenumber is space already in a)
  1633  89ad c922               	cmp #$22;"			; test for quote
  1634  89af d006               	bne ploop1			; no.. skip
  1635  89b1 a513               	lda dores			; toggle reverse flag (init at line start =$01)
  1636  89b3 49ff               	eor #$ff			; $fe or i6509
  1637  89b5 8513               	sta dores
  1638  89b7 c8                 ploop1:	iny				; next char
  1639  89b8 f012               	beq grody			; $00 ? -> end of line
  1640  89ba b16b               	lda (lowtr),y			; load next char
  1641  89bc d011               	bne qplop			; -> check char/token
  1642                          ; pointer to next line
  1643  89be a8                 	tay				; y = 0
  1644  89bf b16b               	lda (lowtr),y			; load address low of next line
  1645  89c1 aa                 	tax
  1646  89c2 c8                 	iny
  1647  89c3 b16b               	lda (lowtr),y			; load address high
  1648  89c5 866b               	stx lowtr			; set lowtr pointer to next line address
  1649  89c7 856c               	sta lowtr+1
  1650  89c9 4c7389             	jmp list4			; -> list next line
  1651  89cc 4c8e85             grody:	jmp ready			; end of list
  1652                          
  1653  89cf 6c8602             qplop:	jmp (iqplop)
  1654                          ; check char / token
  1655  89d2 10d6               nqplop:	bpl ploop			; print char if no token
  1656  89d4 c9ff               	cmp #pi
  1657  89d6 f0d2               	beq ploop			; print pi
  1658  89d8 2413               	bit dores			; check id just switched to reverse mode
  1659  89da 30ce               	bmi ploop			; print quote
  1660  89dc 8452               	sty lstpnt			; remember y
  1661                          ;
  1662  89de c9e9               	cmp #TKVDP			; vdp token ?
  1663  89e0 900d               	bcc ldresl			; no.. -> select standard reslst
  1664                          ; vdp token
  1665  89e2 a0bf               	ldy #>Vdplst			; set index to reserved word list
  1666  89e4 8423               	sty index+1
  1667  89e6 a06b               	ldy #<Vdplst
  1668  89e8 8422               	sty index
  1669  89ea 38                 	sec
  1670  89eb e969               	sbc #TKVDP-tkend		; calc vdp token 0-21	
  1671  89ed 3008               	bmi rescr0			; -> skip always
  1672                          ; basic token
  1673  89ef a080               ldresl:	ldy #>reslst			; set index to reserved word list
  1674  89f1 8423               	sty index1+1
  1675  89f3 a0d2               	ldy #<reslst
  1676  89f5 8422               	sty index1
  1677                          
  1678  89f7 aa                 rescr0:	tax				; token in x
  1679  89f8 a000               	ldy #0
  1680                          plop20:	
  1681  89fa 0a                 	asl				; *2 (clears bit 7 for token)
  1682  89fb f010               	beq prit3b			; -> print word
  1683                          ; point index1 at start of word
  1684  89fd ca                 resrch:	dex				; dec x wor next word in table
  1685  89fe 100c               	bpl prit3			; -> print if word number found
  1686  8a00 e622               rescr1:	inc index1			; increase pointer to reslst
  1687  8a02 d002               	bne rescr2
  1688  8a04 e623               	inc index1+1
  1689  8a06 b122               rescr2:	lda (index1),y			; load char from table
  1690  8a08 10f6               	bpl rescr1
  1691  8a0a 30f1               	bmi resrch
  1692                          ; list word indexing by y
  1693  8a0c c8                 prit3:	iny				; next char of word
  1694  8a0d b122               prit3b:	lda (index1),y			; load char from reserved word list
  1695  8a0f 3095               	bmi prit4			; last char ? -> clear bit#7 and print 
  1696  8a11 20cbae             	jsr ochr			; print char
  1697  8a14 d0f6               	bne prit3			; always (returned char is never zero)
  1698                          ; -------------------------------------------------------------------------------------------------
  1699                          ; process new and clr commands.
  1700                          ;   scrtch resets text area.
  1701                          ;   clearc resets data areas.
  1702                          
  1703  8a16 d05f               scrath:	bne stkrts
  1704  8a18 a900               scrtch:	lda #0
  1705  8a1a a8                 	tay
  1706  8a1b 912d               	sta (txttab),y
  1707  8a1d c8                 	iny
  1708  8a1e 912d               	sta (txttab),y
  1709  8a20 18                 	clc
  1710  8a21 a52d               	lda txttab
  1711  8a23 6902               	adc #2
  1712  8a25 8531               	sta vartab
  1713  8a27 a52e               	lda txttab+1
  1714  8a29 6900               	adc #0
  1715  8a2b 8532               	sta vartab+1
  1716                          
  1717  8a2d 2052ae             runc:	jsr stxtpt
  1718  8a30 a900               	lda #0
  1719                          
  1720                          ; clearc:
  1721                          ;   strend:=arytab:=vartab
  1722  8a32 d043               clear:	bne stkrts
  1723  8a34 200ab4             clearc:	jsr settop			; set top of memory
  1724  8a37 a9ff               	lda #$ff			; indicate no error trap vector
  1725  8a39 8d9702             	sta trapno+1
  1726  8a3c a203               	ldx #pumony-puchrs		; reset print using chars
  1727  8a3e bd788a             clrpu:	lda pudefs,x
  1728  8a41 9d7302             	sta puchrs,x
  1729  8a44 ca                 	dex
  1730  8a45 10f7               	bpl clrpu
  1731  8a47 a900               	lda #0
  1732  8a49 8516               	sta dsdesc			; clear ds$
  1733  8a4b 2052b5             	jsr clall
  1734  8a4e a531               	lda vartab
  1735  8a50 a432               	ldy vartab+1
  1736  8a52 8537               	sta strend
  1737  8a54 8438               	sty strend+1
  1738  8a56 8535               	sta arytab
  1739  8a58 8436               	sty arytab+1
  1740  8a5a 207c8b             fload:	jsr resto1
  1741                          
  1742                          ; reset stk, clear oltxt and current channel
  1743  8a5d a200               stkini:	ldx #0
  1744  8a5f 861d               	stx temppt
  1745  8a61 68                 	pla 
  1746  8a62 a8                 	tay
  1747  8a63 68                 	pla			; get callers address
  1748  8a64 a2fe               	ldx #$fe		; reset stack (leave $01ff free)
  1749  8a66 9a                 	txs
  1750  8a67 48                 	pha
  1751  8a68 98                 	tya
  1752  8a69 48                 	pha			; restore caller's address
  1753  8a6a a900               	lda #0
  1754  8a6c 8544               	sta oldtxt
  1755  8a6e 8545               	sta oldtxt+1
  1756  8a70 851a               	sta channl		; clear out channel
  1757  8a72 8d5802             	sta dolu
  1758  8a75 8514               	sta subflg
  1759  8a77 60                 stkrts:	rts
  1760                          
  1761  8a78 202c2e24           pudefs:	!scr " ,.$"		; default fill,comma,dec pt,money symbols
  1762                          ; -------------------------------------------------------------------------------------------------
  1763                          ; FOR
  1764                          ;    a 'for' entry on the stk has the following format using sp relative offsets:
  1765                          ;    (17-18) txtptr value to end of for-stmt
  1766                          ;    (15-16) line number of for-stmt
  1767                          ;    (10-14) limit value, in basic floating form
  1768                          ;    (04-09) step value, in fac floating form
  1769                          ;    (01-03) ptr to for-var's data area
  1770                          ;    (00)    tkfor token
  1771                          
  1772                          ;   this code creates a new for-entry on the stack.
  1773                          ;   note, return to the caller of "for" is cleared and control jumps to newstt. active for-loops between this
  1774                          ;   and an older loop of the same for-variable are cleared off.
  1775                          
  1776  8a7c a980               for:	lda #128
  1777  8a7e 8514               	sta subflg		; integer for-vars illegal
  1778  8a80 20658d             	jsr let			; for-var <- initial value
  1779  8a83 20ca87             	jsr fndfor		; pop off redundant entries
  1780  8a86 d005               	bne notol
  1781  8a88 8a                 	txa
  1782  8a89 6910               	adc #forsiz-3
  1783  8a8b aa                 	tax
  1784  8a8c 9a                 	txs
  1785  8a8d 68                 notol:	pla
  1786  8a8e 68                 	pla
  1787  8a8f a909               	lda #8+addprc
  1788  8a91 204788             	jsr getstk
  1789  8a94 20ce8c             	jsr datan
  1790  8a97 18                 	clc
  1791  8a98 98                 	tya
  1792  8a99 6583               	adc txtptr		; ptr to end-of-for-stmt
  1793  8a9b 48                 	pha
  1794  8a9c a584               	lda txtptr+1
  1795  8a9e 6900               	adc #0
  1796  8aa0 48                 	pha
  1797  8aa1 a541               	lda curlin+1		; line number
  1798  8aa3 48                 	pha
  1799  8aa4 a540               	lda curlin
  1800  8aa6 48                 	pha
  1801  8aa7 a9a4               	lda #tkto
  1802  8aa9 20ec96             	jsr synchr		; check for 'to' token
  1803  8aac 209aae             	jsr chknum
  1804  8aaf 2097ae             	jsr frmnum		; compute limit, round
  1805  8ab2 a574               	lda facsgn
  1806  8ab4 097f               	ora #127
  1807  8ab6 2570               	and facho
  1808  8ab8 8570               	sta facho
  1809  8aba a9c5               	lda #<ldfone		; return from forpsh
  1810  8abc a08a               	ldy #>ldfone
  1811  8abe 8522               	sta index1
  1812  8ac0 8423               	sty index1+1
  1813  8ac2 4c2696             	jmp forpsh
  1814  8ac5 a9ce               ldfone:	lda #<fone		; "one",default step
  1815  8ac7 a09e               	ldy #>fone
  1816  8ac9 2091a0             	jsr movfm
  1817  8acc 2081b3             	jsr chrgot
  1818  8acf c9a9               	cmp #tkstep
  1819  8ad1 d006               	bne oneon		; no step given...
  1820  8ad3 207eb3             	jsr chrget
  1821  8ad6 2097ae             	jsr frmnum		; compute step value
  1822  8ad9 2020a1             oneon:	jsr sign
  1823  8adc 201796             	jsr pushf
  1824  8adf a554               	lda forpnt+2		; for-var pointer
  1825  8ae1 48                 	pha
  1826  8ae2 a553               	lda forpnt+1
  1827  8ae4 48                 	pha
  1828  8ae5 a552               	lda forpnt
  1829  8ae7 48                 	pha
  1830  8ae8 a981               	lda #tkfor		; for token
  1831  8aea 48                 	pha
  1832  8aeb 4c3287             	jmp newstt		; get new statement
  1833                          ; -------------------------------------------------------------------------------------------------
  1834                          ; NEXT
  1835                          
  1836  8aee d004               next:	bne getfor
  1837  8af0 a2ff               	ldx #$ff		; garbage bank#
  1838  8af2 3003               	bmi stxfor		; always
  1839  8af4 20c198             getfor:	jsr ptrget
  1840  8af7 208a88             stxfor:	jsr sav74
  1841  8afa 20ca87             	jsr fndfor
  1842  8afd f005               	beq havfor
  1843  8aff a22a               	ldx #errnf
  1844  8b01 4c2685             	jmp error
  1845                          
  1846  8b04 9a                 havfor:	txs
  1847  8b05 8a                 	txa
  1848  8b06 18                 	clc
  1849  8b07 6905               	adc #2+ptrsiz		;  offset to step va lue
  1850  8b09 48                 	pha
  1851  8b0a 6906               	adc #5+addprc
  1852  8b0c 8525               	sta index2		; offset to limit value
  1853  8b0e 68                 	pla
  1854  8b0f a001               	ldy #1
  1855  8b11 2091a0             	jsr movfm		; fac<-step value
  1856  8b14 ba                 	tsx
  1857  8b15 bd0a01             	lda stack+9+addprc,x
  1858  8b18 8574               	sta facsgn
  1859  8b1a a552               	lda forpnt
  1860  8b1c a453               	ldy forpnt+1
  1861  8b1e a654               	ldx forpnt+2
  1862  8b20 208e9f             	jsr ucnupk		; acc <- for value
  1863  8b23 207f9d             	jsr faddt
  1864  8b26 20c3a0             	jsr movvf		; for var=for var+step
  1865  8b29 a001               	ldy #1
  1866  8b2b 2052a1             	jsr fcompn		; compare to limit
  1867  8b2e ba                 	tsx
  1868  8b2f 38                 	sec			; correct results for sign
  1869  8b30 fd0a01             	sbc stack+9+addprc,x
  1870  8b33 f017               	beq loopdn
  1871  8b35 bd1001             	lda stack+14+addprc+addprc,x
  1872  8b38 8540               	sta curlin		; not done, repeat...
  1873  8b3a bd1101             	lda stack+15+addprc+addprc,x
  1874  8b3d 8541               	sta curlin+1
  1875  8b3f bd1301             	lda stack+17+addprc+addprc,x
  1876  8b42 8583               	sta txtptr
  1877  8b44 bd1201             	lda stack+16+addprc+addprc,x
  1878  8b47 8584               	sta txtptr+1
  1879  8b49 4c3287             newsgo:	jmp newstt
  1880                          
  1881  8b4c 8a                 loopdn:	txa			; cy=1
  1882  8b4d 6912               	adc #16+addprc+addprc
  1883  8b4f aa                 	tax
  1884  8b50 9a                 	txs			; pop for-entry off stack
  1885  8b51 2081b3             	jsr chrgot
  1886  8b54 c92c               	cmp #','
  1887  8b56 d0f1               	bne newsgo
  1888  8b58 207eb3             	jsr chrget
  1889  8b5b 20f48a             	jsr getfor
  1890  8b5e 4c97ae             	jmp frmnum
  1891                          ; -------------------------------------------------------------------------------------------------
  1892                          ; RESTORE
  1893                          
  1894  8b61 f019               restor:	beq resto1		; no argument..set pointer to start of text
  1895  8b63 207bae             	jsr getpin 		; get line #
  1896  8b66 841b               	sty linnum 		; store < of arg
  1897  8b68 851c               	sta linnum+1		; store > of arg
  1898  8b6a 20f786             	jsr fndlin 		; point to link of arg. line #
  1899  8b6d 901b               	bcc reserr		; line not found
  1900  8b6f a56b               	lda lowtr		; fndlin's result
  1901  8b71 e901               	sbc #1
  1902  8b73 8549               	sta datptr
  1903  8b75 a56c               	lda lowtr+1
  1904  8b77 e900               	sbc #0
  1905  8b79 854a               	sta datptr+1
  1906  8b7b 60                 	rts
  1907  8b7c 38                 resto1:	sec
  1908  8b7d a52d               	lda txttab
  1909  8b7f e901               	sbc #1
  1910  8b81 8549               	sta datptr
  1911  8b83 a52e               	lda txttab+1
  1912  8b85 e900               	sbc #0
  1913  8b87 854a               	sta datptr+1
  1914  8b89 60                 runm10:	rts
  1915  8b8a 4cae8c             reserr:	jmp userr 		; undef'd statement
  1916                          ; -------------------------------------------------------------------------------------------------
  1917                          ; STOP - process stop verb
  1918                          
  1919  8b8d b001               stop:	bcs stpz2
  1920  8b8f 18                 end:	clc
  1921  8b90 d059               stpz2:	bne contx
  1922  8b92 f014               	beq stopd		; always
  1923                          
  1924                          ; here if stop key depressed while running
  1925                          ; enter: cy=0   =>  no break message desired
  1926  8b94 08                 stopc:	php        		; entered from list or newstt
  1927  8b95 ac9702             	ldy trapno+1   		; test if error trapping on
  1928  8b98 c8                 	iny
  1929  8b99 f00a               	beq sa         		; branch if not
  1930                          
  1931  8b9b 20e1ff             unstop: jsr kstop      		; don't go on till stop key no longer depressed
  1932  8b9e f0fb               	beq unstop
  1933  8ba0 a21c               	ldx #$1c       		; otherwise load 'break' error number
  1934  8ba2 4c2685             	jmp error      		; and error routine will goto error trapping
  1935  8ba5 28                 sa:	plp
  1936  8ba6 48                 	pha
  1937  8ba7 48                 	pha		 ; ....push dummy return to be discarded
  1938  8ba8 08                 stopd:	php		 ;  save cy flag
  1939  8ba9 209e9c             	jsr tstdir		; in direct mode?
  1940  8bac f010               	beq nsxx4		; yes...can't continue
  1941  8bae a583               	lda txtptr
  1942  8bb0 a484               	ldy txtptr+1
  1943  8bb2 8544               	sta oldtxt
  1944  8bb4 8445               	sty oldtxt+1
  1945  8bb6 a540               	lda curlin
  1946  8bb8 a441               	ldy curlin+1
  1947  8bba 8542               	sta oldlin
  1948  8bbc 8443               	sty oldlin+1
  1949  8bbe 28                 nsxx4:	plp		 ; restore cy flag
  1950  8bbf 68                 	pla		 ; pop off return to newstt from xeqcm3
  1951  8bc0 68                 	pla
  1952  8bc1 9008               endcon:	bcc nsxx6		; if no break message
  1953  8bc3 a21c               	ldx #brktxt
  1954  8bc5 20d5a2             	jsr msg		 ; output message
  1955  8bc8 4c7c85             	jmp errfin
  1956                          
  1957  8bcb 4c8e85             nsxx6:	jmp ready		; output ready message
  1958                          
  1959  8bce d01b               cont:	bne contx		; make sure there is a terminator
  1960  8bd0 a445               	ldy oldtxt+1
  1961  8bd2 d009               	bne contz3		; if there is code to continue
  1962  8bd4 a544               	lda oldtxt
  1963  8bd6 d007               	bne contz4
  1964  8bd8 a24a               	ldx #errcn
  1965  8bda 4c2685             	jmp error
  1966  8bdd a544               contz3 lda oldtxt
  1967  8bdf 8583               contz4 sta txtptr
  1968  8be1 8484               	sty txtptr+1
  1969  8be3 a542               	lda oldlin
  1970  8be5 a443               	ldy oldlin+1
  1971  8be7 8540               	sta curlin
  1972  8be9 8441               	sty curlin+1
  1973  8beb 60                 contx:	rts
  1974                          ; -------------------------------------------------------------------------------------------------
  1975                          ; RUN - process run verb
  1976                          
  1977  8bec 20fc8b             run:	jsr runmod		; set run mode
  1978  8bef 2081b3             	jsr chrgot		; is there a line # ?
  1979  8bf2 d003               	bne run2		; yes...
  1980  8bf4 4c2d8a             	jmp runc		; no...run from txttab and clear stack
  1981  8bf7 20348a             run2 jsr clearc			; run from line #...only clear stack
  1982  8bfa f022               	beq runc2		; common routine for goto and gosub ... always go
  1983                          
  1984                          ;initialize run mode
  1985                          ;can be started by run,goto, or gosub
  1986  8bfc 209e9c             runmod:	jsr tstdir
  1987  8bff d088               	bne runm10		; already running
  1988  8c01 a9fe               	lda #$fe		; curlin>64999 and <> $ff00
  1989                          ; neither valid line or direct mode
  1990  8c03 8541               	sta curlin+1
  1991  8c05 a900               	lda #0
  1992  8c07 4c90ff             	jmp setmsg		; no loading messages, etc. during run
  1993                          ; -------------------------------------------------------------------------------------------------
  1994                          ; GOSUB -  process gosub verb
  1995                          ;   on entry has the following format
  1996                          ;   1. the gosutk one byte
  1997                          ;   2. the line # of the gosub statement - two bytes
  1998                          ;   3. a -> into the text of the gosub   - two bytes
  1999                          ;   total of 5 bytes
  2000                          
  2001  8c0a a903               gosub:	lda #3
  2002  8c0c 204788             	jsr getstk		; make sure there is room
  2003  8c0f a584               	lda txtptr+1
  2004  8c11 48                 	pha
  2005  8c12 a583               	lda txtptr
  2006  8c14 48                 	pha			; push text ptr onto stk
  2007  8c15 a541               	lda curlin+1
  2008  8c17 48                 	pha
  2009  8c18 a540               	lda curlin
  2010  8c1a 48                 	pha			; push current line #
  2011  8c1b a98d               	lda #tkgosu
  2012  8c1d 48                 	pha			; push on a gosub token
  2013  8c1e 2081b3             runc2:	jsr chrgot		; get chr and set codes for linget
  2014  8c21 20698c             	jsr goto
  2015  8c24 4c3287             	jmp newstt
  2016                          ; -------------------------------------------------------------------------------------------------
  2017                          ; IF
  2018                          
  2019  8c27 207a95             if:	jsr frmevl
  2020  8c2a 2411               	bit valtyp
  2021  8c2c 1003               	bpl if50
  2022  8c2e 20c3a7             	jsr frefac		; if string expr
  2023  8c31 2081b3             if50:	jsr chrgot
  2024  8c34 c989               	cmp #tkgoto
  2025  8c36 f005               	beq okgoto
  2026  8c38 a9a7               	lda #tkthen
  2027  8c3a 20ec96             	jsr synchr
  2028  8c3d a56f               okgoto:	lda facexp
  2029  8c3f d013               	bne docond
  2030  8c41 20c08c             lkelse:	jsr data		; skip to next ":" or end-of-line
  2031  8c44 a000               	ldy #0
  2032  8c46 b183               	lda (txtptr),y
  2033  8c48 f012               	beq rem			; eol, no else-clause
  2034  8c4a 207eb3             	jsr chrget		; is stmt an "else" ?
  2035  8c4d c9e1               	cmp #tkelse
  2036  8c4f d0f0               	bne lkelse		; no, keep looking...
  2037  8c51 207eb3             	jsr chrget		; skip over tkelse
  2038  8c54 2081b3             docond:	jsr chrgot
  2039  8c57 9010               	bcc goto
  2040  8c59 4c8087             	jmp xeqcm3
  2041                          ; -------------------------------------------------------------------------------------------------
  2042                          ; REM
  2043                          
  2044  8c5c 20d18c             rem:	jsr remn		; scan to end of line
  2045  8c5f f062               	beq addon 		; always
  2046                          
  2047  8c61 2081b3             go:	jsr chrgot
  2048  8c64 a9a4               	lda #tkto
  2049  8c66 20ec96             	jsr synchr
  2050                          ; -------------------------------------------------------------------------------------------------
  2051                          ; GOTO - process goto verb
  2052                          
  2053  8c69 20298d             goto:	jsr linget
  2054                          goto0:				; always goto0=goto+3
  2055  8c6c 20d18c             	jsr remn
  2056  8c6f 38                 goto1:	sec
  2057  8c70 a540               	lda curlin
  2058  8c72 e51b               	sbc linnum
  2059  8c74 a541               	lda curlin+1
  2060  8c76 e51c               	sbc linnum+1
  2061  8c78 b00b               	bcs luk4it
  2062  8c7a 98                 	tya
  2063  8c7b 38                 	sec
  2064  8c7c 6583               	adc txtptr
  2065  8c7e a684               	ldx txtptr+1
  2066  8c80 9007               	bcc lukall
  2067  8c82 e8                 	inx
  2068  8c83 b004               	bcs lukall
  2069  8c85 a52d               luk4it:	lda txttab
  2070  8c87 a62e               	ldx txttab+1
  2071  8c89 20fb86             lukall:	jsr fndlnc
  2072  8c8c 9020               	bcc userr
  2073  8c8e a56b               	lda lowtr
  2074  8c90 e901               	sbc #1
  2075  8c92 8583               	sta txtptr
  2076  8c94 a56c               	lda lowtr+1
  2077  8c96 e900               	sbc #0
  2078  8c98 8584               	sta txtptr+1
  2079  8c9a 4cfc8b             	jmp runmod         	; put into run mode
  2080                          ; -------------------------------------------------------------------------------------------------
  2081                          ; RETURN - process return verb
  2082                          
  2083  8c9d d02e               return bne addrts
  2084  8c9f a9ff               	lda #$ff		; improbable offset(hi)
  2085  8ca1 8553               	sta forpnt+1
  2086  8ca3 20ca87             	jsr fndfor
  2087  8ca6 9a                 	txs
  2088  8ca7 c98d               	cmp #tkgosu
  2089  8ca9 f008               	beq retu1
  2090  8cab a22e               	ldx #errrg
  2091  8cad 2c                 	!byte $2c		; eat the next two bytes
  2092  8cae a238               userr:	ldx #errus
  2093  8cb0 4c2685             	jmp error
  2094                          
  2095  8cb3 68                 retu1:	pla
  2096  8cb4 68                 	pla
  2097  8cb5 8540               	sta curlin
  2098  8cb7 68                 	pla
  2099  8cb8 8541               	sta curlin+1
  2100  8cba 68                 	pla
  2101  8cbb 8583               	sta txtptr
  2102  8cbd 68                 	pla
  2103  8cbe 8584               	sta txtptr+1
  2104                          ; -------------------------------------------------------------------------------------------------
  2105                          ; DATA
  2106                          
  2107  8cc0 20ce8c             data:	jsr datan
  2108  8cc3 98                 addon:	tya
  2109  8cc4 18                 	clc
  2110  8cc5 6583               	adc txtptr
  2111  8cc7 8583               	sta txtptr
  2112  8cc9 9002               	bcc addrts
  2113  8ccb e684               	inc txtptr+1
  2114  8ccd 60                 addrts:	rts
  2115                          ; -------------------------------------------------------------------------------------------------
  2116                          ; datan, remn
  2117                          
  2118  8cce a23a               datan:	ldx #':'
  2119  8cd0 2c                 	!byte $2c		; eat the next two bytes
  2120  8cd1 a200               remn:	ldx #0
  2121  8cd3 860c               remn1:	stx charac
  2122  8cd5 a000               	ldy #0
  2123  8cd7 840d               	sty endchr
  2124  8cd9 a50d               exchqt:	lda endchr
  2125  8cdb a60c               	ldx charac
  2126  8cdd 850c               	sta charac
  2127  8cdf 860d               	stx endchr
  2128  8ce1 b183               remer:	lda (txtptr),y
  2129  8ce3 f00b               	beq remtxt
  2130  8ce5 c50d               	cmp endchr
  2131  8ce7 f007               	beq remtxt
  2132  8ce9 c8                 	iny
  2133  8cea c922               	cmp #$22 ; "
  2134  8cec d0f3               	bne remer
  2135  8cee f0e9               	beq exchqt		; always
  2136  8cf0 60                 remtxt:	rts
  2137                          ; -------------------------------------------------------------------------------------------------
  2138                          ; TRAP
  2139                          
  2140  8cf1 20919c             trap:	jsr errdir		; no direct mode allowed
  2141  8cf4 2081b3             	jsr chrgot		; look for argument
  2142  8cf7 f007               	beq trap1		; null means no arg.
  2143  8cf9 207bae             	jsr getpin		; get what should be a line number
  2144  8cfc 8c9602             	sty trapno		; lo byte of argument
  2145  8cff 2c                 	!byte $2c		; eat 2
  2146  8d00 a9ff               trap1:	lda #$ff		; flag no trap
  2147  8d02 8d9702             	sta trapno+1
  2148  8d05 60                 	rts
  2149                          ; -------------------------------------------------------------------------------------------------
  2150                          ; ON GOTO
  2151                          
  2152  8d06 206cae             ongoto:	jsr getbyt
  2153  8d09 48                 	pha
  2154  8d0a c98d               	cmp #tkgosu
  2155  8d0c f007               	beq onglop
  2156  8d0e c989               	cmp #tkgoto
  2157  8d10 f003               	beq onglop		; if goto
  2158  8d12 4c0e97             snerr3:	jmp snerr		; -> syntax error, ready
  2159                          
  2160  8d15 c673               onglop:	dec faclo
  2161  8d17 d004               	bne onglp1
  2162  8d19 68                 	pla
  2163  8d1a 4c8287             	jmp xeqcm2
  2164                          
  2165  8d1d 207eb3             onglp1:	jsr chrget
  2166  8d20 20298d             	jsr linget
  2167  8d23 c92c               	cmp #','
  2168  8d25 f0ee               	beq onglop
  2169  8d27 68                 	pla
  2170  8d28 60                 ongrts:	rts
  2171                          ; -------------------------------------------------------------------------------------------------
  2172                          ; linget
  2173  8d29 a200               linget:	ldx #0
  2174  8d2b 861b               	stx linnum
  2175  8d2d 861c               	stx linnum+1
  2176  8d2f b0f7               morlin:	bcs ongrts
  2177  8d31 e92f               	sbc #$2f
  2178  8d33 850c               	sta charac
  2179  8d35 a51c               	lda linnum+1
  2180  8d37 8522               	sta index
  2181  8d39 c919               	cmp #25
  2182  8d3b b0d5               	bcs snerr3
  2183  8d3d a51b               	lda linnum
  2184  8d3f 0a                 	asl
  2185  8d40 2622               	rol index
  2186  8d42 0a                 	asl
  2187  8d43 2622               	rol index
  2188  8d45 651b               	adc linnum
  2189  8d47 851b               	sta linnum
  2190  8d49 a522               	lda index
  2191  8d4b 651c               	adc linnum+1
  2192  8d4d 851c               	sta linnum+1
  2193  8d4f 061b               	asl linnum
  2194  8d51 261c               	rol linnum+1
  2195  8d53 a51b               	lda linnum
  2196  8d55 650c               	adc charac
  2197  8d57 851b               	sta linnum
  2198  8d59 9002               	bcc nxtlgc
  2199  8d5b e61c               	inc linnum+1
  2200  8d5d 207eb3             nxtlgc:	jsr chrget
  2201  8d60 4c2f8d             	jmp morlin
  2202                          
  2203  8d63 d0ad               ressnr:	bne snerr3
  2204                          ; -------------------------------------------------------------------------------------------------
  2205                          ; LET
  2206  8d65 208788             let:	jsr sav73
  2207  8d68 a9b2               	lda #tkequl
  2208  8d6a 20ec96             	jsr synchr
  2209  8d6d a512               	lda intflg
  2210  8d6f 48                 	pha
  2211  8d70 a511               	lda valtyp
  2212  8d72 48                 	pha
  2213  8d73 207a95             	jsr frmevl
  2214  8d76 68                 	pla
  2215  8d77 2a                 	rol
  2216  8d78 209dae             	jsr chkval
  2217  8d7b d018               	bne copstr
  2218  8d7d 68                 	pla
  2219  8d7e 1012               qintgr:	bpl copflt
  2220  8d80 2010a1             	jsr round
  2221  8d83 208c9a             	jsr ayint
  2222  8d86 a000               	ldy #0
  2223  8d88 a572               	lda facmo
  2224  8d8a 9152               	sta (forpnt),y
  2225  8d8c c8                 	iny
  2226  8d8d a573               	lda faclo
  2227  8d8f 9152               	sta (forpnt),y
  2228  8d91 60                 	rts
  2229                          
  2230  8d92 4cc3a0             copflt:	jmp movvf
  2231                          
  2232  8d95 68                 copstr:	pla
  2233  8d96 4c39a8             	jmp inpcom
  2234                          ; -------------------------------------------------------------------------------------------------
  2235                          ; RESUME
  2236  8d99 20919c             resume:	jsr errdir		; no direct mode
  2237  8d9c ae9902             	ldx errlin+1		; is there an error to resume fron?
  2238  8d9f e8                 	inx
  2239  8da0 f04c               	beq rescnt		; can't resume!
  2240  8da2 2081b3             	jsr chrgot		; look for arguments
  2241  8da5 f027               	beq resswp		; no arg's...restart err'd line
  2242  8da7 901a               	bcc resnum		; numeric argument
  2243  8da9 c982               	cmp #tknext		; only other choice is 'next'
  2244  8dab d0b6               gooos:	bne ressnr		; if not, syntax error
  2245                          
  2246  8dad 20ce8d             	jsr resswp		; resume execution with next stm't
  2247  8db0 a000               	ldy #0
  2248  8db2 b183               	lda (txtptr),y
  2249  8db4 d007               	bne resum2 		; must be a ':'
  2250  8db6 c8                 	iny			; must be a null,get next line
  2251  8db7 203b87             	jsr sav42
  2252  8dba 20c38c             	jsr addon
  2253  8dbd 207eb3             resum2:	jsr chrget		; skip over this character, into body of statement
  2254  8dc0 4cc08c             	jmp data		; advance until null or ':', then rts
  2255                          
  2256  8dc3 207bae             resnum:	jsr getpin		; get address
  2257  8dc6 851c               	sta linnum+1
  2258  8dc8 20dd8d             	jsr resend
  2259  8dcb 4c858c             	jmp luk4it
  2260                          
  2261  8dce a201               resswp:	ldx #1
  2262  8dd0 bd9802             resum0:	lda errlin,x
  2263  8dd3 9540               	sta curlin,x
  2264  8dd5 bd9a02             	lda errtxt,x
  2265  8dd8 9583               	sta txtptr,x
  2266  8dda ca                 	dex
  2267  8ddb 10f3               	bpl resum0
  2268  8ddd a2ff               resend:	ldx #$ff
  2269  8ddf 860f               	stx xcnt
  2270  8de1 8e9802             	stx errlin
  2271  8de4 8e9902             	stx errlin+1		; flag 'no further resumes until next error'
  2272  8de7 ae9d02             	ldx tmptrp		; restore trap line to allow traps again
  2273  8dea 8e9702             	stx trapno+1
  2274  8ded 60                 	rts
  2275                          
  2276  8dee a254               rescnt:	ldx #errcr
  2277  8df0 4c2685             	jmp error
  2278                          ; -------------------------------------------------------------------------------------------------
  2279                          ; dispose
  2280                          
  2281  8df3 c981               dispos:	cmp #tkfor
  2282  8df5 f004               	beq dispo0
  2283  8df7 c98d               	cmp #tkgosu
  2284  8df9 d0b0               	bne gooos 		; not next or gosub is syntax error
  2285  8dfb 8d9f02             dispo0:	sta oldtok
  2286  8dfe 20919c             	jsr errdir
  2287  8e01 ba                 	tsx
  2288  8e02 e8                 	inx
  2289  8e03 e8                 	inx  			; look past return to newstt
  2290  8e04 8a                 	txa
  2291  8e05 a8                 	tay
  2292  8e06 98                 dispo1:	tya			; y==>x
  2293  8e07 aa                 	tax
  2294  8e08 c0ff               	cpy #$ff		; stack empty?
  2295  8e0a f038               	beq diserr		; yes...
  2296  8e0c bd0101             	lda stack+1,x
  2297  8e0f c981               	cmp #tkfor
  2298  8e11 d006               	bne dispo2
  2299  8e13 8a                 	txa 			; stack entry is a for loop, 19 bytes.
  2300  8e14 6912               	adc #18			; + 1 in carry
  2301  8e16 4c1d8e             	jmp dispo3
  2302                          
  2303  8e19 8a                 dispo2:	txa			; stack entry is gosub, 5 bytes.
  2304  8e1a 18                 	clc
  2305  8e1b 6907               	adc #7
  2306                          
  2307  8e1d b025               dispo3:	bcs diserr		; stack underflow...
  2308  8e1f a8                 	tay
  2309  8e20 bd0101             	lda stack+1,x
  2310  8e23 cd9f02             	cmp oldtok
  2311  8e26 d0de               	bne dispo1		; keep looking
  2312  8e28 f003               	beq dispo5
  2313  8e2a ae9e02             dispo4:	ldx dsptmp
  2314  8e2d bd0001             dispo5:	lda stack,x 		; shift stack down
  2315  8e30 990001             	sta stack,y
  2316  8e33 88                 	dey
  2317  8e34 ca                 	dex
  2318  8e35 8e9e02             	stx dsptmp		; done when x=s
  2319  8e38 ba                 	tsx
  2320  8e39 ec9e02             	cpx dsptmp
  2321  8e3c d0ec               	bne dispo4
  2322  8e3e 98                 	tya			; s <== y
  2323  8e3f aa                 	tax
  2324  8e40 9a                 	txs
  2325  8e41 4c7eb3             	jmp chrget		; advance past modifier, do rts
  2326  8e44 a256               diserr:	ldx #errdi
  2327  8e46 4c2685             	jmp error
  2328                          .end
  2329                          
  2330                          ; ****************************************** BVERBS2 **********************************************
  2331                          ; PRINT# - process print# verb
  2332                          
  2333  8e49 204f8e             printn:	jsr cmd			; docmd
  2334  8e4c 4c238f             	jmp iodone		; release channel
  2335                          ; -------------------------------------------------------------------------------------------------
  2336                          ; CMD - process cmd verb
  2337                          
  2338  8e4f 206cae             cmd:	jsr getbyt
  2339  8e52 f003               	beq cmnd2		; if no more
  2340  8e54 20ea96             	jsr chkcom		; comma after channel#
  2341  8e57 08                 cmnd2:	php			; save status
  2342  8e58 48                 	pha
  2343  8e59 8e5802             	stx dolu		;  x=la
  2344  8e5c 204595             	jsr patch1		; check and open output chn*****clr dsk status********
  2345  8e5f 851a               	sta channl		; set chn returned from chkout
  2346  8e61 68                 	pla
  2347  8e62 28                 	plp			; get status back
  2348  8e63 4c6c8e             	jmp print		; process reset of print stm
  2349                          
  2350  8e66 20abae             strdon:	jsr strprt
  2351  8e69 2081b3             newchr:	jsr chrgot		; reget last char
  2352                          ; -------------------------------------------------------------------------------------------------
  2353                          ; PRINT - process print verb
  2354                          
  2355  8e6c f022               print:	beq ocrlf		; terminator so type cr/lf
  2356                          ; here after seeing tab(x) or , or in which ase a terminator does not mean type a cr/lf but just rts.
  2357  8e6e f031               printc:	beq ocrlfx
  2358  8e70 c9a3               	cmp #tktab
  2359  8e72 f03e               	beq taber		; if tab function
  2360  8e74 c9a6               	cmp #tkspc
  2361  8e76 18                 	clc
  2362  8e77 f039               	beq taber		; if space
  2363  8e79 c92c               	cmp #','
  2364  8e7b f025               	beq comprt		; if comma
  2365  8e7d c93b               	cmp #';'
  2366  8e7f f053               	beq notabr		; if semicolon
  2367  8e81 207a95             	jsr frmevl		; evaluate the formula
  2368  8e84 2411               	bit valtyp
  2369  8e86 30de               	bmi strdon		; if string
  2370  8e88 20d0a2             	jsr outfac
  2371  8e8b 20bfae             	jsr ospc		; output a space
  2372  8e8e d0d9               	bne newchr		; always goes
  2373                          
  2374                          ; entry to process carriage return and optional line feed
  2375  8e90 a90d               ocrlf:	lda #cr
  2376  8e92 20cbae             	jsr ochr
  2377  8e95 ad5802             	lda dolu
  2378  8e98 1005               	bpl crfin		; cr only
  2379  8e9a a90a               	lda #lf			; line feed
  2380  8e9c 20cbae             	jsr ochr
  2381  8e9f 49ff               crfin:	eor #255
  2382  8ea1 60                 ocrlfx:	rts
  2383                          
  2384  8ea2 38                 comprt:	sec			; set flag to read cursor position
  2385  8ea3 20f0ff             	jsr plot		; get cursor position
  2386  8ea6 98                 	tya
  2387  8ea7 38                 	sec
  2388  8ea8 e90a               morco1:	sbc #clmwid
  2389  8eaa b0fc               	bcs morco1
  2390  8eac 49ff               	eor #255
  2391  8eae 6901               	adc #1
  2392  8eb0 d018               	bne aspac		; always
  2393                          
  2394  8eb2 08                 taber:	php			; spc or tab function
  2395  8eb3 38                 	sec
  2396  8eb4 20f0ff             	jsr plot
  2397  8eb7 8c5502             	sty trmpos
  2398  8eba 2069ae             	jsr gtbytc
  2399  8ebd c929               	cmp #')'
  2400  8ebf d019               	bne snerr2
  2401  8ec1 28                 	plp
  2402  8ec2 9007               	bcc xspac
  2403  8ec4 8a                 	txa
  2404  8ec5 ed5502             	sbc trmpos
  2405  8ec8 900a               	bcc notabr
  2406  8eca aa                 aspac:	tax
  2407  8ecb e8                 xspac:	inx
  2408  8ecc ca                 xspac2:	dex
  2409  8ecd f005               	beq notabr		; if spacing complete
  2410  8ecf 20bfae             	jsr ospc
  2411  8ed2 d0f8               	bne xspac2
  2412                          
  2413  8ed4 207eb3             notabr:	jsr chrget
  2414  8ed7 4c6e8e             	jmp printc
  2415                          
  2416  8eda 4c0e97             snerr2:	jmp snerr		; -> syntax error, ready
  2417                          ; -------------------------------------------------------------------------------------------------
  2418                          ; GET command
  2419                          ;   get from keyboard or get# from channel.
  2420                          ;   the value of an ascii 0 for a string value is the null string.  the value of an ascii 0 for
  2421                          ;   a numeric value is also 0.  get is not allowed in direct mode.
  2422                          
  2423  8edd 20919c             get:	jsr errdir		; not allowed in direct mode
  2424  8ee0 2081b3             	jsr chrgot		; reget first char
  2425  8ee3 c923               	cmp #'#'		; was it a get# ?
  2426  8ee5 d00e               	bne get010		; no...get from keyboard
  2427  8ee7 2069ae             	jsr gtbytc		; value for channel#...returned in .x
  2428  8eea 20ea96             	jsr chkcom		; must be comma before variable list
  2429  8eed 2007b3             	jsr oldclr		; clear disk status for inputn & get
  2430  8ef0 2036b5             	jsr chkin
  2431  8ef3 851a               	sta channl		; new active channel
  2432                          
  2433                          ; this routine puts a zero as the 2nd character in the buffer and points (x,y) at it.
  2434                          ; this forces a call to getin by inloop the first time and also acts as a terminator.
  2435  8ef5 a487               get010:	ldy buffpt+1 		; buffpt points to buffer
  2436  8ef7 a686               	ldx buffpt
  2437  8ef9 e8                 	inx			; increment to point to 2nd element
  2438  8efa d001               	bne get020
  2439  8efc c8                 	iny
  2440  8efd 8622               get020:	stx index1		; use this as index
  2441  8eff 8423               	sty index1+1
  2442  8f01 a000               	ldy #0
  2443  8f03 98                 	tya			; 0 in .a
  2444  8f04 9122               	sta (index1),y		; to make buffer terminator
  2445  8f06 a423               	ldy index1+1		; pass pointer in (.x,.y)
  2446  8f08 a940               	lda #64			; inpflg will be get
  2447  8f0a 20b68f             	jsr inpco1		; get and fill variable list...
  2448  8f0d a61a               	ldx channl		; get from keyboard?
  2449  8f0f d014               	bne iorele		; no...close channel
  2450  8f11 60                 	rts			; yes...done
  2451                          ; -------------------------------------------------------------------------------------------------
  2452                          ; INPUT#
  2453  8f12 206cae             inputn:	jsr getbyt		; must have channel #
  2454  8f15 20ea96             	jsr chkcom		; comma after channel #
  2455  8f18 2007b3             	jsr oldclr		; clear disk status for inputn & get
  2456  8f1b 2036b5             	jsr chkin
  2457  8f1e 851a               	sta channl
  2458  8f20 203f8f             	jsr notqti
  2459                          ; close current working channel
  2460  8f23 a51a               iodone:	lda channl
  2461  8f25 20ccff             iorele:	jsr clrch
  2462  8f28 a200               	ldx #0
  2463  8f2a 861a               	stx channl
  2464  8f2c 8e5802             	stx dolu
  2465  8f2f 60                 	rts
  2466                          ; -------------------------------------------------------------------------------------------------
  2467                          ; INPUT
  2468                          
  2469  8f30 c922               input:	cmp #$22 ; "		; prompt string?
  2470  8f32 d00b               	bne notqti		; no...
  2471  8f34 20a196             	jsr strtxt		; yes...print it out
  2472  8f37 a93b               	lda #';'
  2473  8f39 20ec96             	jsr synchr		; semi-c as delimeter
  2474  8f3c 20abae             	jsr strprt
  2475  8f3f 20919c             notqti:	jsr errdir
  2476                          
  2477  8f42 20728f             getagn:	jsr qinlin
  2478  8f45 a51a               	lda channl
  2479  8f47 f00d               	beq bufful
  2480  8f49 2019b5             	jsr readst		; get i/o status byte
  2481  8f4c 2903               	and #3			; ***stop for timeouts***
  2482  8f4e f006               	beq bufful		; good input
  2483  8f50 20238f             	jsr iodone		; bad input
  2484  8f53 4cc08c             	jmp data		; skip rest of this statement
  2485                          
  2486  8f56 a000               bufful:	ldy #0
  2487  8f58 b122               	lda (index1),y		; anything in buffer?
  2488  8f5a f006               	beq buffu2
  2489                          
  2490                          ; input ready to process
  2491                          ; point at comma before buffer
  2492  8f5c 206e9d             buffu1:	jsr sav75
  2493  8f5f 4cb48f             	jmp inpcon
  2494                          
  2495                          ; buffer was empty
  2496                          ; if from device, try again if not eoi
  2497                          ; otherwise default all variables
  2498  8f62 a51a               buffu2:	lda channl
  2499  8f64 d003               	bne *+5
  2500  8f66 4cc08c             	jmp data		; from keyboard, skip rest of stmt
  2501  8f69 2019b5             	jsr readst		; from device, check for eoi
  2502  8f6c 2940               	and #$40
  2503  8f6e f0d2               	beq getagn		; no eoi, was only a cr
  2504  8f70 d0ea               	bne buffu1		; eoi, fill with null vals
  2505                          
  2506  8f72 a51a               qinlin:	lda channl 		; keyboard/crt?
  2507  8f74 d006               	bne ginlin		; no...
  2508  8f76 20c9ae             	jsr outqst		; yes..prompt
  2509  8f79 20bfae             	jsr ospc
  2510  8f7c 4cc186             ginlin:	jmp inlin
  2511                          ; -------------------------------------------------------------------------------------------------
  2512                          ; find data
  2513                          ;   search is made by using the execution code for data	to skip over statments.  the start word of
  2514                          ;   each statement is compared with 'datatk'. each new line number is stored in 'datlin' so that if
  2515                          ;   an error occurs while reading data the error msg can give the line # of the ill-formatted data.
  2516                          
  2517  8f7f 20ce8c             datlop:	jsr datan
  2518  8f82 c8                 	iny
  2519  8f83 aa                 	tax
  2520  8f84 d01a               	bne nowlin
  2521  8f86 b183               	lda (txtptr),y		; look for null links
  2522  8f88 d00a               	bne dtlp0
  2523  8f8a c8                 	iny
  2524  8f8b b183               	lda (txtptr),y
  2525  8f8d d006               	bne dtlp1		; if no error
  2526  8f8f a230               	ldx #errod
  2527  8f91 4c2685             	jmp error
  2528                          
  2529  8f94 c8                 dtlp0:	iny
  2530  8f95 c8                 dtlp1:	iny			; point stored stmt to line no.
  2531  8f96 b183               	lda (txtptr),y
  2532  8f98 8547               	sta datlin
  2533  8f9a c8                 	iny
  2534  8f9b b183               	lda (txtptr),y
  2535  8f9d c8                 	iny
  2536  8f9e 8548               	sta datlin+1
  2537                          
  2538  8fa0 20c38c             nowlin:	jsr addon
  2539  8fa3 2081b3             	jsr chrgot
  2540  8fa6 aa                 	tax
  2541  8fa7 e083               	cpx #tkdata
  2542  8fa9 d0d4               	bne datlop
  2543  8fab f04f               	beq datbk1
  2544                          ; -------------------------------------------------------------------------------------------------
  2545                          ; READ
  2546                          ;   in the processing of data and read statements
  2547                          ;   one -> points to the data (ie, the #s being fetched)
  2548                          ;   and another points to the list of variables.
  2549                          
  2550                          ;   the -> into the data always starts pointing to a terminator -- a ,  or eol
  2551                          ;   at this point txtptr points to listo of variables and (y,x) points to data or input line.
  2552                          
  2553                          ;   note, since both data statements and the input buffer are in the text bank, the bank for
  2554                          ;   indirection and the text pointer, txtptr, is always text.
  2555                          
  2556  8fad a649               read:	ldx datptr
  2557  8faf a44a               	ldy datptr+1
  2558  8fb1 a998               	lda #$98
  2559  8fb3 2c                 	!byte $2c		; eat the next two bytes
  2560  8fb4 a900               inpcon:	lda #0
  2561  8fb6 8515               inpco1:	sta inpflg
  2562  8fb8 864b               	stx inpptr
  2563  8fba 844c               	sty inpptr+1
  2564  8fbc 208788             inloop:	jsr sav73
  2565  8fbf a583               	lda txtptr
  2566  8fc1 a484               	ldy txtptr+1
  2567  8fc3 8555               	sta vartxt
  2568  8fc5 8456               	sty vartxt+1
  2569  8fc7 a64b               	ldx inpptr
  2570  8fc9 a44c               	ldy inpptr+1
  2571  8fcb 8683               	stx txtptr
  2572  8fcd 8484               	sty txtptr+1
  2573  8fcf 2081b3             	jsr chrgot
  2574  8fd2 d028               	bne datbk1
  2575  8fd4 2415               	bit inpflg
  2576  8fd6 5013               	bvc qdata
  2577  8fd8 2024b5             	jsr getin
  2578  8fdb 206e9d             	jsr sav75
  2579  8fde 8622               	stx index1
  2580  8fe0 8423               	sty index1+1
  2581  8fe2 a001               	ldy #1
  2582  8fe4 9122               	sta (index1),y
  2583  8fe6 a423               	ldy index1+1
  2584  8fe8 4cf88f             	jmp datbk
  2585  8feb 3092               qdata:	bmi datlop
  2586  8fed a51a               	lda channl
  2587  8fef d003               	bne getnth
  2588  8ff1 20c9ae             	jsr outqst
  2589  8ff4 20728f             getnth:	jsr qinlin
  2590  8ff7 aa                 	tax
  2591  8ff8 8683               datbk:	stx txtptr
  2592  8ffa 8484               	sty txtptr+1
  2593  8ffc 207eb3             datbk1:	jsr chrget
  2594  8fff 2411               	bit valtyp
  2595  9001 1035               	bpl numins
  2596  9003 2415               	bit inpflg
  2597  9005 5009               	bvc setqut
  2598  9007 e8                 	inx
  2599  9008 8683               	stx txtptr
  2600  900a a900               	lda #0
  2601  900c 850c               	sta charac
  2602  900e f00c               	beq resetc
  2603  9010 850c               setqut:	sta charac
  2604  9012 c922               	cmp #$22 ; "
  2605  9014 f007               	beq nowget
  2606  9016 a93a               	lda #':'
  2607  9018 850c               	sta charac
  2608  901a a92c               	lda #','
  2609  901c 18                 resetc:	clc
  2610  901d 850d               nowget:	sta endchr
  2611  901f 202e90             	jsr sav30
  2612  9022 2024a7             	jsr strlt2
  2613  9025 2052aa             	jsr st2txt
  2614  9028 2039a8             	jsr inpcom
  2615  902b 4c4090             	jmp strdn2
  2616  902e a583               sav30:	lda txtptr
  2617  9030 a484               	ldy txtptr+1
  2618  9032 6900               	adc #0
  2619  9034 9001               	bcc nowge1
  2620  9036 c8                 	iny
  2621  9037 60                 nowge1:	rts
  2622                          
  2623  9038 20f1a1             numins:	jsr fin
  2624  903b a512               	lda intflg
  2625  903d 207e8d             	jsr qintgr
  2626  9040 2081b3             strdn2:	jsr chrgot
  2627  9043 f004               	beq trmok
  2628  9045 c92c               	cmp #','
  2629  9047 d01b               	bne trmnok
  2630                          
  2631  9049 a583               trmok:	lda txtptr
  2632  904b a484               	ldy txtptr+1
  2633  904d 854b               	sta inpptr
  2634  904f 844c               	sty inpptr+1
  2635  9051 a555               	lda vartxt
  2636  9053 a456               	ldy vartxt+1
  2637  9055 8583               	sta txtptr
  2638  9057 8484               	sty txtptr+1
  2639  9059 2081b3             	jsr chrgot
  2640  905c f02e               	beq endvar
  2641  905e 20ea96             	jsr chkcom
  2642  9061 4cbc8f             	jmp inloop
  2643                          
  2644                          ; here when the data that was typed in or in 'data' statements is improperly formatted.
  2645                          ; for 'input' we start again.
  2646                          ; for 'read' we give a syntax errort the data line.
  2647  9064 a515               trmnok:	lda inpflg
  2648  9066 f00d               	beq trmno1		; if input try again
  2649  9068 1008               	bpl snerr6		; get stmt, issue syntax err
  2650                          ;	bmi getdtl
  2651                          ;	ldy #255		; make it look direct
  2652                          ;	bne stcurl		; always goes
  2653  906a a547               getdtl:	lda datlin		; get data line number
  2654  906c a448               	ldy datlin+1
  2655  906e 8540               stcurl:	sta curlin		; make it current line
  2656  9070 8441               	sty curlin+1
  2657  9072 4c0e97             snerr6:	jmp snerr		; -> syntax error, ready
  2658                          
  2659  9075 a51a               trmno1:	lda channl		; if not terminal, give bad data
  2660  9077 f005               	beq doagin
  2661  9079 a246               	ldx #errbd
  2662  907b 4c2685             	jmp error
  2663                          
  2664  907e a220               doagin:	ldx #tryagn
  2665  9080 20d5a2             	jsr msg			; print '?redo from start'
  2666  9083 a544               	lda oldtxt		; -> at start of this current line
  2667  9085 a445               	ldy oldtxt+1
  2668  9087 8583               	sta txtptr
  2669  9089 8484               	sty txtptr+1
  2670  908b 60                 	rts			; go to newstt
  2671                          
  2672  908c a54b               endvar:	lda inpptr
  2673  908e a44c               	ldy inpptr+1
  2674  9090 a615               	ldx inpflg
  2675  9092 1005               	bpl vary0
  2676  9094 8549               	sta datptr
  2677  9096 844a               	sty datptr+1
  2678  9098 60                 inprts:	rts
  2679                          
  2680  9099 a000               vary0:	ldy #0
  2681  909b b14b               	lda (inpptr),y
  2682  909d f0f9               	beq inprts
  2683  909f a51a               	lda channl
  2684  90a1 d0f5               	bne inprts
  2685  90a3 a21e               	ldx #exignt
  2686  90a5 4cd5a2             	jmp msg
  2687                          ; -------------------------------------------------------------------------------------------------
  2688                          ; SYS command
  2689                          
  2690  90a8 207bae             csys:	jsr getpin		; get positive integer
  2691  90ab ad40de             	lda via2+prb		; get MMU reg
  2692  90ae 290f               	and #%00001111		; isolate RAM0 bank
  2693  90b0 48                 	pha			; save
  2694  90b1 a9f0               	lda #%11110000		; clear RAM0 bank bits# 0-3
  2695  90b3 2d40de             	and via2+prb
  2696  90b6 0d5702             	ora dfbank		
  2697  90b9 8d40de             	sta via2+prb 		; set RAM0 bank
  2698  90bc a990               	lda #>csysrz		; push return address
  2699  90be 48                 	pha
  2700  90bf a9c4               	lda #<csysrz
  2701  90c1 48                 	pha
  2702  90c2 6c1b00             	jmp (poker)
  2703                          csysrz=*-1
  2704  90c5 68                 	pla
  2705  90c6 8d5b02             	sta tttemp
  2706  90c9 a9f0               	lda #%11110000		; clear RAM0 bank bits# 0-3
  2707  90cb 2d40de             	and via2+prb
  2708  90ce 0d5b02             	ora tttemp
  2709  90d1 8d40de             	sta via2+prb		; restore RAM0 bank
  2710  90d4 60                 	rts
  2711                          ; -------------------------------------------------------------------------------------------------
  2712                          ; DIM
  2713  90d5 20ea96             dim3:	jsr chkcom
  2714                          
  2715  90d8 aa                 dim:	tax
  2716  90d9 20c698             	jsr ptrgt1
  2717  90dc 2081b3             	jsr chrgot
  2718  90df d0f4               	bne dim3
  2719  90e1 60                 	rts
  2720                          ; -------------------------------------------------------------------------------------------------
  2721                          ; DEFFN
  2722                          
  2723  90e2 20a39c             defn:	jsr getfnm
  2724  90e5 20919c             	jsr errdir
  2725  90e8 20e796             	jsr chkopn
  2726  90eb a980               	lda #128
  2727  90ed 8514               	sta subflg
  2728  90ef 20c198             	jsr ptrget
  2729  90f2 209aae             	jsr chknum
  2730  90f5 20e496             	jsr chkcls
  2731  90f8 a9b2               	lda #tkequl		; must have equal token
  2732  90fa 20ec96             	jsr synchr
  2733  90fd a551               	lda varpnt+2
  2734  90ff 48                 	pha
  2735  9100 a550               	lda varpnt+1
  2736  9102 48                 	pha
  2737  9103 a54f               	lda varpnt
  2738  9105 48                 	pha
  2739  9106 a584               	lda txtptr+1
  2740  9108 48                 	pha
  2741  9109 a583               	lda txtptr
  2742  910b 48                 	pha
  2743  910c 20c08c             	jsr data
  2744  910f 4c1d9d             	jmp deffin
  2745                          ; -------------------------------------------------------------------------------------------------
  2746                          ; POKE
  2747                          
  2748  9112 2060ae             poke:	jsr getnum
  2749  9115 ad40de             	lda via2+prb		; get MMU reg
  2750  9118 48                 	pha			; save
  2751  9119 29f0               	and #%11110000		; clear RAM0 bank bits# 0-3
  2752  911b 0d5702             	ora dfbank		
  2753  911e 8d40de             	sta via2+prb 		; set default RAM0 bank
  2754  9121 a000               	ldy #0
  2755  9123 8a                 	txa
  2756  9124 911b               	sta (poker),y
  2757  9126 68                 	pla
  2758  9127 8d40de             	sta via2+prb		; restore RAM0 bank
  2759  912a 60                 	rts
  2760                          ; -------------------------------------------------------------------------------------------------
  2761                          ; WAIT
  2762                          
  2763  912b 2060ae             fnwait:	jsr getnum
  2764  912e 8e5502             	stx andmsk
  2765  9131 a200               	ldx #0
  2766  9133 2081b3             	jsr chrgot
  2767  9136 f003               	beq stordo
  2768  9138 2063ae             	jsr combyt
  2769  913b 8e5602             stordo:	stx eormsk
  2770  913e ad40de             	lda via2+prb		; get MMU reg
  2771  9141 48                 	pha			; save
  2772  9142 29f0               	and #%11110000		; clear RAM0 bank bits# 0-3
  2773  9144 0d5702             	ora dfbank		
  2774  9147 8d40de             	sta via2+prb 		; set default RAM0 bank
  2775  914a a000               	ldy #0
  2776  914c b11b               waiter:	lda (poker),y
  2777  914e 4d5602             	eor eormsk
  2778  9151 2d5502             	and andmsk
  2779  9154 f0f6               	beq waiter
  2780  9156 68                 	pla
  2781  9157 8d40de             	sta via2+prb		; restore RAM0 bank
  2782  915a 60                 	rts
  2783                          ; -------------------------------------------------------------------------------------------------
  2784                          ; KEY processor:   key [ key number , string ]
  2785                          
  2786  915b d004               fkey:	bne key20
  2787  915d a000               	ldy #0			; no params => list all keys
  2788  915f f026               	beq keygo		; always
  2789                          
  2790  9161 206cae             key20:	jsr getbyt		; .x := positive byte integer
  2791  9164 8a                 	txa
  2792  9165 d003               	bne key40		; must be non-zero
  2793  9167 4c189b             fcerr3:	jmp fcerr		; -> illegal quantity error, ready
  2794                          
  2795  916a c915               key40:	cmp #21
  2796  916c b0f9               	bcs fcerr3		; must be <= 20
  2797  916e 48                 	pha			; save key number
  2798  916f 20ea96             	jsr chkcom
  2799  9172 209291             	jsr sav13
  2800  9175 8562               	sta highds		; set up string descriptor
  2801  9177 a522               	lda index1
  2802  9179 a623               	ldx index1+1
  2803  917b a424               	ldy index1+2
  2804  917d 8563               	sta highds+1
  2805  917f 8664               	stx highds+2
  2806  9181 8465               	sty highds+3
  2807  9183 68                 	pla
  2808  9184 a8                 	tay			; .y := key number
  2809  9185 a962               	lda #<highds		; note hightr must follow highds
  2810                          
  2811  9187 2075ff             keygo:	jsr pgmkey		; do it!
  2812  918a 9005               	bcc bakrts		; if no problem
  2813  918c a234               	ldx #52			; out of memory
  2814  918e 6c8002             	jmp (ierror)
  2815  9191 60                 bakrts:	rts
  2816  9192 207a95             sav13:	jsr frmevl
  2817  9195 4cc0a7             	jmp frestr
  2818                          ; -------------------------------------------------------------------------------------------------
  2819                          ; VERIFY - process verify verb
  2820                          
  2821  9198 a950               cverf:	lda #errvr		; set message table pointer
  2822  919a 48                 	pha
  2823  919b a980               	lda #$80		; set verify flag / basic bank 0
  2824  919d 20d591             	jsr ldver		; load/verify routine
  2825  91a0 f019               	beq cvf1		; if direct mode
  2826  91a2 68                 	pla
  2827  91a3 60                 	rts
  2828                          ; -------------------------------------------------------------------------------------------------
  2829                          ; LOAD - process load verb
  2830                          
  2831  91a4 a900               cload:	lda #0			; set load flag / basic bank 0
  2832  91a6 20d591             	jsr ldver		; load/verify routine
  2833                          
  2834                          ; entry from dload
  2835  91a9 f009               loadck:	beq clf1		; if direct mode
  2836  91ab 208286             	jsr lnkprg		; relink
  2837  91ae 2052ae             	jsr stxtpt		; point txtptr to null byte
  2838  91b1 4c5a8a             	jmp fload		; set stack pointer
  2839                          
  2840  91b4 8631               clf1:	stx vartab		; save new text end
  2841  91b6 8432               	sty vartab+1
  2842  91b8 a94e               	lda #errld		; set message table pointer
  2843  91ba 48                 	pha
  2844                          
  2845  91bb 2019b5             cvf1:	jsr readst		; read status of load/verify
  2846  91be 2910               	and #$10
  2847  91c0 d004               	bne cld2		; if error
  2848  91c2 68                 	pla
  2849  91c3 a918               	lda #msrdy
  2850  91c5 48                 	pha
  2851                          
  2852  91c6 68                 cld2:	pla
  2853  91c7 aa                 	tax
  2854                          
  2855  91c8 20d5a2             cld3:	jsr msg			; output message
  2856  91cb 4c7986             	jmp fini		; relink, set end of text and goto main loop
  2857                          
  2858                          cld4:
  2859  91ce a236               	ldx #errom		; 64k	**** PATCHED by Vossi - CBM had here absolute instead immediate! *** 
  2860  91d0 d0f6               	bne cld3		; always
  2861                          
  2862                          ;   entry from dload
  2863  91d2 48                 loadnp:	pha			; a = 0
  2864  91d3 f004               	beq lvr1		; always
  2865                          
  2866                          ;   entry a = 0 if no verify, <>0 if verify
  2867  91d5 48                 ldver:	pha			; save load/verify flag
  2868  91d6 2020b3             	jsr plsv		; verify entry
  2869                          
  2870  91d9 20e1ff             lvr1:	jsr kstop
  2871  91dc f0fb               	beq lvr1		; debounce
  2872                          
  2873  91de 68                 	pla			; restore flag
  2874  91df a62d               	ldx txttab		; load into text table
  2875  91e1 a42e               	ldy txttab+1
  2876  91e3 2042b5             	jsr load		; request load from kernal
  2877  91e6 b022               	bcs ldsver		; if load/verify error
  2878  91e8 4c9e9c             	jmp tdm        		; get direct mode
  2879                          ; -------------------------------------------------------------------------------------------------
  2880                          ; SAVE - process basic save command.
  2881                          
  2882  91eb 2020b3             csave:	jsr plsv
  2883                          
  2884  91ee a62d               savenp:	ldx txttab		; highds is start vector
  2885  91f0 a42e               	ldy txttab+1
  2886  91f2 a900               	lda #0			; basic bank
  2887  91f4 8662               	stx highds
  2888  91f6 8463               	sty highds+1
  2889  91f8 a631               	ldx vartab
  2890  91fa a432               	ldy vartab+1		; hightr is end vector
  2891  91fc 8665               savenb:	stx hightr
  2892  91fe 8466               	sty hightr+1
  2893  9200 a262               	ldx #<highds
  2894  9202 a065               	ldy #<hightr
  2895  9204 2048b5             	jsr save
  2896  9207 b001               	bcs ldsver		; load/save error
  2897  9209 60                 	rts
  2898                          
  2899  920a 0a                 ldsver:	asl			; double error number
  2900  920b aa                 	tax			; transfer to x
  2901  920c 4c2685             	jmp error		; process error
  2902                          ; -------------------------------------------------------------------------------------------------
  2903                          ; OPEN - process open verb
  2904                          
  2905  920f a200               copen:	ldx #00			; set default parameters
  2906  9211 8689               	stx parsts		; clear status
  2907  9213 8e1002             	stx dosf1l		; set length to zero
  2908  9216 8e2102             	stx dossa		; set secondary address to zero
  2909  9219 e8                 	inx
  2910  921a 8e2002             	stx dosfa		; set device number to one
  2911  921d 206db3             	jsr plsv32
  2912  9220 206cae             	jsr getbyt
  2913  9223 8e1f02             	stx dosla		; set logical file number
  2914  9226 205392             	jsr cops		; get next number if one
  2915  9229 8e2002             	stx dosfa		; save device number
  2916  922c a000               	ldy #0
  2917  922e e003               	cpx #3
  2918  9230 9001               	bcc cop1		; if not iec
  2919  9232 88                 	dey
  2920                          
  2921  9233 8c2102             cop1:	sty dossa		; set default secondary address
  2922  9236 205392             	jsr cops		; get next number if one
  2923  9239 8e2102             	stx dossa		; set secondary address
  2924  923c 2081b3             	jsr chrgot
  2925  923f f006               	beq copx		; if end of statement
  2926  9241 206ab3             	jsr plsv30
  2927  9244 200fb3             	jsr sav77
  2928                          
  2929  9247 2044b3             copx:	jsr plsvx		; set file info
  2930                          
  2931  924a 20ccff             globtt:	jsr clrch		; unlisten
  2932  924d 201db5             	jsr open
  2933  9250 4c1c93             	jmp dcat0		; restore listener,if any
  2934                          
  2935  9253 2081b3             cops:	jsr chrgot
  2936  9256 d005               	bne copg
  2937  9258 68                 	pla			; if end of statement, scrap return...
  2938  9259 68                 	pla			; ...and go off to open it
  2939  925a 4c4792             	jmp copx
  2940  925d 206ab3             copg:	jsr plsv30		; else get next device param and continue
  2941  9260 4c6cae             	jmp getbyt
  2942                          ; -------------------------------------------------------------------------------------------------
  2943                          ; CLOSE - process close verb
  2944                          
  2945  9263 206db3             cclos:	jsr plsv32
  2946  9266 206cae             	jsr getbyt
  2947  9269 8a                 	txa
  2948  926a 4c4eb5             	jmp close
  2949                          ; ****************************************** BVERBS3 **********************************************
  2950                          ; 'basic/dos interface verbs.'
  2951                          ; this set of routines takes tokens and values after the following basic keywords
  2952                          
  2953                          ; dopen,  dclose, record, format, collect, backup, copy
  2954                          ; concat, dsave,  dload,  catlog, rename,  append, scrtch
  2955                          
  2956                          ; it then parses the following line and finds syntax errors, checks for out of range values, and sets
  2957                          ; variables in the zero-page to be passed to the disk message generator (dmg).
  2958                          
  2959                          ; CATALOG-DIRECTORY - catalog a device (==directory)
  2960                          
  2961  926d 20d8ae             dcat:	jsr dospar		; parse the line
  2962  9270 a589               	lda parsts		; check options
  2963  9272 29e6               	and #$e6
  2964  9274 f003               	beq *+5
  2965  9276 4c0e97             	jmp snerr		; -> syntax error, ready
  2966  9279 a001               	ldy #tcat		; table offset
  2967  927b a201               	ldx #1			; just $
  2968  927d a589               	lda parsts		; chk for default
  2969  927f 2911               	and #$11		; no drive?
  2970  9281 f006               	beq dcat2
  2971  9283 4a                 	lsr
  2972  9284 9002               	bcc dcat1		; just drive
  2973  9286 e8                 	inx			; drive and filename
  2974  9287 e8                 	inx
  2975  9288 e8                 dcat1:	inx
  2976  9289 8a                 dcat2:	txa			; a now has length
  2977  928a 209ab1             	jsr sendp		; build
  2978  928d a915               	lda #dosctl
  2979  928f 850f               	sta xcnt		; max lines before prompt
  2980  9291 a060               	ldy #$60		; sa, load floppy
  2981  9293 202793             	jsr ochanl		; open special channel
  2982  9296 a003               	ldy #3			; loop counter
  2983                          ; get length in blocks
  2984  9298 8479               dcat3:	sty t3			; save counter
  2985  929a a20e               	ldx #doslfn
  2986  929c 2036b5             	jsr chkin		; open for input
  2987  929f 202ab5             	jsr basin		; get char
  2988  92a2 857a               	sta t4
  2989  92a4 2019b5             	jsr readst
  2990  92a7 d06b               	bne dcat10		; if bad status
  2991  92a9 202ab5             	jsr basin		; get char
  2992  92ac 857b               	sta t4+1
  2993  92ae 2019b5             	jsr readst
  2994  92b1 d061               	bne dcat10		; if bad status
  2995  92b3 a479               	ldy t3
  2996  92b5 88                 	dey
  2997  92b6 d0e0               	bne dcat3		; if not done
  2998                          ; output blocks number
  2999  92b8 201c93             	jsr dcat0		; clear channel  restore output device
  3000  92bb a67a               	ldx t4
  3001  92bd a57b               	lda t4+1
  3002  92bf 20c6a2             	jsr linprt		; output number
  3003  92c2 a920               	lda #' '
  3004  92c4 2030b5             	jsr bsout		; output a space
  3005                          ; loop reading name and output
  3006  92c7 20ccff             dcat4:	jsr clrch 		; clear channel  default input is disk
  3007  92ca a20e               	ldx #doslfn
  3008  92cc 2036b5             	jsr chkin
  3009  92cf 202ab5             	jsr basin		; get char
  3010  92d2 48                 	pha			; save char
  3011  92d3 2019b5             	jsr readst		; get status
  3012  92d6 d03b               	bne dcat9		; if bad status
  3013  92d8 201c93             	jsr dcat0 		; clear channel  restore output device
  3014  92db 68                 	pla			; get back char
  3015  92dc f005               	beq dcat5		; if eol
  3016  92de 2030b5             	jsr bsout		; echo char
  3017  92e1 90e4               	bcc dcat4		; continue to process name
  3018                          
  3019                          ; here on end of name
  3020  92e3 c60f               dcat5:	dec xcnt		; decrement max lines counter
  3021  92e5 a90d               	lda #cr
  3022  92e7 2030b5             	jsr bsout		; output new line
  3023  92ea 20ccff             	jsr clrch		; close
  3024                          ; check for suspend or halt
  3025  92ed 20e1ff             	jsr kstop		; get status of stop key
  3026  92f0 f022               	beq dcat10		; if stop request
  3027  92f2 a50f               	lda xcnt		; lines
  3028  92f4 d019               	bne dcat8		; if not max lines
  3029  92f6 a915               	lda #dosctl
  3030  92f8 850f               	sta xcnt		; reset counter
  3031  92fa 209e9c             	jsr tstdir    		; don't prompt unless in direct mode
  3032  92fd d010               	bne dcat8
  3033  92ff a61a               	ldx channl    		; or if not writing to screen
  3034  9301 e000               	cpx #0
  3035  9303 d00a               	bne dcat8
  3036  9305 a224               	ldx #mremsg
  3037  9307 20d5a2             	jsr msg			; prompt user
  3038                          ; wait for go
  3039  930a 2024b5             dcat7:	jsr getin		; suspend waiting for key
  3040  930d f0fb               	beq dcat7		; if no key - suspend
  3041                          ; process next
  3042  930f a002               dcat8:	ldy #2			; perform 2 times
  3043  9311 d085               	bne dcat3		; jmp
  3044                          
  3045  9313 68                 dcat9:	pla			; clean up stk
  3046  9314 20ccff             dcat10:	jsr clrch
  3047  9317 a90e               	lda #doslfn
  3048  9319 204eb5             	jsr close		; close special channel
  3049  931c 20ccff             dcat0:	jsr clrch
  3050  931f ae5802             	ldx dolu
  3051  9322 f04b               	beq goorat
  3052  9324 4c3cb5             	jmp chkout
  3053                          ; -------------------------------------------------------------------------------------------------
  3054                          ; open channel 14 for special purposes
  3055                          ;   enter:  .y=sa
  3056                          ;   doslfn = lu
  3057                          ;   dosfa = fa
  3058                          ;   assumes setnam previously called
  3059  9327 ae2002             ochanl:	ldx dosfa
  3060  932a d002               	bne ochl10
  3061  932c a208               	ldx #8			; use default of 8
  3062  932e a90e               ochl10:	lda #doslfn		; lfn
  3063  9330 20baff             	jsr setlfs		; set file parameters
  3064  9333 20ccff             	jsr clrch		; unlisten default out
  3065  9336 4c1db5             	jmp open		; open it...
  3066                          ; -------------------------------------------------------------------------------------------------
  3067                          ; DOPEN code dfn(,t(,r))
  3068                          
  3069  9339 a922               dopen:	lda #$22		; set error flag
  3070  933b 205a93             	jsr sav9
  3071  933e a002               	ldy #topn		; fcb format pointer
  3072  9340 a204               	ldx #4			; normal length
  3073  9342 2489               	bit parsts		; relative record
  3074  9344 500d               	bvc dop2		; if not random access
  3075  9346 a208               	ldx #8			; random access length
  3076  9348 d009               	bne dop2		; alway jump
  3077                          ; -------------------------------------------------------------------------------------------------
  3078                          ; APPEND code
  3079                          
  3080  934a a9e2               append:	lda #$e2		; set error flags
  3081  934c 205a93             	jsr sav9		; chk req'd parms
  3082  934f a003               	ldy #tapn		; tabld index
  3083  9351 a205               	ldx #5			; length
  3084                          
  3085  9353 8a                 dop2:	txa			; set length into a
  3086  9354 209ab1             	jsr sendp
  3087  9357 4c4a92             	jmp globtt
  3088                          
  3089  935a 20daae             sav9	jsr dosprs		; parse the line
  3090  935d 2092b2             	jsr chk6		; chk req'd parms
  3091                          ;  find an available secondary address
  3092  9360 a061               fndsca:	ldy #$61
  3093  9362 c8                 fsca10:	iny
  3094  9363 c06f               	cpy #$6f
  3095  9365 f009               	beq fsca20		; if none available
  3096  9367 208aff             	jsr lkupsa		; get physical unit from secondary
  3097  936a 90f6               	bcc fsca10		; if secondary address used
  3098  936c 8c2102             	sty dossa		; save secondary address
  3099                          
  3100  936f 60                 goorat:	rts			; return .y = sa
  3101                          
  3102  9370 a202               fsca20:	ldx #ms1		; too many files open
  3103  9372 4c2685             	jmp error
  3104                          ; -------------------------------------------------------------------------------------------------
  3105                          ; DCLOSE - close disk file
  3106                          
  3107  9375 a9f3               dclose:	lda #$f3		; set error flags
  3108  9377 20daae             	jsr dosprs		; parse the line
  3109  937a 2007b3             	jsr oldclr
  3110  937d a589               	lda parsts		; any la given?
  3111  937f 2904               	and #$04
  3112  9381 f006               	beq dclall		; no....
  3113  9383 ad1f02             	lda dosla
  3114  9386 4c4eb5             	jmp close		; close file
  3115                          ; -------------------------------------------------------------------------------------------------
  3116                          ; dclall
  3117                          
  3118  9389 ad2002             dclall:	lda dosfa		; get disk #
  3119  938c 4c4b95             	jmp patch3		; close all units*****device in .a only******
  3120                          ; -------------------------------------------------------------------------------------------------
  3121                          ; DSAVE dfn
  3122                          
  3123  938f a966               dsave:	lda #$66		; set error flags
  3124  9391 20daae             	jsr dosprs		; parse the line
  3125  9394 2093b1             	jsr sav20
  3126  9397 4cee91             	jmp savenp
  3127                          ; -------------------------------------------------------------------------------------------------
  3128                          ; DLOAD dfn
  3129                          
  3130  939a a9e6               dload:	lda #$e6		; set error flags
  3131  939c 20daae             	jsr dosprs		; parse the line
  3132  939f 2093b1             	jsr sav20
  3133  93a2 a900               	lda #0			; set load flag
  3134  93a4 20d291             	jsr loadnp		; perform load no parse
  3135  93a7 4ca991             	jmp loadck		; go to load checking
  3136                          ; -------------------------------------------------------------------------------------------------
  3137                          ; BANK dfn
  3138                          
  3139  93aa 206cae             chbank:	jsr getbyt
  3140  93ad e010               	cpx #mxbank		; too large?
  3141  93af b004               	bcs xbkerr
  3142  93b1 8e5702             	stx dfbank
  3143  93b4 60                 bsvrts:	rts
  3144  93b5 4c189b             xbkerr:	jmp    fcerr		; illegal quantity
  3145                          ; -------------------------------------------------------------------------------------------------
  3146                          ; BSAVE dfn
  3147                          
  3148  93b8 a966               bsave:	lda #$66		; std error flag
  3149  93ba a2f8               	ldx #$f8		; auxiliary error flag
  3150  93bc 20dcae             	jsr dosprx		; parse options
  3151  93bf 2093b1             	jsr sav20		; check req params done
  3152                          
  3153  93c2 ad1a02             	lda dosbnk		; bank
  3154  93c5 ae1b02             	ldx dosofl		; start addr
  3155  93c8 ac1c02             	ldy dosofl+1
  3156  93cb 8662               	stx highds
  3157  93cd 8463               	sty highds+1
  3158  93cf ae1d02             	ldx dosofh		; end addr
  3159  93d2 ac1e02             	ldy dosofh+1
  3160  93d5 4cfc91             	jmp savenb
  3161                          ; -------------------------------------------------------------------------------------------------
  3162                          ; BLOAD dfn
  3163                          
  3164  93d8 a9e6               bload:	lda #$e6		; std error flag
  3165  93da a2fc               	ldx #$fc		; aux error flag
  3166  93dc 20dcae             	jsr dosprx		; parse options
  3167  93df 2093b1             	jsr sav20
  3168                          
  3169  93e2 ad1a02             	lda dosbnk		; bit7 is clear(=>load)
  3170  93e5 18                 	clc
  3171  93e6 ae1b02             	ldx dosofl		; start addr
  3172  93e9 ac1c02             	ldy dosofl+1
  3173  93ec 2042b5             	jsr load
  3174  93ef 90c3               	bcc bsvrts		; done
  3175                          ; -------------------------------------------------------------------------------------------------
  3176                          ; HEADER nddn (,id)
  3177                          
  3178  93f1 20d8ae             format:	jsr dospar		; parse the line
  3179  93f4 206cb2             	jsr chk1		; check parameter errors
  3180  93f7 2911               	and #$11
  3181  93f9 c911               	cmp #$11
  3182  93fb d05d               	bne rec5 		; if required parameters not present
  3183                          
  3184  93fd 208993             frmt2:	jsr dclall		; close all files
  3185  9400 20ceb2             	jsr rusure		; r-u-sure prpt
  3186  9403 b0af               	bcs bsvrts 		; if no and direct mode
  3187  9405 a004               	ldy #thed		; tabld index
  3188  9407 a904               	lda #4			; length
  3189  9409 ae2302             	ldx dosdid		; check for diskid
  3190  940c f002               	beq frmt6
  3191  940e a906               	lda #6			; length with id
  3192  9410 203795             frmt6:	jsr trans			; build and send
  3193                          
  3194  9413 209bb2             	jsr errchl		; get error status
  3195  9416 209e9c             	jsr tdm			; test direct mode
  3196  9419 d099               	bne bsvrts 		; if direct mode
  3197                          
  3198  941b a000               	ldy #0
  3199  941d b117               	lda (dsdesc+1),y
  3200  941f c932               	cmp #'2'
  3201  9421 b001               	bcs frmt8		; if error occured
  3202  9423 60                 	rts
  3203                          
  3204  9424 a216               frmt8:	ldx #msg31		; ? bad disk
  3205  9426 4c2685             	jmp error
  3206                          ; -------------------------------------------------------------------------------------------------
  3207                          ; SCRATCH dfn
  3208                          
  3209  9429 20d8ae             scratc:	jsr dospar		; parse the line
  3210  942c 206cb2             	jsr chk1
  3211  942f 20ceb2             	jsr rusure		; check direct and ask user
  3212  9432 b025               	bcs zxit		; if no and direct mode
  3213  9434 a00a               	ldy #tscr		; offset
  3214  9436 a904               	lda #4			; length
  3215  9438 203795             	jsr trans
  3216  943b 209bb2             	jsr errchl		; read error channel
  3217  943e 209e9c             	jsr tdm			; test direct mode
  3218  9441 d016               	bne zxit		; if direct mode
  3219  9443 a90d               	lda #cr
  3220  9445 2030b5             	jsr bsout		; output cr
  3221  9448 a000               	ldy #0			; clr to read errchl
  3222  944a b117               sctc1:	lda (dsdesc+1),y	; get mesg
  3223  944c f006               	beq sctc2		; if end of error message
  3224  944e 2030b5             	jsr bsout
  3225  9451 c8                 	iny
  3226  9452 d0f6               	bne sctc1		; always
  3227                          
  3228  9454 a90d               sctc2:	lda #cr
  3229  9456 2030b5             	jsr bsout		; output cr
  3230  9459 60                 zxit:	rts
  3231                          
  3232  945a 4c0e97             rec5:	jmp snerr		; -> syntax error, ready
  3233                          ; -------------------------------------------------------------------------------------------------
  3234                          ; RECORD - random record access.
  3235                          
  3236  945d a901               record:	lda #01			; default pos = 1
  3237  945f 8d2202             	sta dosrcl
  3238  9462 2081b3             	jsr chrgot
  3239  9465 a923               	lda #'#'
  3240  9467 20ec96             	jsr synchr		; next character = "#"
  3241  946a 2015b1             	jsr gtvl2		; get next value
  3242  946d e000               	cpx #0
  3243  946f f016               	beq rec4		; cannot be zero
  3244  9471 8e1f02             	stx dosla		; save logical address
  3245  9474 20ea96             	jsr chkcom		; check for ","
  3246  9477 f0e1               	beq rec5		; if end of statement
  3247  9479 9014               	bcc rec1		; if numeric
  3248  947b 20e796             	jsr chkopn		; check for "("
  3249  947e 207bae             	jsr getpin		; get positive integer
  3250  9481 20e496             	jsr chkcls
  3251  9484 4c9294             	jmp rec2
  3252                          
  3253  9487 4ca3b0             rec4:	jmp qtyerr
  3254                          
  3255  948a a206               rec6:	ldx #ms3		; file not found err
  3256  948c 4c2685             	jmp error
  3257                          
  3258  948f 207bae             rec1:	jsr getpin		; get positive integer
  3259                          
  3260  9492 2081b3             rec2:	jsr chrgot		; see what is next
  3261  9495 f018               	beq rec3		; if end of statement
  3262  9497 20ea96             	jsr chkcom		; check for ","
  3263  949a f0be               	beq rec5		; if end of statement
  3264  949c 2015b1             	jsr gtvl2
  3265  949f e000               	cpx #0
  3266  94a1 f0e4               	beq rec4		; if out of range
  3267  94a3 e0ff               	cpx #$ff
  3268  94a5 f0e0               	beq rec4		; if out of range
  3269  94a7 8e2202             	stx dosrcl		; save byte position (pos)
  3270  94aa 2081b3             	jsr chrgot
  3271  94ad d0ab               gaaa:	bne rec5		; if not end of statement
  3272                          
  3273  94af ad1f02             rec3:	lda dosla		; get logical address
  3274  94b2 208dff             	jsr lkupla		; logical to physical map
  3275  94b5 b0d3               	bcs rec6		; if file not found
  3276  94b7 8c2102             	sty dossa		; save secondary address
  3277  94ba 8e2002             	stx dosfa
  3278  94bd 20baff             	jsr setlfs		; set up la, fa
  3279  94c0 2007b3             	jsr oldclr		; clear disk status
  3280  94c3 a00b               	ldy #trec		; set pointer
  3281  94c5 a904               	lda #4			; process five bytes
  3282  94c7 d06e               	bne trans		; transfer on channel 15
  3283                          ; -------------------------------------------------------------------------------------------------
  3284                          ; 950a DCLEAR
  3285                          
  3286  94c9 20d8ae             dclear:	jsr dospar		; parse the line
  3287  94cc a000               	ldy #tclr		; set code
  3288  94ce a902               	lda #2
  3289  94d0 d065               	bne trans
  3290                          ; -------------------------------------------------------------------------------------------------
  3291                          ; COLLECT v<drive#}
  3292                          
  3293  94d2 20d8ae             colect:	jsr dospar		; parse the line
  3294  94d5 207eb2             	jsr chk3		; chk opt parms
  3295  94d8 208993             	jsr dclall		; close all files
  3296  94db a005               	ldy #tcoll		; tabld offset
  3297  94dd a201               	ldx #1			; length
  3298  94df a589               	lda parsts
  3299  94e1 2910               	and #$10
  3300  94e3 f001               	beq clct2
  3301  94e5 e8                 	inx			; include drive
  3302  94e6 8a                 clct2:	txa			; place in a
  3303  94e7 d04e               	bne trans		; always (x <> 0)
  3304                          ; -------------------------------------------------------------------------------------------------
  3305                          ; COPY - copy routines cdddfn=sdsfn
  3306                          
  3307  94e9 20d8ae             dcopy:	jsr dospar		; parse the line
  3308  94ec 2930               	and #$30
  3309  94ee c930               	cmp #$30		; chk req'd parms
  3310  94f0 d006               	bne dcpy2
  3311  94f2 a589               	lda parsts
  3312  94f4 29c7               	and #$c7
  3313  94f6 f007               	beq dcpy4
  3314  94f8 a589               dcpy2:	lda parsts
  3315  94fa 2083b2             	jsr chk4
  3316  94fd a589               	lda parsts
  3317  94ff a007               dcpy4:	ldy #tcopy		; tabld offset
  3318  9501 a908               	lda #8			; length
  3319  9503 d032               	bne trans		; go do it
  3320                          ; -------------------------------------------------------------------------------------------------
  3321                          ; CONCAT routines
  3322                          
  3323  9505 20d8ae             concat:	jsr dospar		; parse the line
  3324  9508 2083b2             	jsr chk4
  3325  950b a008               	ldy #tconc		; offset
  3326  950d a90c               	lda #12			; length
  3327  950f d026               	bne trans		; go do it
  3328                          ; -------------------------------------------------------------------------------------------------
  3329                          ; RENAME rdddfn=sdsfn
  3330                          
  3331  9511 a9e4               rename:	lda #$e4		; set error flags
  3332  9513 20daae             	jsr dosprs		; parse the line
  3333  9516 2089b2             	jsr chk5
  3334  9519 a009               	ldy #tren		; offset
  3335  951b a908               	lda #8			; length
  3336  951d d018               	bne trans		; go do it
  3337                          ; -------------------------------------------------------------------------------------------------
  3338                          ; BACKUP d<dd>=<sd}
  3339                          
  3340  951f a9c7               backup:	lda #$c7		; set error flags
  3341  9521 20daae             	jsr dosprs		; parse the line
  3342  9524 2930               	and #$30		; req'd parms
  3343  9526 c930               	cmp #$30
  3344  9528 d083               	bne gaaa		; if syntax error
  3345  952a 20ceb2             	jsr rusure		; test for direct mode and send message
  3346  952d 9001               	bcc bup1  		; if run mode or not 'yes'
  3347  952f 60                 	rts
  3348                          
  3349  9530 208993             bup1:	jsr dclall		; close disk
  3350  9533 a006               	ldy #tbak
  3351  9535 a904               	lda #4			; length
  3352                          ; trans subroutine
  3353  9537 209ab1             trans:	jsr sendp		; build string to output
  3354  953a 20ccff             	jsr clrch
  3355  953d 38                 	sec
  3356  953e 201eb5             	jsr opn10 		; send it...
  3357  9541 4c1c93             	jmp dcat0
  3358                          
  3359                          ; ****************************************** MATH1 ************************************************
  3360                          ; 'math cracking routines.'
  3361                          
  3362                          forfix:               		; empty space for future fixes
  3363  9544 22                 	!byte $22		; check sum byte
  3364                          
  3365  9545 2007b3             patch1:	jsr oldclr		; clear disk status for printn & cmd
  3366  9548 4c3cb5             	jmp chkout
  3367                          
  3368                          
  3369  954b 38                 patch3:	sec			; close all files associated with device in .a
  3370  954c 4ce7ff             	jmp kclall
  3371                          
  3372                          *=*+$2b
  3373                          ; -------------------------------------------------------------------------------------------------
  3374                          ; 95c1 frmevl
  3375                          ;   the formula evaluator starts with (txtptr) -> to the 1st char of the formula.
  3376                          ;   at the end (txtptr) -> to the terminator. the result is left in the fac.
  3377                          ;   on return (a) does not reflect the terminator.
  3378                          ; 
  3379                          ;   the formula evaluator uses the operator list (optab= to determine precedence and dispatch
  3380                          ;   addresses for each operator. a tem result on the stk has the following format address of the
  3381                          ;   operator routine fp temp result precedence of the operator
  3382                          
  3383  957a 6c8c02             frmevl:	jmp (ifrmev)
  3384                          
  3385  957d a683               nfrmev:	ldx txtptr
  3386  957f d002               	bne frmev1
  3387  9581 c684               	dec txtptr+1
  3388  9583 c683               frmev1:	dec txtptr
  3389  9585 a200               	ldx #0
  3390  9587 24                 	!byte $24
  3391                          
  3392  9588 48                 lpoper:	pha
  3393  9589 8a                 	txa
  3394  958a 48                 	pha
  3395  958b a901               	lda #1
  3396  958d 204788             	jsr getstk
  3397  9590 206796             	jsr eval
  3398  9593 a900               	lda #0
  3399  9595 8558               	sta opmask
  3400  9597 2081b3             tstop:	jsr chrgot
  3401                          
  3402  959a 38                 loprel:	sec
  3403  959b e9b1               	sbc #tkgrea
  3404  959d 9017               	bcc endrel
  3405  959f c903               	cmp #tkless-tkgrea+1
  3406  95a1 b013               	bcs endrel
  3407  95a3 c901               	cmp #1
  3408  95a5 2a                 	rol
  3409  95a6 4901               	eor #1
  3410  95a8 4558               	eor opmask
  3411  95aa c558               	cmp opmask
  3412  95ac 9061               	bcc snerr5
  3413  95ae 8558               	sta opmask
  3414  95b0 207eb3             	jsr chrget
  3415  95b3 4c9a95             	jmp loprel
  3416                          
  3417  95b6 a658               endrel:	ldx opmask
  3418  95b8 d02c               	bne finrel
  3419  95ba b07f               	bcs qop
  3420  95bc 6907               	adc #tkgrea-tkplus
  3421  95be 907b               	bcc qop
  3422  95c0 6511               	adc valtyp
  3423  95c2 d003               	bne *+5
  3424  95c4 4c0ea9             	jmp cat
  3425                          
  3426  95c7 69ff               	adc #$ff
  3427  95c9 8522               	sta index1
  3428  95cb 0a                 	asl
  3429  95cc 6522               	adc index1
  3430  95ce a8                 	tay 
  3431  95cf 68                 qprec:	pla
  3432  95d0 d9b480             	cmp optab,y
  3433  95d3 b06b               	bcs qchnum
  3434  95d5 209aae             	jsr chknum
  3435  95d8 48                 doprec:	pha
  3436  95d9 20ff95             negprc:	jsr dopre1
  3437  95dc 68                 	pla
  3438  95dd a455               	ldy opptr
  3439  95df 1017               	bpl qprec1
  3440  95e1 aa                 	tax
  3441  95e2 f05a               	beq qopgo
  3442  95e4 d063               	bne pulstk
  3443  95e6 4611               finrel:	lsr valtyp
  3444  95e8 8a                 	txa
  3445  95e9 2a                 	rol
  3446  95ea a683               	ldx txtptr
  3447  95ec d002               	bne finre2
  3448  95ee c684               	dec txtptr+1
  3449  95f0 c683               finre2:	dec txtptr
  3450  95f2 a01b               	ldy #ptdorl-optab
  3451  95f4 8558               	sta opmask
  3452  95f6 d0d7               	bne qprec
  3453  95f8 d9b480             qprec1:	cmp optab,y
  3454  95fb b04c               	bcs pulstk
  3455  95fd 90d9               	bcc doprec
  3456                          
  3457  95ff b9b680             dopre1:	lda optab+2,y
  3458  9602 48                 	pha
  3459  9603 b9b580             	lda optab+1,y
  3460  9606 48                 	pha
  3461  9607 201296             	jsr pushf1
  3462  960a a558               	lda opmask
  3463  960c 4c8895             	jmp lpoper
  3464                          
  3465  960f 4c0e97             snerr5:	jmp snerr		; -> syntax error, ready
  3466                          ; -------------------------------------------------------------------------------------------------
  3467                          ; pushf1
  3468                          
  3469  9612 a574               pushf1:	lda facsgn
  3470  9614 beb480             	ldx optab,y
  3471  9617 a8                 pushf:	tay
  3472  9618 68                 	pla
  3473  9619 8522               	sta index1
  3474  961b 68                 	pla
  3475  961c 8523               	sta index1+1
  3476  961e 98                 	tya
  3477  961f 48                 	pha
  3478  9620 e622               	inc index1		; fix 10/19/79
  3479  9622 d002               	bne forpsh		; 
  3480  9624 e623               	inc index1+1
  3481  9626 2010a1             forpsh:	jsr round
  3482  9629 a573               	lda faclo
  3483  962b 48                 	pha
  3484  962c a572               	lda facmo
  3485  962e 48                 	pha
  3486  962f a571               	lda facmoh
  3487  9631 48                 	pha
  3488  9632 a570               	lda facho
  3489  9634 48                 	pha
  3490  9635 a56f               	lda facexp
  3491  9637 48                 	pha
  3492  9638 6c2200             	jmp (index1)
  3493                          
  3494  963b a0ff               qop:	ldy #$ff
  3495  963d 68                 	pla
  3496  963e f024               qopgo:	beq qoprts
  3497  9640 c964               qchnum:	cmp #100
  3498  9642 f003               	beq unpstk
  3499  9644 209aae             	jsr chknum
  3500  9647 8455               unpstk:	sty opptr
  3501  9649 68                 pulstk:	pla
  3502  964a 4a                 	lsr
  3503  964b 8d5902             	sta domask
  3504  964e 68                 	pla
  3505  964f 8577               	sta argexp
  3506  9651 68                 	pla
  3507  9652 8578               	sta argho
  3508  9654 68                 	pla
  3509  9655 8579               	sta argmoh
  3510  9657 68                 	pla
  3511  9658 857a               	sta argmo
  3512  965a 68                 	pla
  3513  965b 857b               	sta arglo
  3514  965d 68                 	pla
  3515  965e 857c               	sta argsgn
  3516  9660 4574               	eor facsgn
  3517  9662 857d               	sta arisgn
  3518  9664 a56f               qoprts:	lda facexp
  3519  9666 60                 	rts
  3520                          ; -------------------------------------------------------------------------------------------------
  3521                          ; eval
  3522                          
  3523  9667 6c8a02             eval:	jmp (ieval)
  3524                          
  3525  966a a900               neval:	lda #0
  3526  966c 8511               	sta valtyp
  3527                          
  3528  966e 207eb3             eval0:	jsr chrget
  3529  9671 b016               	bcs eval2
  3530  9673 4cf1a1             eval1:	jmp fin
  3531                          
  3532  9676 c9ff               eval22:	cmp #pi
  3533  9678 d017               	bne qdot
  3534  967a a984               	lda #<pival
  3535  967c a096               	ldy #>pival
  3536  967e 2091a0             	jsr movfm
  3537  9681 4c7eb3             	jmp chrget
  3538                          
  3539  9684 82490fdaa1         pival:	!byte $82,$49,$0f,$da,$a1	; constant pi
  3540                          
  3541                          ; non numeric
  3542  9689 204e99             eval2:	jsr isletc
  3543  968c 90e8               	bcc eval22
  3544                          ;	bcs isvar			; isvar branch replaced with
  3545  968e 4c1397             	jmp isvar			; ..jmp isvar (too far for branch)
  3546                          
  3547  9691 c92e               qdot:	cmp #'.'
  3548  9693 f0de               	beq eval1
  3549  9695 c9ab               	cmp #tkminu
  3550  9697 f03e               	beq domin
  3551  9699 c9aa               	cmp #tkplus
  3552  969b f0d1               	beq eval0
  3553  969d c922               	cmp #34
  3554  969f d009               	bne eval3
  3555  96a1 202e90             strtxt:	jsr sav30
  3556  96a4 201ca7             	jsr strlit
  3557  96a7 4c52aa             	jmp st2txt
  3558                          
  3559  96aa c9a8               eval3:	cmp #tknot
  3560  96ac d013               	bne eval4
  3561  96ae a018               	ldy #nottab-optab
  3562  96b0 d027               	bne gonprc
  3563                          ; not
  3564  96b2 208c9a             notop:	jsr ayint
  3565  96b5 a573               	lda faclo
  3566  96b7 49ff               	eor #$ff
  3567  96b9 a8                 	tay
  3568  96ba a572               	lda facmo
  3569  96bc 49ff               	eor #$ff
  3570  96be 4c809c             	jmp givayf
  3571                          ; fn
  3572  96c1 c9a5               eval4:	cmp #tkfn
  3573  96c3 d003               	bne eval5
  3574  96c5 4cb89c             	jmp fndoer
  3575                          ; math functions
  3576  96c8 c9b4               eval5:	cmp #tkonef
  3577  96ca 9012               	bcc parchk
  3578  96cc c9e7               	cmp #tkerrd		; cover err$ & instr$
  3579  96ce b004               	bcs eval6
  3580  96d0 c9cb               	cmp #tkgo		; can't be reserved word past str ftns
  3581  96d2 b03a               	bcs snerr
  3582  96d4 4cfb96             eval6:	jmp NewIsfun		; VDP: check for VDP function befere execute basic 4+ function
  3583                          ;	jmp isfun		; execute function
  3584                          
  3585  96d7 a015               domin:	ldy #negtab-optab
  3586  96d9 68                 gonprc:	pla
  3587  96da 68                 	pla
  3588  96db 4cd995             	jmp negprc
  3589                          
  3590  96de 20e796             parchk:	jsr chkopn		; check '(' ')'
  3591  96e1 207a95             	jsr frmevl
  3592                          
  3593  96e4 a929               chkcls:	lda #')'		; check for ')'
  3594  96e6 2c                 	!byte $2c		; eat the next two bytes
  3595                          
  3596  96e7 a928               chkopn:	lda #'('		; check for '('
  3597  96e9 2c                 	!byte $2c		; eat the next two bytes
  3598                          
  3599  96ea a92c               chkcom:	lda #','		; check ','
  3600                          ; -------------------------------------------------------------------------------------------------
  3601                          ; synchr
  3602                          ;   looks at the current char to make sure it is the specific thing loaded into acca just before
  3603                          ;   the call to synchk. if not it calls the syntax error routine.
  3604                          ;   otherwise it eats the next char and returns
  3605  96ec 8d5b02             synchr:	sta tttemp
  3606  96ef a000               	ldy #0
  3607  96f1 b183               	lda (txtptr),y
  3608  96f3 cd5b02             	cmp tttemp
  3609  96f6 d016               	bne snerr		; if not =, then error
  3610  96f8 4c7eb3             	jmp chrget		; eat char
  3611                          ; -------------------------------------------------------------------------------------------------
  3612                          ; new basic4+ isfun routine start to detect vdp function
  3613                          NewIsfun:
  3614  96fb c9f4               	cmp #TKTEST			; TEST ?
  3615  96fd f003               	beq IsTest
  3616  96ff 4cbc97             	jmp isfun			; isfun
  3617                          
  3618  9702 207eb3             IsTest:	jsr chrget
  3619  9705 20de96             	jsr parchk
  3620  9708 2098b8             	jsr VDPTest
  3621  970b 4c7e9c             	jmp sngflt			; sngflt
  3622                          ; -------------------------------------------------------------------------------------------------
  3623                          ; snerr - output syntax error
  3624  970e a22c               snerr:	ldx #errsn
  3625  9710 4c2685             	jmp error
  3626                          ; -------------------------------------------------------------------------------------------------
  3627                          ; isvar
  3628                          ;   isvar sets up the value of the variable expression in the floating accumulator. if it is an
  3629                          ;   integer,the value is floated; if it is a string,fac holds a pointer to the string's descriptor.
  3630                          
  3631                          ;   note, symbol table space for uninitialized variables is never allocated. for these and basic
  3632                          ;   reserved vars, "ptrget" returns a pointer to "zero", stored in basic's rom area. "isvar" checks
  3633                          ;   the var name and type for these special cases. if not a reserved var, "isvar" uses "zero" to
  3634                          ;   create a numeric zero or null string value.
  3635                          
  3636  9713 20c198             isvar:	jsr ptrget
  3637                          
  3638  9716 8572               isvret:	sta facmo
  3639  9718 8473               	sty facmo+1
  3640  971a 8674               	stx facmo+2
  3641  971c a64d               	ldx varnam
  3642  971e a44e               	ldy varnam+1
  3643  9720 a511               	lda valtyp
  3644  9722 f033               	beq goo
  3645  9724 a900               	lda #0
  3646  9726 857e               	sta facov
  3647                          ; all special variables in RAM	- modded by vossi
  3648                          ; check ti$
  3649  9728 e054               	cpx #'t'
  3650  972a d007               	bne isvds		; if not 't'
  3651  972c c0c9               	cpy #$c9 		; 'i'+$80
  3652  972e d003               	bne isvds		; if 't' but not 'ti$'
  3653  9730 4cabaa             	jmp gettim		; get time
  3654                          ; check ds$
  3655  9733 e044               isvds:	cpx #'d'
  3656  9735 d018               	bne isvrts		; if not 'd'
  3657  9737 c0d3               	cpy #$d3  		; 's'+$80
  3658  9739 d014               	bne isvrts		; if not 'ds$'
  3659  973b 205097             	jsr chkds
  3660  973e a517               	lda dsdesc+1
  3661  9740 a418               	ldy dsdesc+2
  3662  9742 a619               	ldx dsdesc+3
  3663  9744 4c1ca7             	jmp strlit
  3664                          
  3665  9747 a53d               strrts:	lda memtop		; facmo<-addr of user "zero"
  3666  9749 8572               	sta facmo
  3667  974b a53e               	lda memtop+1
  3668  974d 8573               	sta facmo+1
  3669  974f 60                 isvrts:	rts
  3670                          
  3671  9750 a516               chkds:	lda dsdesc
  3672  9752 d0fb               	bne isvrts
  3673  9754 4c9bb2             	jmp errchl		; get status
  3674                          
  3675  9757 2412               goo:	bit intflg		; test sign
  3676  9759 100d               	bpl gooo
  3677  975b a000               	ldy #0
  3678  975d b172               	lda (facmo),y
  3679  975f aa                 	tax
  3680  9760 c8                 	iny
  3681  9761 b172               	lda (facmo),y
  3682  9763 a8                 	tay
  3683  9764 8a                 	txa
  3684  9765 4c809c             	jmp givayf
  3685                          
  3686  9768 e053               gooo:	cpx #'s'
  3687  976a d00a               	bne qerlin		; if not 's'
  3688  976c c054               	cpy #'t'
  3689  976e d006               	bne qerlin		; if 's' but not 'st'
  3690  9770 2019b5             	jsr readst		; get i/o status byte
  3691  9773 4c31a1             	jmp float
  3692                          
  3693  9776 e045               qerlin:	cpx #'e'
  3694  9778 d017               	bne qdsav
  3695  977a c052               	cpy #'r'
  3696  977c f00d               	beq gnumer
  3697  977e c04c               	cpy #'l'
  3698  9780 d00f               	bne qdsav
  3699  9782 ad9902             	lda errlin+1
  3700  9785 ac9802             	ldy errlin
  3701  9788 4c739c             	jmp nosflt		; print 2 bytes
  3702  978b a58d               gnumer:	lda errnum
  3703  978d 4a                 	lsr			; divide by 2
  3704  978e 4c31a1             	jmp float 		; print 1 byte
  3705                          
  3706  9791 e044               qdsav:	cpx #'d'
  3707  9793 d020               	bne gomovf		; if not 'd'
  3708  9795 c053               	cpy #'s'
  3709  9797 d01c               	bne gomovf		; if 'd' but not 'ds'
  3710  9799 205097             	jsr chkds
  3711  979c a000               	ldy #0
  3712  979e b117               	lda (dsdesc+1),y
  3713  97a0 290f               	and #$f
  3714  97a2 0a                 	asl
  3715  97a3 8513               	sta garbfl
  3716  97a5 0a                 	asl
  3717  97a6 0a                 	asl
  3718  97a7 6513               	adc garbfl
  3719  97a9 8513               	sta garbfl
  3720  97ab c8                 	iny
  3721  97ac b117               	lda (dsdesc+1),y
  3722  97ae 290f               	and #$f
  3723  97b0 6513               	adc garbfl
  3724  97b2 4c31a1             	jmp float
  3725                          
  3726  97b5 a572               gomovf:	lda facmo		;  fac<-rom mem (uninit. flt var)
  3727  97b7 a473               	ldy facmo+1
  3728  97b9 4c91a0             	jmp movfm
  3729                          ; -------------------------------------------------------------------------------------------------
  3730                          ; isfun
  3731                          
  3732  97bc 0a                 isfun:	asl
  3733  97bd 48                 	pha
  3734  97be aa                 	tax
  3735  97bf 207eb3             	jsr chrget
  3736  97c2 e08f               	cpx #tklasn+tklasn-$ff
  3737  97c4 902b               	bcc oknorm
  3738                          
  3739                          tkerd2=tkerrd+tkerrd
  3740  97c6 e0ce               	cpx #<tkerd2
  3741  97c8 f076               	beq errjmp
  3742  97ca 20e796             	jsr chkopn
  3743  97cd 207a95             	jsr frmevl
  3744  97d0 20ea96             	jsr chkcom
  3745  97d3 209cae             	jsr chkstr
  3746  97d6 68                 	pla
  3747                          
  3748                          tkint2=tkinst+tkinst
  3749  97d7 c9d0               	cmp #<tkint2
  3750  97d9 f062               	beq insjmp
  3751  97db aa                 	tax
  3752  97dc a574               	lda facmo+2		;  push descr ptr for opnd1
  3753  97de 48                 	pha
  3754  97df a573               	lda facmo+1
  3755  97e1 48                 	pha
  3756  97e2 a572               	lda facmo
  3757  97e4 48                 	pha
  3758  97e5 8a                 	txa
  3759  97e6 48                 	pha
  3760  97e7 206cae             	jsr getbyt		; opnd2
  3761  97ea 68                 	pla
  3762  97eb a8                 	tay
  3763  97ec 8a                 	txa
  3764  97ed 48                 	pha
  3765  97ee 4cf697             	jmp fingo
  3766                          
  3767  97f1 20de96             oknorm:	jsr parchk
  3768  97f4 68                 	pla
  3769  97f5 a8                 	tay
  3770  97f6 b91e80             fingo:	lda fundsp-tkonef-tkonef+256,y
  3771  97f9 8560               	sta jmper+1
  3772                          
  3773  97fb b91f80             	lda fundsp-tkonef-tkonef+257,y
  3774  97fe 8561               	sta jmper+2
  3775                          
  3776  9800 205f00             	jsr jmper
  3777  9803 4c9aae             	jmp chknum
  3778                          ; -------------------------------------------------------------------------------------------------
  3779                          ; OR
  3780                          
  3781  9806 a0ff               orop:	ldy #$ff
  3782  9808 2c                 	!byte $2c		; eat the next two bytes
  3783                          ; AND
  3784  9809 a000               andop:	ldy #0
  3785  980b 8c5602             	sty eormsk
  3786  980e 208c9a             	jsr ayint
  3787  9811 a572               	lda facmo
  3788  9813 4d5602             	eor eormsk
  3789  9816 850c               	sta integr
  3790  9818 a573               	lda faclo
  3791  981a 4d5602             	eor eormsk
  3792  981d 850d               	sta integr+1
  3793  981f 20f1a0             	jsr movfa
  3794  9822 208c9a             	jsr ayint
  3795  9825 a573               	lda faclo
  3796  9827 4d5602             	eor eormsk
  3797  982a 250d               	and integr+1
  3798  982c 4d5602             	eor eormsk
  3799  982f a8                 	tay
  3800  9830 a572               	lda facmo
  3801  9832 4d5602             	eor eormsk
  3802  9835 250c               	and integr
  3803  9837 4d5602             	eor eormsk
  3804  983a 4c809c             	jmp givayf
  3805                          
  3806  983d 4c27ad             insjmp:	jmp instrg
  3807                          
  3808  9840 4c5baa             errjmp:	jmp errd
  3809                          ; -------------------------------------------------------------------------------------------------
  3810                          ; = - perform relational operator
  3811                          ;   (domask) contains the bits as to which relational operator it was. cbit set = string compare.
  3812                          
  3813  9843 209dae             dorel:	jsr chkval
  3814  9846 b013               	bcs strcmp
  3815  9848 a57c               	lda argsgn		; conv arg to basic internal form
  3816  984a 097f               	ora #127
  3817  984c 2578               	and argho
  3818  984e 8578               	sta argho
  3819  9850 a977               	lda #<argexp
  3820  9852 a000               	ldy #>argexp
  3821  9854 2050a1             	jsr fcomp		;  arg is 1st opnd
  3822  9857 aa                 	tax
  3823  9858 4c9d98             	jmp qcomp
  3824                          
  3825                          ; string =
  3826  985b a900               strcmp:	lda #0
  3827  985d 8511               	sta valtyp
  3828  985f c658               	dec opmask
  3829  9861 20c3a7             	jsr frefac		; free string2
  3830  9864 856e               	sta dsctmp		;  dsctmp <- length2,
  3831  9866 a202               	ldx #2
  3832                          
  3833  9868 b522               grrk:	lda index,x
  3834  986a 956f               	sta dsctmp+1,x
  3835  986c ca                 	dex
  3836  986d 10f9               	bpl grrk
  3837  986f a57a               	lda argmo
  3838  9871 a47b               	ldy argmo+1
  3839  9873 a67c               	ldx argmo+2
  3840  9875 20c7a7             	jsr fretmp		; free string1
  3841  9878 a622               	ldx index
  3842  987a a423               	ldy index+1
  3843  987c 867a               	stx argmo		; argmo<-ptr to string1
  3844  987e 847b               	sty argmo+1
  3845  9880 a424               	ldy index+2
  3846  9882 847c               	sty argmo+2
  3847  9884 aa                 	tax			; .x <- length1
  3848  9885 38                 	sec
  3849  9886 e56e               	sbc dsctmp
  3850  9888 f008               	beq stasgn		;  length1=length2
  3851  988a a901               	lda #1
  3852  988c 9004               	bcc stasgn		;  length1<length2
  3853  988e a66e               	ldx dsctmp
  3854  9890 a9ff               	lda #$ff
  3855                          ; .a = o(equal), 1(len1<len2), -1(len1>len2)
  3856                          ; .x = length of shorter string
  3857  9892 8574               stasgn:	sta facsgn
  3858  9894 a0ff               	ldy #$ff
  3859  9896 e8                 	inx
  3860  9897 c8                 nxtcmp:	iny			; .y=inx to nxt chr, .x=#chrs to go
  3861  9898 ca                 	dex
  3862  9899 d007               	bne getcmp
  3863  989b a674               	ldx facsgn
  3864                          ; come here when strings are equal, but
  3865                          ; .x =  1, len1<len2, cy=1
  3866                          ;  0, len1=len2, cy=0
  3867                          ; -1, len1>len2, cy=0
  3868  989d 3015               qcomp:	bmi docmp
  3869  989f 18                 	clc
  3870  98a0 9012               	bcc docmp
  3871  98a2 b16f               getcmp:	lda (dsctmp+1),y	;  chr from string2
  3872  98a4 8d5b02             	sta tttemp
  3873  98a7 b17a               	lda (argmo),y		;  chr from string1
  3874  98a9 cd5b02             	cmp tttemp
  3875  98ac f0e9               	beq nxtcmp
  3876  98ae a2ff               	ldx #$ff
  3877  98b0 b002               	bcs docmp
  3878  98b2 a201               	ldx #1
  3879  98b4 e8                 docmp:	inx
  3880  98b5 8a                 	txa
  3881  98b6 2a                 	rol
  3882  98b7 2d5902             	and domask
  3883  98ba f002               	beq goflot
  3884  98bc a9ff               	lda #$ff
  3885  98be 4c31a1             goflot:	jmp float
  3886                          ; -------------------------------------------------------------------------------------------------
  3887                          ; ptrget
  3888                          
  3889  98c1 a200               ptrget:	ldx #0
  3890  98c3 2081b3             	jsr chrgot
  3891  98c6 8610               ptrgt1:	stx dimflg
  3892  98c8 854d               ptrgt2:	sta varnam
  3893  98ca 2081b3             	jsr chrgot
  3894  98cd 204e99             	jsr isletc
  3895  98d0 b003               	bcs ptrgt3
  3896  98d2 4c0e97             interr:	jmp snerr		; -> syntax error, ready
  3897                          
  3898  98d5 a200               ptrgt3:	ldx #0
  3899  98d7 8611               	stx valtyp
  3900  98d9 8612               	stx intflg
  3901  98db 207eb3             	jsr chrget
  3902  98de 9005               	bcc issec
  3903  98e0 204e99             	jsr isletc
  3904  98e3 900b               	bcc nosec
  3905  98e5 aa                 issec:	tax
  3906  98e6 207eb3             eatem:	jsr chrget
  3907  98e9 90fb               	bcc eatem
  3908  98eb 204e99             	jsr isletc
  3909  98ee b0f6               	bcs eatem
  3910  98f0 c924               nosec:	cmp #'$'
  3911  98f2 d006               	bne notstr
  3912  98f4 a9ff               	lda #$ff
  3913  98f6 8511               	sta valtyp
  3914  98f8 d010               	bne turnon
  3915  98fa c925               notstr:	cmp #'%'
  3916  98fc d013               	bne strnam
  3917  98fe a514               	lda subflg
  3918  9900 d0d0               	bne interr
  3919  9902 a980               	lda #$80
  3920  9904 8512               	sta intflg
  3921  9906 054d               	ora varnam
  3922  9908 854d               	sta varnam
  3923  990a 8a                 turnon:	txa
  3924  990b 0980               	ora #$80
  3925  990d aa                 	tax
  3926  990e 207eb3             	jsr chrget
  3927  9911 864e               strnam:	stx varnam+1
  3928  9913 38                 	sec
  3929  9914 0514               	ora subflg
  3930  9916 e928               	sbc #40
  3931  9918 d003               	bne strna1
  3932  991a 4ca19a             	jmp isary
  3933                          
  3934  991d a000               strna1:	ldy #0
  3935  991f 8414               	sty subflg
  3936  9921 a531               	lda vartab
  3937  9923 a632               	ldx vartab+1
  3938  9925 866c               stxfnd:	stx lowtr+1
  3939  9927 856b               lopfnd:	sta lowtr		; reached end of simple vars?
  3940                          
  3941  9929 e436               	cpx arytab+1
  3942  992b d004               	bne lopfn
  3943  992d c535               	cmp arytab
  3944  992f f027               	beq notfns
  3945  9931 b16b               lopfn:	lda (lowtr),y
  3946  9933 c54d               	cmp varnam
  3947  9935 d00d               	bne notit
  3948  9937 c8                 	iny
  3949  9938 b16b               	lda (lowtr),y
  3950  993a c54e               	cmp varnam+1
  3951  993c d005               	bne nxtptr
  3952  993e 4c5f9a             	jmp finptr
  3953                          
  3954  9941 f08f               gobadv:	beq interr
  3955                          
  3956  9943 88                 nxtptr:	dey
  3957  9944 18                 notit:	clc
  3958  9945 a56b               	lda lowtr
  3959  9947 6907               	adc #6+addprc
  3960  9949 90dc               	bcc lopfnd
  3961  994b e8                 	inx
  3962  994c d0d7               	bne stxfnd
  3963  994e c941               isletc:	cmp #'a'
  3964  9950 9005               	bcc islrts
  3965  9952 e95b               	sbc #$5b
  3966  9954 38                 	sec
  3967  9955 e9a5               	sbc #$a5
  3968  9957 60                 islrts:	rts
  3969                          
  3970  9958 68                 notfns:	pla
  3971  9959 48                 	pha
  3972                          
  3973                          isvrm1=isvret-1
  3974  995a c915               	cmp #<isvrm1
  3975  995c d00d               	bne notevl
  3976  995e ba                 	tsx
  3977  995f bd0201             	lda stack+2,x
  3978  9962 c997               	cmp #>isvrm1
  3979  9964 d005               	bne notevl
  3980  9966 a922               ldzr:	lda #<fzero
  3981  9968 a0a4               	ldy #>fzero
  3982  996a 60                 	rts
  3983                          
  3984  996b a54d               notevl:	lda varnam
  3985  996d a44e               	ldy varnam+1
  3986  996f c954               	cmp #'t'
  3987  9971 d004               	bne qstavr
  3988  9973 c0c9               	cpy #$c9   		; 'i'+$80
  3989  9975 f0ef               	beq ldzr
  3990                          ;	cpy #'i'		; disabled by CBM Basic4+ only TI$
  3991                          ;	bne qstavr
  3992                          ;	gobadv jmp snerr	; -> syntax error, ready
  3993                          
  3994  9977 c953               qstavr:	cmp #'s'
  3995  9979 d004               	bne qeravr
  3996  997b c054               	cpy #'t'
  3997  997d f0c2               	beq gobadv
  3998  997f c945               qeravr:	cmp #'e'
  3999  9981 d008               	bne qdsvar
  4000  9983 c052               	cpy #'r'
  4001  9985 f0ba               	beq gobadv
  4002  9987 c04c               	cpy #'l'
  4003  9989 f0b6               	beq gobadv
  4004                          
  4005  998b c944               qdsvar:	cmp #'d'		; disk status?
  4006  998d d008               	bne varok
  4007  998f c053               	cpy #'s'
  4008  9991 f0ae               	beq gobadv		; cannot modify ds
  4009  9993 c0d3               	cpy #$d3  		; 's'+$80
  4010  9995 f0aa               	beq gobadv		; cannot modify ds$
  4011                          varok:
  4012  9997 a535               	lda arytab
  4013  9999 a436               	ldy arytab+1
  4014  999b 856b               	sta lowtr
  4015  999d 846c               	sty lowtr+1
  4016  999f a537               	lda strend
  4017  99a1 a438               	ldy strend+1
  4018  99a3 8565               	sta hightr
  4019  99a5 8466               	sty hightr+1
  4020  99a7 18                 	clc
  4021  99a8 6907               	adc #6+addprc
  4022  99aa 9001               	bcc noteve
  4023  99ac c8                 	iny
  4024  99ad 8562               noteve:	sta highds
  4025  99af 8463               	sty highds+1
  4026  99b1 200488             	jsr bltu
  4027  99b4 a562               	lda highds
  4028  99b6 a463               	ldy highds+1
  4029  99b8 c8                 	iny
  4030  99b9 8535               	sta arytab
  4031  99bb 8436               	sty arytab+1
  4032  99bd 8562               	sta arypnt		; set pointer to arrays
  4033  99bf 8463               	sty arypnt+1
  4034  99c1 a562               aryva2:	lda arypnt
  4035  99c3 a663               	ldx arypnt+1
  4036  99c5 e438               aryva3:	cpx strend+1		; end of arrays ?
  4037  99c7 d007               	bne aryvgo
  4038  99c9 c537               	cmp strend
  4039  99cb d003               	bne aryvgo
  4040  99cd 4c439a             	jmp arydon		; finished...
  4041  99d0 8522               aryvgo:	sta index1		; parse the array
  4042  99d2 8623               	stx index1+1
  4043  99d4 a000               	ldy #1-addprc
  4044  99d6 b122               	lda (index1),y		; array name
  4045  99d8 aa                 	tax
  4046  99d9 c8                 	iny
  4047  99da b122               	lda (index1),y		; name 2nd char
  4048  99dc 08                 	php			; save status reg
  4049  99dd c8                 	iny
  4050  99de b122               	lda (index1),y		; point to next array
  4051  99e0 6562               	adc arypnt
  4052  99e2 8562               	sta arypnt
  4053  99e4 c8                 	iny
  4054  99e5 b122               	lda (index1),y
  4055  99e7 6563               	adc arypnt+1
  4056  99e9 8563               	sta arypnt+1
  4057  99eb 28                 	plp			; restore status
  4058  99ec 10d3               	bpl aryva2		; not a string type
  4059  99ee 8a                 	txa
  4060  99ef 30d0               	bmi aryva2		; not a string array
  4061  99f1 c8                 	iny			; ok we have a string array
  4062  99f2 b122               	lda (index1),y
  4063  99f4 a000               	ldy #$00
  4064  99f6 0a                 	asl
  4065  99f7 6905               	adc #5
  4066  99f9 6522               	adc index1
  4067  99fb 8522               	sta index1
  4068  99fd 9002               	bcc aryget
  4069  99ff e623               	inc index1+1
  4070  9a01 a623               aryget:	ldx index1+1		; parse array
  4071  9a03 e463               	cpx arypnt+1		; done with this array ?
  4072  9a05 d004               	bne gogo
  4073  9a07 c562               	cmp arypnt
  4074  9a09 f0ba               	beq aryva3		; yes...
  4075  9a0b a000               gogo:	ldy #$00		; process string pointer
  4076  9a0d b122               	lda (index1),y
  4077  9a0f f025               	beq dvarts		; no string...go on...
  4078  9a11 8d5b02             	sta tttemp
  4079  9a14 c8                 	iny
  4080  9a15 b122               	lda (index1),y
  4081  9a17 18                 	clc
  4082  9a18 6d5b02             	adc tttemp
  4083  9a1b 8565               	sta hightr
  4084  9a1d aa                 	tax			; save is x for check
  4085  9a1e c8                 	iny
  4086  9a1f b122               	lda (index1),y
  4087  9a21 6900               	adc #$00		; adjust high byte
  4088  9a23 8566               	sta hightr+1
  4089  9a25 c8                 	iny
  4090                          ; fix backwards pointer by adding
  4091                          ; the move length to it
  4092  9a26 18                 	clc
  4093  9a27 a000               	ldy #$00
  4094  9a29 b165               	lda (hightr),y
  4095  9a2b 6907               	adc #6+addprc
  4096  9a2d 9165               	sta (hightr),y
  4097  9a2f c8                 	iny
  4098  9a30 b165               	lda (hightr),y
  4099  9a32 6900               	adc #$00
  4100  9a34 9165               	sta (hightr),y		; done with this str.
  4101                          ; fix the next string in the array
  4102  9a36 a904               dvarts:	lda #strsiz
  4103  9a38 18                 	clc
  4104  9a39 6522               	adc index1
  4105  9a3b 8522               	sta index1
  4106  9a3d 90c2               	bcc aryget
  4107  9a3f e623               	inc index1+1
  4108  9a41 d0be               	bne aryget		; branch always
  4109                          
  4110                          arydon:
  4111  9a43 a000               	ldy #0
  4112  9a45 a54d               	lda varnam
  4113  9a47 916b               	sta (lowtr),y
  4114  9a49 c8                 	iny
  4115  9a4a a54e               	lda varnam+1
  4116  9a4c 916b               	sta (lowtr),y
  4117  9a4e a900               	lda #0
  4118  9a50 c8                 	iny
  4119  9a51 916b               	sta (lowtr),y
  4120  9a53 c8                 	iny
  4121  9a54 916b               	sta (lowtr),y
  4122  9a56 c8                 	iny
  4123  9a57 916b               	sta (lowtr),y
  4124  9a59 c8                 	iny
  4125  9a5a 916b               	sta (lowtr),y
  4126  9a5c c8                 	iny
  4127  9a5d 916b               	sta (lowtr),y
  4128                          
  4129  9a5f a56b               finptr:	lda lowtr
  4130  9a61 18                 	clc
  4131  9a62 6902               	adc #2
  4132  9a64 a46c               	ldy lowtr+1
  4133  9a66 9001               	bcc finnow
  4134  9a68 c8                 	iny
  4135  9a69 854f               finnow:	sta varpnt
  4136  9a6b 8450               	sty varpnt+1
  4137  9a6d 60                 	rts
  4138                          
  4139                          ; ******************************************* MATH2 ***********************************************
  4140                          ; fmaptr
  4141                          
  4142  9a6e a50e               fmaptr:	lda count
  4143  9a70 0a                 	asl
  4144  9a71 6905               	adc #5			; -> entries, c clr'd by asl
  4145  9a73 656b               	adc lowtr
  4146  9a75 a46c               	ldy lowtr+1
  4147  9a77 9001               	bcc jsrgm
  4148  9a79 c8                 	iny
  4149  9a7a 8562               jsrgm:	sta arypnt
  4150  9a7c 8463               	sty arypnt+1
  4151  9a7e 60                 	rts
  4152                          ; -------------------------------------------------------------------------------------------------
  4153                          ; intidx
  4154                          ;   read a formula from the current pos and turns it into a positive integer.
  4155                          ;   leaving the result in facmo & lo. negative arguments are not allowed.
  4156                          
  4157  9a7f 207eb3             intidx:	jsr chrget
  4158  9a82 207a95             	jsr frmevl
  4159  9a85 209aae             posint:	jsr chknum
  4160  9a88 a574               	lda facsgn
  4161  9a8a 300d               	bmi nonono
  4162  9a8c a56f               ayint:	lda facexp
  4163  9a8e c990               	cmp #$90
  4164  9a90 9009               	bcc qintgo
  4165  9a92 a91f               	lda #<n32768
  4166  9a94 a0a4               	ldy #>n32768
  4167  9a96 2050a1             	jsr fcomp
  4168  9a99 d003               nonono:	bne fcerr8
  4169  9a9b 4c99a1             qintgo:	jmp qint
  4170                          
  4171  9a9e 4c189b             fcerr8:	jmp fcerr		; -> illegal quantity error, ready
  4172                          ; -------------------------------------------------------------------------------------------------
  4173                          ; isary
  4174                          ;   format of arrays in ram.
  4175                          ;   descriptor:
  4176                          ;   lb = 1st char
  4177                          ;   hb = 2nd char (200 bit = str flag)
  4178                          ;   length of array in ram in bytes
  4179                          ;   number of dims
  4180                          ;   for each dim starting with the 1st list (2 bytes each) of the max indice+1 the values.
  4181                          
  4182  9aa1 a510               isary:	lda dimflg
  4183  9aa3 0512               	ora intflg
  4184  9aa5 48                 	pha
  4185  9aa6 a511               	lda valtyp
  4186  9aa8 48                 	pha
  4187  9aa9 a900               	lda #0
  4188  9aab 48                 	pha
  4189  9aac a54e               indlop:	lda varnam+1
  4190  9aae 48                 	pha
  4191  9aaf a54d               	lda varnam
  4192  9ab1 48                 	pha
  4193  9ab2 207f9a             	jsr intidx
  4194  9ab5 68                 	pla
  4195                          	
  4196  9ab6 854d               	sta varnam
  4197  9ab8 68                 	pla
  4198  9ab9 854e               	sta varnam+1
  4199  9abb 68                 	pla
  4200  9abc a8                 	tay
  4201  9abd ba                 	tsx
  4202  9abe bd0201             	lda stack+2,x
  4203  9ac1 48                 	pha
  4204  9ac2 bd0101             	lda stack+1,x
  4205  9ac5 48                 	pha
  4206  9ac6 a572               	lda indice
  4207  9ac8 9d0201             	sta stack+2,x
  4208  9acb a573               	lda indice+1
  4209  9acd 9d0101             	sta stack+1,x
  4210                          	
  4211  9ad0 c8                 	iny
  4212  9ad1 98                 	tya
  4213  9ad2 48                 	pha
  4214  9ad3 2081b3             	jsr chrgot
  4215  9ad6 c92c               	cmp #44
  4216  9ad8 f0d2               	beq indlop
  4217  9ada 68                 	pla
  4218  9adb 850e               	sta count
  4219  9add 20e496             	jsr chkcls
  4220  9ae0 68                 	pla
  4221  9ae1 8511               	sta valtyp
  4222  9ae3 68                 	pla
  4223  9ae4 8512               	sta intflg
  4224  9ae6 297f               	and #127
  4225  9ae8 8510               	sta dimflg
  4226  9aea a635               	ldx arytab
  4227  9aec a536               	lda arytab+1
  4228  9aee 866b               lopfda:	stx lowtr
  4229  9af0 856c               	sta lowtr+1
  4230  9af2 c538               	cmp strend+1		; 64k,128k
  4231  9af4 e437               	cpx strend		; 64k,128k
  4232  9af6 f043               	beq notfdd
  4233  9af8 a000               lopfdv:	ldy #0
  4234  9afa b16b               	lda (lowtr),y
  4235  9afc c8                 	iny
  4236  9afd c54d               	cmp varnam
  4237  9aff d006               	bne nmary1
  4238  9b01 b16b               	lda (lowtr),y
  4239  9b03 c54e               	cmp varnam+1
  4240  9b05 f016               	beq gotary
  4241  9b07 c8                 nmary1:	iny
  4242  9b08 b16b               	lda (lowtr),y
  4243  9b0a 18                 	clc
  4244  9b0b 656b               	adc lowtr
  4245  9b0d aa                 	tax
  4246  9b0e c8                 	iny
  4247  9b0f b16b               	lda (lowtr),y
  4248  9b11 656c               	adc lowtr+1
  4249                          	
  4250  9b13 90d9               	bcc lopfda
  4251                          ; -------------------------------------------------------------------------------------------------
  4252                          ; bserr - bad subscript error
  4253                          
  4254  9b15 a23a               bserr:	ldx #errbs
  4255  9b17 2c                 	!byte $2c
  4256                          ; illegal quantity error
  4257  9b18 a232               fcerr:	ldx #errfc
  4258  9b1a 4c2685             errgo3:	jmp error
  4259                          ; -------------------------------------------------------------------------------------------------
  4260                          ; gotary
  4261                          
  4262  9b1d a23c               gotary:	ldx #errdd
  4263  9b1f a510               	lda dimflg
  4264  9b21 d0f7               	bne errgo3
  4265  9b23 206e9a             	jsr fmaptr
  4266  9b26 a004               	ldy #4
  4267  9b28 b16b               	lda (lowtr),y
  4268  9b2a c50e               	cmp count
  4269  9b2c d0e7               	bne bserr
  4270  9b2e 4cc09b             	jmp getdef
  4271  9b31 1007               sav44:	bpl sav45		; float: size=5
  4272  9b33 ca                 	dex
  4273  9b34 a54d               	lda varnam
  4274  9b36 1002               	bpl sav45		; string:size=4
  4275  9b38 ca                 	dex
  4276  9b39 ca                 	dex			; int  : size=2
  4277  9b3a 60                 sav45:	rts
  4278                          ; -------------------------------------------------------------------------------------------------
  4279                          ; 9bd0 notfdd - here when var is not found in the array table
  4280                          ;   building an entry
  4281                          ;   put down the descriptor
  4282                          ;   setup # of dims
  4283                          ;   make sure there is room for the new entry
  4284                          ;   remember 'varpnt'
  4285                          ;   tally =4
  4286                          ;   skip 2 locs for later fill in of size
  4287                          ;   loop get an indice
  4288                          ;   put down #+1 and inc varptr
  4289                          ;   tally= tally*#+1
  4290                          ;   decrement #-dims
  4291                          ;   bne loop
  4292                          ;   call 'reason' with y,a reflecting last loc of var
  4293                          ;   update strend
  4294                          ;   zero all
  4295                          ;   make tally include maxdims and descriptor
  4296                          ;   put down tally
  4297                          ;   if called by dim, return
  4298                          ;   otherwise
  4299                          ;   index into the var as if it were found on the
  4300                          ;   initial search
  4301                          
  4302  9b3b 206e9a             notfdd:	jsr fmaptr
  4303  9b3e 205888             	jsr reason
  4304  9b41 a000               	ldy #0
  4305  9b43 8481               	sty curtol+1
  4306  9b45 a54d               	lda varnam		; stor name, calc elt size
  4307  9b47 916b               	sta (lowtr),y
  4308  9b49 c8                 	iny
  4309  9b4a a205               	ldx #5
  4310  9b4c a54e               	lda varnam+1
  4311  9b4e 916b               	sta (lowtr),y
  4312  9b50 20319b             	jsr sav44
  4313  9b53 8680               	stx curtol
  4314  9b55 a50e               	lda count
  4315  9b57 c8                 	iny
  4316  9b58 c8                 	iny
  4317  9b59 c8                 	iny
  4318  9b5a 916b               	sta (lowtr),y		; store #dimensions
  4319                          
  4320  9b5c a20b               loppta:	ldx #11			; default upper bound for subscr
  4321  9b5e a900               	lda #0
  4322  9b60 2410               	bit dimflg
  4323  9b62 5008               	bvc notdim
  4324  9b64 68                 	pla			; not using default, get size from stack...
  4325  9b65 18                 	clc
  4326  9b66 6901               	adc #1			; ...and add 1 to it for limit
  4327  9b68 aa                 	tax
  4328  9b69 68                 	pla
  4329  9b6a 6900               	adc #0
  4330  9b6c c8                 notdim:	iny
  4331  9b6d 916b               	sta (lowtr),y		; store upper bound (reverse order)
  4332  9b6f c8                 	iny
  4333  9b70 8a                 	txa
  4334  9b71 916b               	sta (lowtr),y
  4335  9b73 20209c             	jsr umult		; increase current size
  4336  9b76 8680               	stx curtol
  4337  9b78 8581               	sta curtol+1
  4338  9b7a a422               	ldy index		; restore index saved by umult
  4339  9b7c c60e               	dec count
  4340  9b7e d0dc               	bne loppta		; any more dims to do?
  4341  9b80 6563               	adc arypnt+1		; no, add total size of array to ptr
  4342  9b82 b05a               	bcs omerr1
  4343  9b84 8563               	sta arypnt+1
  4344  9b86 a8                 	tay
  4345  9b87 8a                 	txa
  4346  9b88 6562               	adc arypnt
  4347  9b8a 9003               	bcc grease
  4348  9b8c c8                 	iny
  4349  9b8d f04f               	beq omerr1
  4350                          
  4351  9b8f 205888             grease:	jsr reason		; 64k or 128k versions
  4352  9b92 8537               	sta strend
  4353  9b94 8438               	sty strend+1
  4354  9b96 a900               	lda #0
  4355  9b98 e681               	inc curtol+1
  4356  9b9a a480               	ldy curtol
  4357  9b9c f005               	beq deccur
  4358  9b9e 88                 zerita:	dey
  4359  9b9f 9162               	sta (arypnt),y
  4360  9ba1 d0fb               	bne zerita
  4361                          
  4362  9ba3 c663               deccur:	dec arypnt+1
  4363  9ba5 c681               	dec curtol+1
  4364  9ba7 d0f5               	bne zerita
  4365  9ba9 e663               	inc arypnt+1
  4366  9bab 38                 	sec
  4367  9bac a537               	lda strend
  4368  9bae e56b               	sbc lowtr
  4369  9bb0 a002               	ldy #2
  4370  9bb2 916b               	sta (lowtr),y
  4371  9bb4 a538               	lda strend+1
  4372  9bb6 c8                 	iny
  4373  9bb7 e56c               	sbc lowtr+1
  4374  9bb9 916b               	sta (lowtr),y
  4375  9bbb a510               	lda dimflg
  4376  9bbd d060               	bne dimrts
  4377  9bbf c8                 	iny
  4378                          
  4379  9bc0 b16b               getdef:	lda (lowtr),y
  4380  9bc2 850e               	sta count
  4381  9bc4 a900               	lda #0
  4382  9bc6 8580               	sta curtol
  4383  9bc8 8581               inlpnm:	sta curtol+1
  4384  9bca c8                 	iny
  4385  9bcb 68                 	pla
  4386  9bcc aa                 	tax
  4387  9bcd 8572               	sta indice
  4388  9bcf 68                 	pla
  4389  9bd0 8573               	sta indice+1
  4390  9bd2 b16b               	lda (lowtr),y
  4391  9bd4 c8                 	iny
  4392  9bd5 c573               	cmp indice+1
  4393  9bd7 f008               	beq inlpn0
  4394  9bd9 b00e               	bcs inlpn1
  4395  9bdb 4c159b             bserr7:	jmp bserr
  4396  9bde 4c2485             omerr1:	jmp omerr
  4397                          
  4398  9be1 b16b               inlpn0:	lda (lowtr),y
  4399  9be3 c572               	cmp indice
  4400  9be5 f0f4               	beq bserr7
  4401  9be7 90f2               	bcc bserr7
  4402                          
  4403  9be9 a581               inlpn1:	lda curtol+1
  4404  9beb 0580               	ora curtol
  4405  9bed 18                 	clc
  4406  9bee f00a               	beq addind
  4407  9bf0 20209c             	jsr umult
  4408  9bf3 8a                 	txa
  4409  9bf4 6572               	adc indice
  4410  9bf6 aa                 	tax
  4411  9bf7 98                 	tya
  4412  9bf8 a422               	ldy index1
  4413  9bfa 6573               addind:	adc indice+1
  4414  9bfc 8680               	stx curtol
  4415  9bfe c60e               	dec count
  4416  9c00 d0c6               	bne inlpnm
  4417  9c02 8581               	sta curtol+1
  4418  9c04 a205               	ldx #5			; maximum elt size is:
  4419  9c06 a54e               	lda varnam+1
  4420  9c08 20319b             	jsr sav44
  4421  9c0b 862a               	stx addend
  4422  9c0d a900               	lda #0
  4423  9c0f 20299c             	jsr umultd
  4424  9c12 8a                 	txa
  4425  9c13 6562               	adc arypnt
  4426  9c15 854f               	sta varpnt
  4427  9c17 98                 	tya
  4428  9c18 6563               	adc arypnt+1
  4429  9c1a 8550               	sta varpnt+1
  4430  9c1c a8                 	tay
  4431  9c1d a54f               	lda varpnt
  4432  9c1f 60                 dimrts:	rts
  4433                          ; -------------------------------------------------------------------------------------------------
  4434                          ; umult
  4435                          ;   two byte unsigned integer multiply.
  4436                          ;   for multiply dimensioned arrays.
  4437                          ;   x,y= x,a= curtol*lowtr,y,y+1
  4438                          
  4439  9c20 8422               umult:	sty index
  4440  9c22 b16b               	lda (lowtr),y
  4441  9c24 852a               	sta addend
  4442  9c26 88                 	dey
  4443  9c27 b16b               	lda (lowtr),y
  4444  9c29 852b               umultd:	sta addend+1
  4445  9c2b a910               	lda #16
  4446  9c2d 8569               	sta deccnt
  4447  9c2f a200               	ldx #0
  4448  9c31 a000               	ldy #0
  4449  9c33 8a                 umultc:	txa
  4450  9c34 0a                 	asl
  4451  9c35 aa                 	tax
  4452  9c36 98                 	tya
  4453  9c37 2a                 	rol
  4454  9c38 a8                 	tay
  4455  9c39 b0a3               	bcs omerr1
  4456  9c3b 0680               	asl curtol
  4457  9c3d 2681               	rol curtol+1
  4458  9c3f 900b               	bcc umlcnt
  4459  9c41 18                 	clc
  4460  9c42 8a                 	txa
  4461  9c43 652a               	adc addend
  4462  9c45 aa                 	tax
  4463  9c46 98                 	tya
  4464  9c47 652b               	adc addend+1
  4465  9c49 a8                 	tay
  4466  9c4a b092               	bcs omerr1
  4467  9c4c c669               umlcnt:	dec deccnt
  4468  9c4e d0e3               	bne umultc
  4469  9c50 60                 	rts
  4470                          ; -------------------------------------------------------------------------------------------------
  4471                          ; FRE
  4472                          ;   fre(expr) returns the number of available bytes in the specified bank. if 'expr' is string,
  4473                          ;   then the bank is assumed to be the string bank. if 'expr' is numeric, it must be a positive,
  4474                          ;   byte value to be used as the bank#. if the selected bank cannot be used for basic programs,
  4475                          ;   a zero is returned. garbage collection is always done whenever the string bank is selected.
  4476                          
  4477  9c51 a511               fre:	lda valtyp		; numeric or string param?
  4478  9c53 f006               	beq fref10		; numeric
  4479  9c55 20c3a7             	jsr frefac		; string... free temporary
  4480  9c58 4c609c             	jmp frefst
  4481                          
  4482  9c5b 206fae             fref10:	jsr conint		; .x = parameter
  4483  9c5e d010               	bne fref50
  4484  9c60 20f8ab             frefst:	jsr garba2		; compress out garbage strings
  4485  9c63 38                 	sec
  4486  9c64 a539               	lda fretop
  4487  9c66 e537               	sbc strend
  4488  9c68 a8                 	tay
  4489  9c69 a53a               	lda fretop+1
  4490  9c6b e538               	sbc strend+1
  4491  9c6d 4c739c             	jmp nosflt
  4492                          
  4493  9c70 a900               fref50:	lda #0
  4494  9c72 a8                 	tay
  4495                          ; unsigned double byte integer to float
  4496  9c73 20869c             nosflt:	jsr stoint
  4497  9c76 38                 	sec			; sign is positive
  4498  9c77 4c3ea1             	jmp floatc
  4499                          ; -------------------------------------------------------------------------------------------------
  4500                          ; POS
  4501                          ; function pos(x)
  4502  9c7a 38                 pos:	sec
  4503  9c7b 20f0ff             	jsr plot		; get current position
  4504                          
  4505                          ; signed single byte integer to float
  4506  9c7e a900               sngflt:	lda #0			; msd is 0, lsd in .y
  4507                          
  4508                          ; signed double byte integer to float
  4509  9c80 20869c             givayf:	jsr stoint
  4510  9c83 4c39a1             	jmp floats
  4511                          ; -------------------------------------------------------------------------------------------------
  4512                          ; stoint
  4513                          ;   mov int to fac and compute proper exponents
  4514  9c86 a200               stoint:	ldx #0
  4515  9c88 8611               	stx valtyp		; type is integer
  4516  9c8a 8570               	sta facho		; msd
  4517  9c8c 8471               	sty facho+1		; lsd
  4518  9c8e a290               	ldx #$90		; exponent
  4519  9c90 60                 storts:	rts
  4520                          ; -------------------------------------------------------------------------------------------------
  4521                          ; note
  4522                          ;   only single arguments are allowed to functions and functions must be of the single line form
  4523                          ;   def fna(x)= x^2+x-2
  4524                          ;   no strings can be involved with these functions
  4525                          ; 
  4526                          ; idea
  4527                          ;   create a simple variable entry whose 1st char has the 200 bit set.
  4528                          ;   the value will be
  4529                          ;   a text ptr to the formula
  4530                          ;   a ptr to the argument variable
  4531                          ; 
  4532                          ;   function names can be like 'fna4'.
  4533                          
  4534                          ; see if we are in direct mode.
  4535                          ; and complain if so.
  4536                          
  4537                          ; errdir - test direct? -> illegal direct error
  4538  9c91 209e9c             errdir:	jsr tstdir		; in direct mode?
  4539  9c94 d0fa               	bne storts		; no...
  4540  9c96 a240               	ldx #errid		; yes...'illegal direct'
  4541  9c98 2c                 	!byte $2c
  4542                          
  4543                          ; errguf - undefined function error
  4544  9c99 a24c               errguf:	ldx #erruf		; udf never defined
  4545  9c9b 4c2685             	jmp error
  4546                          ; -------------------------------------------------------------------------------------------------
  4547                          ; tstdir
  4548                          ;   test if execution is in direct mode
  4549                          ;   return z=1 if direct, z=0 otherwise
  4550                          
  4551  9c9e a541               tstdir:	lda curlin+1
  4552  9ca0 c9ff               	cmp #$ff
  4553  9ca2 60                 	rts
  4554                          tdm =tstdir
  4555                          ; -------------------------------------------------------------------------------------------------
  4556                          ; getfnm - get a ptr to a function name
  4557                          
  4558  9ca3 a9a5               getfnm:	lda #tkfn		;  must start with fn
  4559  9ca5 20ec96             	jsr synchr
  4560  9ca8 0980               	ora #$80		;  .a<-1st char of fn name+$80
  4561  9caa 8514               	sta subflg		;  indicates parsing fn
  4562  9cac 20c898             	jsr ptrgt2
  4563  9caf 8559               	sta defpnt		;  defpnt<-ptr to ftn
  4564  9cb1 845a               	sty defpnt+1
  4565  9cb3 865b               	stx defpnt+2
  4566  9cb5 4c9aae             	jmp chknum
  4567                          ; -------------------------------------------------------------------------------------------------
  4568                          ; fndoer
  4569                          
  4570  9cb8 20a39c             fndoer:	jsr getfnm
  4571  9cbb a55b               	lda defpnt+2		; stack <- ptr to ftn (defpnt)
  4572  9cbd 48                 	pha
  4573  9cbe a55a               	lda defpnt+1
  4574  9cc0 48                 	pha
  4575  9cc1 a559               	lda defpnt
  4576  9cc3 48                 	pha
  4577  9cc4 20de96             	jsr parchk		; compute actual param, check for parens
  4578  9cc7 209aae             	jsr chknum
  4579  9cca 68                 	pla			;  defpnt <- stack
  4580  9ccb 8559               	sta defpnt
  4581  9ccd 68                 	pla
  4582  9cce 855a               	sta defpnt+1
  4583  9cd0 68                 	pla
  4584  9cd1 a002               	ldy #2			;  varpnt <- ptr for formal param
  4585  9cd3 b159               	lda (defpnt),y
  4586  9cd5 854f               	sta varpnt
  4587  9cd7 aa                 	tax
  4588  9cd8 c8                 	iny
  4589  9cd9 b159               	lda (defpnt),y
  4590  9cdb 8550               	sta varpnt+1
  4591  9cdd 054f               	ora varpnt		; null ptr => undef'd
  4592  9cdf f0b8               	beq errguf
  4593  9ce1 c8                 	iny
  4594  9ce2 b159               	lda (defpnt),y
  4595  9ce4 b14f               fndo50:	lda (varpnt),y		;  push old value of formal param
  4596  9ce6 48                 	pha
  4597  9ce7 88                 	dey
  4598  9ce8 10fa               	bpl fndo50
  4599  9cea a450               	ldy varpnt+1		; init formal param with fac
  4600  9cec a551               	lda varpnt+2
  4601  9cee 20c9a0             	jsr movumf
  4602  9cf1 a584               	lda txtptr+1		;  stack <- text ptr
  4603  9cf3 48                 	pha
  4604  9cf4 a583               	lda txtptr
  4605  9cf6 48                 	pha
  4606  9cf7 b159               	lda (defpnt),y		; text ptr <- ptr to ftn body text
  4607  9cf9 8583               	sta txtptr
  4608  9cfb c8                 	iny
  4609  9cfc b159               	lda (defpnt),y
  4610  9cfe 8584               	sta txtptr+1
  4611  9d00 a550               	lda varpnt+1
  4612  9d02 48                 	pha
  4613  9d03 a54f               	lda varpnt
  4614  9d05 48                 	pha
  4615  9d06 2097ae             	jsr frmnum		;  compute the ftn body
  4616  9d09 68                 	pla			;  defpnt <- ptr to formal
  4617  9d0a 8559               	sta defpnt
  4618  9d0c 68                 	pla
  4619  9d0d 855a               	sta defpnt+1
  4620  9d0f 2081b3             	jsr chrgot
  4621  9d12 f003               	beq deffi		;  no multi-stmt ftn bodies
  4622  9d14 4c0e97             	jmp snerr		; -> syntax error, ready
  4623                          
  4624  9d17 68                 deffi:	pla			;  restore text ptr
  4625  9d18 8583               	sta txtptr
  4626  9d1a 68                 	pla
  4627  9d1b 8584               	sta txtptr+1
  4628                          
  4629                          ; when entered from defstf, deffin is used to restore the pre-function call value of the formal
  4630                          ; parameter (5 bytes).
  4631                          ; when entered from defn, deffin is used to initialize the ftn's symbol table entry with a ptr to
  4632                          ; the text for the ftn body (2 bytes) and a ptr to the data area of the formal parameter (3 bytes)
  4633  9d1d a000               deffin:	ldy #0
  4634  9d1f 68                 	pla
  4635  9d20 9159               	sta (defpnt),y
  4636  9d22 68                 	pla
  4637  9d23 c8                 	iny
  4638  9d24 9159               	sta (defpnt),y
  4639  9d26 68                 	pla
  4640  9d27 c8                 	iny
  4641  9d28 9159               	sta (defpnt),y
  4642  9d2a 68                 	pla
  4643  9d2b c8                 	iny
  4644  9d2c 9159               	sta (defpnt),y
  4645  9d2e 68                 	pla
  4646  9d2f c8                 	iny
  4647  9d30 9159               	sta (defpnt),y
  4648  9d32 60                 	rts
  4649                          ; -------------------------------------------------------------------------------------------------
  4650                          ; PEEK
  4651                          
  4652  9d33 a51c               peek:	lda poker+1
  4653  9d35 48                 	pha
  4654  9d36 a51b               	lda poker
  4655  9d38 48                 	pha
  4656  9d39 207eae             	jsr getadr
  4657  9d3c ad40de             	lda via2+prb		; get MMU reg
  4658  9d3f aa                 	tax			; save in .x
  4659  9d40 29f0               	and #%11110000		; clear RAM0 bank bits# 0-3
  4660  9d42 0d5702             	ora dfbank		
  4661  9d45 8d40de             	sta via2+prb 		; set default RAM0 bank
  4662  9d48 a000               	ldy #0
  4663  9d4a b11b               	lda (poker),y
  4664  9d4c 8e40de             	stx via2+prb		; restore RAM0 bank
  4665  9d4f a8                 	tay
  4666  9d50 68                 	pla
  4667  9d51 851b               	sta poker
  4668  9d53 68                 	pla
  4669  9d54 851c               	sta poker+1
  4670  9d56 4c7e9c             	jmp sngflt
  4671                          ; -------------------------------------------------------------------------------------------------
  4672                          ; faddh
  4673                          
  4674  9d59 a920               faddh:	lda #<fhalf
  4675  9d5b a0a4               	ldy #>fhalf
  4676  9d5d d01d               	bne fadd
  4677                          
  4678  9d5f 208e9f             fsub:	jsr conupk
  4679                          ; -------------------------------------------------------------------------------------------------
  4680                          ; MINUS
  4681                          
  4682  9d62 2090a4             fsubt:	jsr sav41
  4683  9d65 457c               	eor argsgn
  4684  9d67 857d               	sta arisgn
  4685  9d69 a56f               	lda facexp
  4686  9d6b 4c7f9d             	jmp faddt
  4687                          
  4688  9d6e a487               sav75:	ldy buffpt+1
  4689  9d70 a686               	ldx buffpt
  4690  9d72 d001               	bne sav76
  4691  9d74 88                 	dey
  4692                          
  4693  9d75 ca                 sav76:	dex
  4694  9d76 60                 zerrts:	rts
  4695                          
  4696  9d77 20ab9e             fadd5:	jsr shiftr
  4697  9d7a 903c               	bcc fadd4		; always
  4698  9d7c 208e9f             fadd:	jsr conupk
  4699                          ; -------------------------------------------------------------------------------------------------
  4700                          ; PLUS
  4701                          
  4702  9d7f d003               faddt:	bne faddb
  4703  9d81 4cf1a0             	jmp movfa
  4704                          
  4705  9d84 a67e               faddb:	ldx facov
  4706  9d86 8661               	stx oldov
  4707  9d88 a277               	ldx #<argexp
  4708  9d8a a577               	lda argexp
  4709  9d8c a8                 faddc:	tay
  4710  9d8d f0e7               	beq zerrts
  4711  9d8f 38                 	sec
  4712  9d90 e56f               	sbc facexp
  4713  9d92 f024               	beq fadd4
  4714  9d94 9012               	bcc fadda
  4715  9d96 846f               	sty facexp
  4716  9d98 a47c               	ldy argsgn
  4717  9d9a 8474               	sty facsgn
  4718  9d9c 49ff               	eor #$ff
  4719  9d9e 6900               	adc #0
  4720  9da0 a000               	ldy #0
  4721  9da2 8461               	sty oldov
  4722  9da4 a26f               	ldx #<fac
  4723  9da6 d004               	bne fadd1
  4724  9da8 a000               fadda:	ldy #0
  4725  9daa 847e               	sty facov
  4726  9dac c9f9               fadd1:	cmp #$f9
  4727  9dae 30c7               	bmi fadd5
  4728  9db0 a8                 	tay
  4729  9db1 a57e               	lda facov
  4730  9db3 5601               	lsr zp+1,x
  4731  9db5 20c29e             	jsr rolshf
  4732  9db8 247d               fadd4:	bit arisgn
  4733  9dba 1057               	bpl fadd2
  4734  9dbc a06f               	ldy #<facexp
  4735  9dbe e077               	cpx #<argexp
  4736  9dc0 f002               	beq subit
  4737  9dc2 a077               	ldy #<argexp
  4738  9dc4 38                 subit:	sec
  4739  9dc5 49ff               	eor #$ff
  4740  9dc7 6561               	adc oldov
  4741  9dc9 857e               	sta facov
  4742  9dcb b90400             	lda zp+3+addprc,y
  4743  9dce f504               	sbc zp+3+addprc,x
  4744  9dd0 8573               	sta faclo
  4745  9dd2 b90300             	lda zp+2+addprc,y
  4746  9dd5 f503               	sbc zp+2+addprc,x
  4747  9dd7 8572               	sta facmo
  4748  9dd9 b90200             	lda zp+2,y
  4749  9ddc f502               	sbc zp+2,x
  4750  9dde 8571               	sta facmoh
  4751  9de0 b90100             	lda zp+1,y
  4752  9de3 f501               	sbc zp+1,x
  4753  9de5 8570               	sta facho
  4754  9de7 b003               fadflt:	bcs normal
  4755  9de9 205c9e             	jsr negfac
  4756  9dec a000               normal:	ldy #0
  4757  9dee 98                 	tya
  4758  9def 18                 	clc
  4759  9df0 a670               norm3:	ldx facho
  4760  9df2 d04a               	bne norm1
  4761  9df4 a671               	ldx facho+1
  4762  9df6 8670               	stx facho
  4763  9df8 a672               	ldx facmoh+1
  4764  9dfa 8671               	stx facmoh
  4765  9dfc a673               	ldx facmo+1
  4766  9dfe 8672               	stx facmo
  4767  9e00 a67e               	ldx facov
  4768  9e02 8673               	stx faclo
  4769  9e04 847e               	sty facov
  4770  9e06 6908               	adc #$08
  4771  9e08 c920               	cmp #$18+addpr8
  4772  9e0a d0e4               	bne norm3
  4773  9e0c a900               zerofc:	lda #0
  4774  9e0e 856f               zerof1:	sta facexp
  4775  9e10 8574               zeroml:	sta facsgn
  4776  9e12 60                 	rts
  4777                          ; -------------------------------------------------------------------------------------------------
  4778                          ; fadd2
  4779                          
  4780  9e13 6561               fadd2:	adc oldov
  4781  9e15 857e               	sta facov
  4782  9e17 a573               	lda faclo
  4783  9e19 657b               	adc arglo
  4784  9e1b 8573               	sta faclo
  4785  9e1d a572               	lda facmo
  4786  9e1f 657a               	adc argmo
  4787  9e21 8572               	sta facmo
  4788  9e23 a571               	lda facmoh
  4789  9e25 6579               	adc argmoh
  4790  9e27 8571               	sta facmoh
  4791  9e29 a570               	lda facho
  4792  9e2b 6578               	adc argho
  4793  9e2d 8570               	sta facho
  4794  9e2f 4c4b9e             	jmp squeez
  4795                          
  4796  9e32 6901               norm2:	adc #1
  4797  9e34 067e               	asl facov
  4798  9e36 2673               	rol faclo
  4799  9e38 2672               	rol facmo
  4800  9e3a 2671               	rol facmoh
  4801  9e3c 2670               	rol facho
  4802  9e3e 10f2               norm1:	bpl norm2
  4803  9e40 38                 	sec
  4804  9e41 e56f               	sbc facexp
  4805  9e43 b0c7               	bcs zerofc
  4806  9e45 49ff               	eor #$ff
  4807  9e47 6901               	adc #1
  4808  9e49 856f               	sta facexp
  4809  9e4b 900e               squeez:	bcc rndrts
  4810  9e4d e66f               rndshf:	inc facexp
  4811  9e4f f03f               	beq overr
  4812  9e51 6670               	ror facho
  4813  9e53 6671               	ror facmoh
  4814  9e55 6672               	ror facmo
  4815  9e57 6673               	ror faclo
  4816  9e59 667e               	ror facov
  4817  9e5b 60                 rndrts:	rts
  4818                          ; -------------------------------------------------------------------------------------------------
  4819                          ; negfac
  4820                          
  4821  9e5c 2090a4             negfac:	jsr sav41
  4822                          
  4823  9e5f a570               negfch:	lda facho
  4824  9e61 49ff               	eor #$ff
  4825  9e63 8570               	sta facho
  4826  9e65 a571               	lda facmoh
  4827  9e67 49ff               	eor #$ff
  4828  9e69 8571               	sta facmoh
  4829  9e6b a572               	lda facmo
  4830  9e6d 49ff               	eor #$ff
  4831  9e6f 8572               	sta facmo
  4832  9e71 a573               	lda faclo
  4833  9e73 49ff               	eor #$ff
  4834  9e75 8573               	sta faclo
  4835  9e77 a57e               	lda facov
  4836  9e79 49ff               	eor #$ff
  4837  9e7b 857e               	sta facov
  4838  9e7d e67e               	inc facov
  4839  9e7f d00e               	bne incfrt
  4840  9e81 e673               incfac:	inc faclo
  4841  9e83 d00a               	bne incfrt
  4842  9e85 e672               	inc facmo
  4843  9e87 d006               	bne incfrt
  4844  9e89 e671               	inc facmoh
  4845  9e8b d002               	bne incfrt
  4846  9e8d e670               	inc facho
  4847  9e8f 60                 incfrt:	rts
  4848                          ; -------------------------------------------------------------------------------------------------
  4849                          ; overflow error
  4850                          
  4851  9e90 a234               overr:	ldx #errov
  4852  9e92 4c2685             	jmp error
  4853                          ; -------------------------------------------------------------------------------------------------
  4854                          ; mulshf
  4855                          
  4856  9e95 a227               mulshf:	ldx #<(resho-1)
  4857  9e97 b404               shftr2:	ldy zp+3+addprc,x
  4858  9e99 847e               	sty facov
  4859  9e9b b403               	ldy zp+3,x
  4860  9e9d 9404               	sty zp+4,x
  4861  9e9f b402               	ldy zp+2,x
  4862  9ea1 9403               	sty zp+3,x
  4863  9ea3 b401               	ldy zp+1,x
  4864  9ea5 9402               	sty zp+2,x
  4865  9ea7 a476               	ldy bits
  4866  9ea9 9401               	sty zp+1,x
  4867  9eab 6908               shiftr:	adc #$08
  4868  9ead 30e8               	bmi shftr2
  4869  9eaf f0e6               	beq shftr2
  4870  9eb1 e908               	sbc #$08
  4871  9eb3 a8                 	tay
  4872  9eb4 a57e               	lda facov
  4873  9eb6 b014               	bcs shftrt
  4874  9eb8 1601               shftr3:	asl zp+1,x
  4875  9eba 9002               	bcc shftr4
  4876  9ebc f601               	inc zp+1,x
  4877  9ebe 7601               shftr4:	ror zp+1,x
  4878  9ec0 7601               	ror zp+1,x
  4879  9ec2 7602               rolshf:	ror zp+2,x
  4880  9ec4 7603               	ror zp+3,x
  4881  9ec6 7604               	ror zp+4,x
  4882  9ec8 6a                 	ror
  4883  9ec9 c8                 	iny
  4884  9eca d0ec               	bne shftr3
  4885  9ecc 18                 shftrt:	clc
  4886  9ecd 60                 	rts
  4887                          
  4888                          ; constants
  4889  9ece 8100000000         fone:	!byte $81,0,0,0,0		; 1
  4890  9ed3 03                 logcn2:	!byte $03			; 4 log constants (polynom 3)
  4891  9ed4 7f5e56cb79         	!byte $7f,$5e,$56,$cb,$79	; 0.434255942
  4892  9ed9 80139b0b64         	!byte $80,$13,$9b,$0b,$64	; 0.576584541
  4893  9ede 8076389316         	!byte $80,$76,$38,$93,$16	; 0.961800759
  4894  9ee3 8238aa3b20         	!byte $82,$38,$aa,$3b,$20	; 2.885390007
  4895  9ee8 803504f334         sqr05:	!byte $80,$35,$04,$f3,$34	; 1/2 sqr 2
  4896  9eed 813504f334         sqr20:	!byte $81,$35,$04,$f3,$34	; sqr 2
  4897  9ef2 8080000000         neghlf:	!byte $80,$80,0,0,0		; -0.5
  4898  9ef7 80317217f8         log2:	!byte $80,$31,$72,$17,$f8	; log 2
  4899                          ; ******************************************* MATH3 ***********************************************
  4900                          ; LOG
  4901                          
  4902  9efc 2020a1             log:	jsr sign
  4903  9eff f002               	beq logerr
  4904  9f01 1003               	bpl log1
  4905  9f03 4c189b             logerr:	jmp fcerr		; -> illegal quantity error, ready
  4906                          
  4907  9f06 a56f               log1:	lda facexp
  4908  9f08 e97f               	sbc #$7f
  4909  9f0a 48                 	pha
  4910  9f0b a980               	lda #$80
  4911  9f0d 856f               	sta facexp
  4912  9f0f a9e8               	lda #<sqr05
  4913  9f11 a09e               	ldy #>sqr05
  4914  9f13 207c9d             	jsr fadd
  4915  9f16 a9ed               	lda #<sqr20
  4916  9f18 a09e               	ldy #>sqr20
  4917  9f1a 2011a0             	jsr fdiv
  4918  9f1d a9ce               	lda #<fone
  4919  9f1f a09e               	ldy #>fone
  4920  9f21 205f9d             	jsr fsub
  4921  9f24 a9d3               	lda #<logcn2
  4922  9f26 a09e               	ldy #>logcn2
  4923  9f28 2018a5             	jsr polyx
  4924  9f2b a9f2               	lda #<neghlf
  4925  9f2d a09e               	ldy #>neghlf
  4926  9f2f 207c9d             	jsr fadd
  4927  9f32 68                 	pla
  4928  9f33 207ca2             	jsr finlog
  4929  9f36 a9f7               	lda #<log2
  4930  9f38 a09e               	ldy #>log2
  4931                          
  4932                          ; -------------------------------------------------------------------------------------------------
  4933                          ; MULTIPLY
  4934  9f3a 208e9f             fmult:	jsr conupk
  4935                          
  4936  9f3d f04e               fmultt:	beq multrt
  4937                          
  4938  9f3f 20b99f             	jsr muldiv
  4939  9f42 a900               	lda #0
  4940  9f44 8528               	sta resho
  4941  9f46 8529               	sta resmoh
  4942  9f48 852a               	sta resmo
  4943  9f4a 852b               	sta reslo
  4944  9f4c a57e               	lda facov
  4945  9f4e 20689f             	jsr mltply
  4946  9f51 a573               	lda faclo
  4947  9f53 20689f             	jsr mltply
  4948  9f56 a572               	lda facmo
  4949  9f58 20689f             	jsr mltply
  4950  9f5b a571               	lda facmoh
  4951  9f5d 20689f             	jsr mltply
  4952  9f60 a570               	lda facho
  4953  9f62 206d9f             	jsr mltpl1
  4954  9f65 4c85a0             	jmp movfr
  4955                          
  4956  9f68 d003               mltply:	bne mltpl1
  4957  9f6a 4c959e             	jmp mulshf
  4958                          
  4959  9f6d 4a                 mltpl1:	lsr
  4960  9f6e 0980               	ora #$80
  4961  9f70 a8                 mltpl2:	tay
  4962  9f71 900c               	bcc mltpl3
  4963  9f73 18                 	clc
  4964  9f74 a203               	ldx #3
  4965                          
  4966  9f76 b528               mltpl4:	lda resho,x
  4967  9f78 7578               	adc argho,x
  4968  9f7a 9528               	sta resho,x
  4969  9f7c ca                 	dex
  4970  9f7d 10f7               	bpl mltpl4
  4971  9f7f 6628               mltpl3:	ror resho
  4972  9f81 6629               	ror resmoh
  4973  9f83 662a               	ror resmo
  4974  9f85 662b               	ror reslo
  4975  9f87 667e               	ror facov
  4976  9f89 98                 	tya
  4977  9f8a 4a                 	lsr
  4978  9f8b d0e3               	bne mltpl2
  4979  9f8d 60                 multrt:	rts
  4980                          ; -------------------------------------------------------------------------------------------------
  4981                          ; conupk
  4982                          ;    move, typically a basic rom constant, into fac
  4983                          ;    enter: .a,.y  pointer to value
  4984                          ;    .x     bank# (ucnupk)
  4985                          
  4986                          conupk:
  4987  9f8e 8522               ucnupk:	sta index1
  4988  9f90 8423               	sty index1+1
  4989  9f92 a004               	ldy #4
  4990  9f94 b122               	lda (index1),y
  4991  9f96 857b               	sta arglo
  4992  9f98 88                 	dey
  4993  9f99 b122               	lda (index1),y
  4994  9f9b 857a               	sta argmo
  4995  9f9d 88                 	dey
  4996  9f9e b122               	lda (index1),y
  4997  9fa0 8579               	sta argmoh
  4998  9fa2 88                 	dey
  4999  9fa3 b122               	lda (index1),y
  5000  9fa5 857c               	sta argsgn
  5001  9fa7 4574               	eor facsgn
  5002  9fa9 857d               	sta arisgn
  5003  9fab a57c               	lda argsgn
  5004  9fad 0980               	ora #$80
  5005  9faf 8578               	sta argho
  5006  9fb1 88                 	dey
  5007  9fb2 b122               	lda (index1),y
  5008  9fb4 8577               	sta argexp
  5009  9fb6 a56f               	lda facexp
  5010  9fb8 60                 	rts
  5011                          ; -------------------------------------------------------------------------------------------------
  5012                          ; muldiv
  5013                          
  5014  9fb9 a577               muldiv:	lda argexp
  5015  9fbb f01f               mldexp:	beq zeremv
  5016  9fbd 18                 	clc
  5017  9fbe 656f               	adc facexp
  5018  9fc0 9004               	bcc tryoff
  5019  9fc2 301d               	bmi goover
  5020  9fc4 18                 	clc
  5021  9fc5 2c                 	!byte $2c
  5022  9fc6 1014               tryoff:	bpl zeremv
  5023  9fc8 6980               	adc #$80
  5024  9fca 856f               	sta facexp
  5025  9fcc d003               	bne *+5
  5026  9fce 4c109e             	jmp zeroml
  5027                          
  5028  9fd1 a57d               	lda arisgn
  5029  9fd3 8574               	sta facsgn
  5030  9fd5 60                 	rts
  5031  9fd6 a574               mldvex:	lda facsgn
  5032  9fd8 49ff               	eor #$ff
  5033  9fda 3005               	bmi goover
  5034  9fdc 68                 zeremv:	pla
  5035  9fdd 68                 	pla
  5036  9fde 4c0c9e             	jmp zerofc
  5037                          
  5038  9fe1 4c909e             goover:	jmp overr
  5039                          ; -------------------------------------------------------------------------------------------------
  5040                          ; multiply by 10
  5041                          
  5042  9fe4 2001a1             mul10:	jsr movaf
  5043  9fe7 aa                 	tax
  5044  9fe8 f010               	beq mul10r
  5045  9fea 18                 	clc
  5046  9feb 6902               	adc #2
  5047  9fed b0f2               	bcs goover
  5048  9fef a200               finml6:	ldx #0
  5049  9ff1 867d               	stx arisgn
  5050  9ff3 208c9d             	jsr faddc
  5051  9ff6 e66f               	inc facexp
  5052  9ff8 f0e7               	beq goover
  5053  9ffa 60                 mul10r:	rts
  5054                          ; -------------------------------------------------------------------------------------------------
  5055                          ; constant 10
  5056  9ffb 8420000000         tenc	!byte $84,$20,0,0,0		
  5057                          ; -------------------------------------------------------------------------------------------------
  5058                          ; divide by 10
  5059                          
  5060  a000 2001a1             div10:	jsr movaf
  5061  a003 a9fb               	lda #<tenc
  5062  a005 a09f               	ldy #>tenc
  5063  a007 a200               	ldx #0
  5064  a009 867d               fdivf:	stx arisgn
  5065  a00b 2091a0             	jsr movfm
  5066  a00e 4c14a0             	jmp fdivt
  5067                          ; -------------------------------------------------------------------------------------------------
  5068                          ; DIVIDE
  5069  a011 208e9f             fdiv:	jsr conupk
  5070                          
  5071  a014 f05d               fdivt:	beq dv0err
  5072  a016 2010a1             	jsr round
  5073  a019 a900               	lda #0
  5074  a01b 38                 	sec
  5075  a01c e56f               	sbc facexp
  5076  a01e 856f               	sta facexp
  5077  a020 20b99f             	jsr muldiv
  5078  a023 e66f               	inc facexp
  5079  a025 f0ba               	beq goover
  5080  a027 a2fc               	ldx #$fc
  5081  a029 a901               	lda #1
  5082  a02b a478               divide:	ldy argho
  5083  a02d c470               	cpy facho
  5084  a02f d010               	bne savquo
  5085  a031 a479               	ldy argmoh
  5086  a033 c471               	cpy facmoh
  5087  a035 d00a               	bne savquo
  5088  a037 a47a               	ldy argmo
  5089  a039 c472               	cpy facmo
  5090  a03b d004               	bne savquo
  5091  a03d a47b               	ldy arglo
  5092  a03f c473               	cpy faclo
  5093  a041 08                 savquo:	php
  5094  a042 2a                 	rol
  5095  a043 9009               	bcc qshft
  5096  a045 e8                 	inx
  5097  a046 952b               	sta reslo,x
  5098  a048 f02e               	beq ld100
  5099  a04a 1030               	bpl divnrm
  5100  a04c a901               	lda #1
  5101  a04e 28                 qshft:	plp
  5102  a04f b00e               	bcs divsub
  5103  a051 067b               shfarg:	asl arglo
  5104  a053 267a               	rol argmo
  5105  a055 2679               	rol argmoh
  5106  a057 2678               	rol argho
  5107  a059 b0e6               	bcs savquo
  5108  a05b 30ce               	bmi divide
  5109  a05d 10e2               	bpl savquo
  5110  a05f a8                 divsub:	tay
  5111  a060 8a                 	txa
  5112  a061 48                 	pha
  5113  a062 a203               	ldx #3
  5114                          
  5115  a064 b578               divsb1:	lda argho,x
  5116  a066 f570               	sbc facho,x
  5117  a068 9578               	sta argho,x
  5118  a06a ca                 	dex
  5119  a06b 10f7               	bpl divsb1
  5120  a06d 68                 	pla
  5121  a06e aa                 	tax
  5122  a06f 98                 	tya
  5123  a070 4c51a0             	jmp shfarg
  5124                          
  5125  a073 a23e               dv0err:	ldx #errdvo		; division by zero error
  5126  a075 4c2685             	jmp error
  5127                          
  5128  a078 a940               ld100:	lda #$40
  5129  a07a d0d2               	bne qshft
  5130  a07c 0a                 divnrm:	asl
  5131  a07d 0a                 	asl
  5132  a07e 0a                 	asl
  5133  a07f 0a                 	asl
  5134  a080 0a                 	asl
  5135  a081 0a                 	asl
  5136  a082 857e               	sta facov
  5137  a084 28                 	plp
  5138                          ; -------------------------------------------------------------------------------------------------
  5139                          ; floating pt move routines
  5140                          ;   move data between memory and float "regs". letters following "mov" in each routine name tells
  5141                          ;   what that routine accomplishes: destination, source
  5142                          ;   fac <- res
  5143                          ;   movfr
  5144  a085 a203               movfr:	ldx #3
  5145                          
  5146  a087 b528               movfrz:	lda resho,x
  5147  a089 9570               	sta facho,x
  5148  a08b ca                 	dex
  5149  a08c 10f9               	bpl movfrz
  5150  a08e 4cec9d             	jmp normal
  5151                          ; -------------------------------------------------------------------------------------------------
  5152                          ;   movfm:   fac <- system memory
  5153                          ;   movfum:  fac <- user memory
  5154                          movfm:
  5155  a091 8522               movfum:	sta index1
  5156  a093 8423               	sty index1+1
  5157  a095 a004               	ldy #3+addprc
  5158  a097 b122               	lda (index1),y
  5159  a099 8573               	sta faclo
  5160  a09b 88                 	dey
  5161  a09c b122               	lda (index1),y
  5162  a09e 8572               	sta facmo
  5163  a0a0 88                 	dey
  5164  a0a1 b122               	lda (index1),y
  5165  a0a3 8571               	sta facmoh
  5166  a0a5 88                 	dey
  5167  a0a6 b122               	lda (index1),y
  5168  a0a8 8574               	sta facsgn
  5169  a0aa 0980               	ora #$80
  5170  a0ac 8570               	sta facho
  5171  a0ae 88                 	dey
  5172  a0af b122               	lda (index1),y
  5173  a0b1 856f               	sta facexp
  5174  a0b3 847e               	sty facov
  5175  a0b5 60                 	rts
  5176                          ; -------------------------------------------------------------------------------------------------
  5177                          ;   mov2f:  temp2f <- fac
  5178                          ;   mov1f:  temp1f <- fac
  5179                          ;   movmf:  system memory <- fac
  5180                          ;   movvf:  forpnt var  <- fac
  5181                          ;   movumf: user memory <- fac
  5182  a0b6 a268               mov2f:	ldx #<tempf2
  5183  a0b8 2c                 	!byte $2c
  5184  a0b9 a262               mov1f:	ldx #<tempf1
  5185  a0bb a000               	ldy #0
  5186  a0bd 2010a1             movmf:	jsr round
  5187  a0c0 4ccca0             	jmp mov001
  5188                          
  5189  a0c3 a652               movvf:	ldx forpnt
  5190  a0c5 a453               	ldy forpnt+1
  5191  a0c7 a554               	lda forpnt+2
  5192                          
  5193  a0c9 2010a1             movumf:	jsr round
  5194  a0cc 8423               mov001:	sty index1+1
  5195  a0ce 8622               	stx index1
  5196  a0d0 a004               	ldy #3+addprc
  5197  a0d2 a573               	lda faclo
  5198  a0d4 9122               	sta (index),y
  5199  a0d6 88                 	dey
  5200  a0d7 a572               	lda facmo
  5201  a0d9 9122               	sta (index),y
  5202  a0db 88                 	dey
  5203  a0dc a571               	lda facmoh
  5204  a0de 9122               	sta (index),y
  5205  a0e0 88                 	dey
  5206  a0e1 a574               	lda facsgn
  5207  a0e3 097f               	ora #$7f
  5208  a0e5 2570               	and facho
  5209  a0e7 9122               	sta (index),y
  5210  a0e9 88                 	dey
  5211  a0ea a56f               	lda facexp
  5212  a0ec 9122               	sta (index),y
  5213  a0ee 847e               	sty facov
  5214  a0f0 60                 	rts
  5215                          ; -------------------------------------------------------------------------------------------------
  5216                          ;   movfa:  fac <- arg register
  5217                          ;   movaf:  arg <- fac register
  5218  a0f1 a57c               movfa:	lda argsgn
  5219  a0f3 8574               movfa1:	sta facsgn
  5220  a0f5 a205               	ldx #4+addprc
  5221  a0f7 b576               movfal:	lda argexp-1,x
  5222  a0f9 956e               	sta facexp-1,x
  5223  a0fb ca                 	dex
  5224  a0fc d0f9               	bne movfal
  5225  a0fe 867e               	stx facov
  5226  a100 60                 	rts
  5227                          
  5228  a101 2010a1             movaf:	jsr round
  5229  a104 a206               movef:	ldx #5+addprc
  5230  a106 b56e               movafl:	lda facexp-1,x
  5231  a108 9576               	sta argexp-1,x
  5232  a10a ca                 	dex
  5233  a10b d0f9               	bne movafl
  5234  a10d 867e               	stx facov
  5235  a10f 60                 movrts:	rts
  5236                          ; -------------------------------------------------------------------------------------------------
  5237                          ; round
  5238                          
  5239  a110 a56f               round:	lda facexp
  5240  a112 f0fb               	beq movrts
  5241  a114 067e               	asl facov
  5242  a116 90f7               	bcc movrts
  5243                          
  5244  a118 20819e             incrnd:	jsr incfac
  5245  a11b d0f2               	bne movrts
  5246  a11d 4c4d9e             	jmp rndshf
  5247  a120 a56f               sign:	lda facexp
  5248  a122 f009               	beq signrt
  5249  a124 a574               fcsign:	lda facsgn
  5250  a126 2a                 fcomps:	rol
  5251  a127 a9ff               	lda #$ff
  5252  a129 b002               	bcs signrt
  5253  a12b a901               	lda #1
  5254  a12d 60                 signrt:	rts
  5255                          ; -------------------------------------------------------------------------------------------------
  5256                          ; SGN
  5257                          
  5258  a12e 2020a1             sgn:	jsr sign
  5259                          
  5260  a131 8570               float:	sta facho
  5261  a133 a900               	lda #0
  5262  a135 8571               	sta facho+1
  5263  a137 a288               	ldx #$88
  5264  a139 a570               floats:	lda facho
  5265  a13b 49ff               	eor #$ff
  5266  a13d 2a                 	rol
  5267  a13e a900               floatc:	lda #0
  5268  a140 8573               	sta faclo
  5269  a142 8572               	sta facmo
  5270  a144 866f               floatb:	stx facexp
  5271  a146 857e               	sta facov
  5272  a148 8574               	sta facsgn
  5273  a14a 4ce79d             	jmp fadflt
  5274                          ; -------------------------------------------------------------------------------------------------
  5275                          ; ABS
  5276                          
  5277  a14d 4674               abs:	lsr facsgn
  5278  a14f 60                 	rts
  5279                          ; -------------------------------------------------------------------------------------------------
  5280                          ; fcomp - compare fac with value stored in system memory
  5281                          ;   enter: .a,.y pointer to value
  5282                          
  5283  a150 8525               fcomp:	sta index2
  5284  a152 8426               fcompn:	sty index2+1		;  enter w/value on stack ("next")
  5285  a154 a000               	ldy #0
  5286  a156 2096a1             	jsr fcinx2 
  5287  a159 c8                 	iny
  5288  a15a aa                 	tax
  5289  a15b f0c3               	beq sign
  5290  a15d 2096a1             	jsr fcinx2 
  5291  a160 4574               	eor facsgn
  5292  a162 30c0               	bmi fcsign
  5293  a164 e46f               	cpx facexp
  5294  a166 d025               	bne fcompc
  5295  a168 2096a1             	jsr fcinx2 
  5296  a16b 0980               	ora #$80
  5297  a16d c570               	cmp facho
  5298  a16f d01c               	bne fcompc
  5299  a171 c8                 	iny
  5300  a172 2096a1             	jsr fcinx2 
  5301  a175 c571               	cmp facmoh
  5302  a177 d014               	bne fcompc
  5303  a179 c8                 	iny
  5304  a17a 2096a1             	jsr fcinx2 
  5305  a17d c572               	cmp facmo
  5306  a17f d00c               	bne fcompc
  5307  a181 c8                 	iny
  5308  a182 a97f               	lda #$7f
  5309  a184 c57e               	cmp facov
  5310  a186 2096a1             	jsr fcinx2 
  5311  a189 e573               	sbc faclo
  5312  a18b f02b               	beq qintrt
  5313  a18d a574               fcompc:	lda facsgn
  5314  a18f 9002               	bcc fcompd
  5315  a191 49ff               	eor #$ff
  5316  a193 4c26a1             fcompd:	jmp fcomps
  5317                          ; -------------------------------------------------------------------------------------------------
  5318                          ; fcinx2
  5319  a196 b125               fcinx2:	lda (index2),y
  5320  a198 60                 	rts
  5321                          ; ******************************************* MATH4 ***********************************************
  5322                          ; qint - quick greatest integer function.
  5323                          ;   leaves int(fac) in facho,mo,lo signed.
  5324                          ;   assumes fac < 2**23 = 8388608.
  5325                          
  5326  a199 a56f               qint:	lda facexp
  5327  a19b f04a               	beq clrfac
  5328  a19d 38                 	sec
  5329  a19e e9a0               	sbc #addpr8+$98
  5330  a1a0 2474               	bit facsgn
  5331  a1a2 1009               	bpl qishft
  5332  a1a4 aa                 	tax
  5333  a1a5 a9ff               	lda #$ff
  5334  a1a7 8576               	sta bits
  5335  a1a9 205f9e             	jsr negfch
  5336  a1ac 8a                 	txa
  5337  a1ad a26f               qishft:	ldx #<fac
  5338  a1af c9f9               	cmp #$f9
  5339  a1b1 1006               	bpl qint1
  5340  a1b3 20ab9e             	jsr shiftr
  5341  a1b6 8476               	sty bits
  5342  a1b8 60                 qintrt:	rts
  5343  a1b9 a8                 qint1:	tay
  5344  a1ba a574               	lda facsgn
  5345  a1bc 2980               	and #$80
  5346  a1be 4670               	lsr facho
  5347  a1c0 0570               	ora facho
  5348  a1c2 8570               	sta facho
  5349  a1c4 20c29e             	jsr rolshf
  5350  a1c7 8476               	sty bits
  5351  a1c9 60                 	rts
  5352                          ; -------------------------------------------------------------------------------------------------
  5353                          ; INT
  5354                          
  5355  a1ca a56f               int:	lda facexp
  5356  a1cc c9a0               	cmp #addpr8+$98
  5357  a1ce b020               	bcs intrts
  5358  a1d0 2099a1             	jsr qint
  5359  a1d3 847e               	sty facov
  5360  a1d5 a574               	lda facsgn
  5361  a1d7 8474               	sty facsgn
  5362  a1d9 4980               	eor #$80
  5363  a1db 2a                 	rol
  5364  a1dc a9a0               	lda #$98+8
  5365  a1de 856f               	sta facexp
  5366  a1e0 a573               	lda faclo
  5367  a1e2 850c               	sta integr
  5368  a1e4 4ce79d             	jmp fadflt
  5369  a1e7 8570               clrfac:	sta facho
  5370  a1e9 8571               	sta facmoh
  5371  a1eb 8572               	sta facmo
  5372  a1ed 8573               	sta faclo
  5373  a1ef a8                 	tay 
  5374  a1f0 60                 intrts:	rts
  5375                          ; -------------------------------------------------------------------------------------------------
  5376                          ; fin - number input is left in fac.
  5377                          ;   at entry txtptr -> to the 1st char in a text buf. the 1st char is also in acc.
  5378                          ;   fin packs the digits into the fac as an integer and keeps track of where the decimal point is.
  5379                          ;   dptflg tells whether a dp has been seen.  dccnt is the number of digits after the dp.
  5380                          ;   at the end dccnt and the exp are used to determine how many times to mult or div by 10 to
  5381                          ;   get the correct #.
  5382                          
  5383  a1f1 a000               fin:	ldy #$00
  5384  a1f3 a20c               	ldx #sgnflg-deccnt
  5385  a1f5 9469               finzlp:	sty deccnt,x
  5386  a1f7 ca                 	dex
  5387  a1f8 10fb               	bpl finzlp
  5388  a1fa 900f               	bcc findgq
  5389  a1fc c92d               	cmp #'-'
  5390  a1fe d004               	bne qplus
  5391  a200 8675               	stx sgnflg
  5392  a202 f004               	beq finc
  5393  a204 c92b               qplus:	cmp #'+'
  5394  a206 d005               	bne fin1
  5395  a208 207eb3             finc:	jsr chrget
  5396  a20b 905b               findgq:	bcc findig
  5397  a20d c92e               fin1:	cmp #'.'
  5398  a20f f02e               	beq findp
  5399  a211 c945               	cmp #'e'
  5400  a213 d030               	bne fine
  5401  a215 207eb3             	jsr chrget
  5402  a218 9017               	bcc fnedg1
  5403  a21a c9ab               	cmp #tkminu
  5404  a21c f00e               	beq finec1
  5405  a21e c92d               	cmp #'-'
  5406  a220 f00a               	beq finec1
  5407  a222 c9aa               	cmp #tkplus
  5408  a224 f008               	beq finec
  5409  a226 c92b               	cmp #'+'
  5410  a228 f004               	beq finec
  5411  a22a d007               	bne finec2
  5412  a22c 666d               finec1:	ror expsgn
  5413  a22e 207eb3             finec:	jsr chrget
  5414  a231 905c               fnedg1:	bcc finedg
  5415  a233 246d               finec2:	bit expsgn
  5416  a235 100e               	bpl fine
  5417  a237 a900               	lda #0
  5418  a239 38                 	sec
  5419  a23a e56a               	sbc tenexp
  5420  a23c 4c47a2             	jmp fine1
  5421                          ; findp
  5422  a23f 666c               findp:	ror dptflg
  5423  a241 246c               	bit dptflg
  5424  a243 50c3               	bvc finc
  5425  a245 a56a               fine:	lda tenexp
  5426  a247 38                 fine1:	sec
  5427  a248 e569               	sbc deccnt
  5428  a24a 856a               	sta tenexp
  5429  a24c f012               	beq finqng
  5430  a24e 1009               	bpl finmul
  5431  a250 2000a0             findiv:	jsr div10
  5432  a253 e66a               	inc tenexp
  5433  a255 d0f9               	bne findiv
  5434  a257 f007               	beq finqng
  5435  a259 20e49f             finmul:	jsr mul10
  5436  a25c c66a               	dec tenexp
  5437  a25e d0f9               	bne finmul
  5438  a260 a575               finqng:	lda sgnflg
  5439  a262 3001               	bmi negxqs
  5440  a264 60                 	rts
  5441                          
  5442  a265 4c8ca4             negxqs:	jmp negop
  5443                          ; findig
  5444  a268 48                 findig:	pha
  5445  a269 246c               	bit dptflg
  5446  a26b 1002               	bpl findg1
  5447  a26d e669               	inc deccnt
  5448  a26f 20e49f             findg1:	jsr mul10
  5449  a272 68                 	pla
  5450  a273 38                 	sec
  5451  a274 e930               	sbc #'0'
  5452  a276 207ca2             	jsr finlog
  5453  a279 4c08a2             	jmp finc
  5454                          ; finlog
  5455  a27c 48                 finlog:	pha
  5456  a27d 2001a1             	jsr movaf
  5457  a280 68                 	pla
  5458  a281 2031a1             	jsr float
  5459  a284 a57c               	lda argsgn
  5460  a286 4574               	eor facsgn
  5461  a288 857d               	sta arisgn
  5462  a28a a66f               	ldx facexp
  5463  a28c 4c7f9d             	jmp faddt
  5464                          ; finedg
  5465  a28f a56a               finedg:	lda tenexp
  5466  a291 c90a               	cmp #$0a
  5467  a293 9009               	bcc mlex10
  5468  a295 a964               	lda #$64
  5469  a297 246d               	bit expsgn
  5470  a299 3017               	bmi mlexmi
  5471  a29b 4c909e             	jmp overr
  5472                          
  5473  a29e 0a                 mlex10:	asl
  5474  a29f 0a                 	asl
  5475  a2a0 18                 	clc
  5476  a2a1 656a               	adc tenexp
  5477  a2a3 0a                 	asl
  5478  a2a4 18                 	clc
  5479  a2a5 a000               	ldy #0
  5480  a2a7 8d5b02             	sta tttemp
  5481  a2aa b183               	lda (txtptr),y
  5482  a2ac 6d5b02             	adc tttemp
  5483  a2af 38                 	sec
  5484  a2b0 e930               	sbc #'0'
  5485  a2b2 856a               mlexmi:	sta tenexp
  5486  a2b4 4c2ea2             	jmp finec
  5487                          ; -------------------------------------------------------------------------------------------------
  5488                          ; constants
  5489  a2b7 9b3ebc1ffd         n0999:	!byte $9b,$3e,$bc,$1f,$fd	; 99,999,999.0499
  5490  a2bc 9e6e6b27fd         n9999:	!byte $9e,$6e,$6b,$27,$fd	; 999,999,999.499
  5491  a2c1 9e6e6b2800         nmil:	!byte $9e,$6e,$6b,$28,0  	; 10**9
  5492                          ; -------------------------------------------------------------------------------------------------
  5493                          ; linprt	
  5494                          ;   entry   a= < of number
  5495                          ;   x= >of number
  5496                          
  5497  a2c6 8570               linprt:	sta facho
  5498  a2c8 8671               	stx facho+1
  5499  a2ca a290               	ldx #$90		; exponent is 2**16
  5500  a2cc 38                 	sec
  5501  a2cd 203ea1             	jsr floatc
  5502  a2d0 20f4a2             outfac:	jsr fout
  5503  a2d3 a222               	ldx #fbptr
  5504                          ; -------------------------------------------------------------------------------------------------
  5505                          ; msg - print a message
  5506                          ;   can also print the contents of fbuffr
  5507                          ;   entry:  .x =index into ebase, a table of start addresses of messages
  5508                          ;   data =sequential ascii characters
  5509                          ;   terminated by a zero byte
  5510                          ;   calls:  ldaabs, ochr
  5511                          
  5512  a2d5 bd6f82             msg:	lda ebase,x
  5513  a2d8 bc7082             	ldy ebase+1,x
  5514  a2db 8d5b02             	sta ldaadr
  5515  a2de 8c5c02             	sty ldaadr+1
  5516                          
  5517  a2e1 205a02             msgprt:	jsr ldaabs
  5518  a2e4 f00d               	beq msgrts		; zero byte terminator
  5519  a2e6 20cbae             	jsr ochr
  5520  a2e9 ee5b02             	inc ldaadr
  5521  a2ec d0f3               	bne msgprt
  5522  a2ee ee5c02             	inc ldaadr+1
  5523  a2f1 d0ee               	bne msgprt
  5524  a2f3 60                 msgrts:	rts
  5525                          ; -------------------------------------------------------------------------------------------------
  5526                          ; fout -  build string for formula result.
  5527                          
  5528  a2f4 a001               fout:	ldy #1
  5529  a2f6 a920               	lda #$20		; print space if positive
  5530  a2f8 2474               	bit facsgn
  5531  a2fa 1002               	bpl fout1
  5532  a2fc a92d               	lda #'-'
  5533  a2fe 99ff01             fout1:	sta fbuffr-1,y 		; store the char
  5534  a301 8574               	sta facsgn 		; make fac positive or qint.
  5535  a303 8480               	sty fbufpt 		; save for later
  5536  a305 c8                 	iny
  5537  a306 a930               	lda #'0'		; get zero to type if fac=0
  5538  a308 a66f               	ldx facexp
  5539  a30a d003               	bne fout10
  5540  a30c 4c16a4             	jmp fout19
  5541                          
  5542  a30f a900               fout10:	lda #0
  5543  a311 e080               	cpx #$80
  5544  a313 f002               	beq fout37 		; if number > 1.0
  5545  a315 b009               	bcs fout7
  5546  a317 a9c1               fout37:	lda #<nmil
  5547  a319 a0a2               	ldy #>nmil
  5548  a31b 203a9f             	jsr fmult  		; * 10**6
  5549  a31e a9f7               	lda #250-addpr2-addprc
  5550  a320 8569               fout7:	sta deccnt 		; save count or zero it
  5551  a322 a9bc               fout4:	lda #<n9999
  5552  a324 a0a2               	ldy #>n9999
  5553  a326 2050a1             	jsr fcomp  		; if num > 999,999.999
  5554  a329 f01e               	beq bigges
  5555  a32b 1012               	bpl fout9
  5556  a32d a9b7               fout3:	lda #<n0999
  5557  a32f a0a2               	ldy #>n0999
  5558  a331 2050a1             	jsr fcomp
  5559  a334 f002               	beq fout38
  5560  a336 100e               	bpl fout5
  5561  a338 20e49f             fout38:	jsr mul10
  5562  a33b c669               	dec deccnt
  5563  a33d d0ee               	bne fout3
  5564  a33f 2000a0             fout9:	jsr div10
  5565  a342 e669               	inc deccnt
  5566  a344 d0dc               	bne fout4
  5567  a346 20599d             fout5:	jsr faddh
  5568  a349 2099a1             bigges:	jsr qint
  5569  a34c a201               	ldx #1
  5570  a34e a569               	lda deccnt
  5571  a350 18                 	clc
  5572  a351 690a               	adc #addpr2+addprc+7
  5573  a353 3009               	bmi foutpi
  5574  a355 c90b               	cmp #addpr2+addprc+$08
  5575  a357 b006               	bcs fout6
  5576  a359 69ff               	adc #$ff
  5577  a35b aa                 	tax
  5578  a35c a902               	lda #2
  5579  a35e 38                 foutpi:	sec
  5580  a35f e902               fout6:	sbc #2
  5581  a361 856a               	sta tenexp
  5582  a363 8669               	stx deccnt
  5583  a365 8a                 	txa
  5584  a366 f002               	beq fout39
  5585  a368 1013               	bpl fout8
  5586  a36a a480               fout39:	ldy fbufpt
  5587  a36c a92e               	lda #'.'
  5588  a36e c8                 	iny
  5589  a36f 99ff01             	sta fbuffr-1,y
  5590  a372 8a                 	txa
  5591  a373 f006               	beq fout16
  5592  a375 a930               	lda #'0'
  5593  a377 c8                 	iny
  5594  a378 99ff01             	sta fbuffr-1,y
  5595  a37b 8480               fout16:	sty fbufpt
  5596                          
  5597  a37d a000               fout8:	ldy #0
  5598  a37f a280               	ldx #$80
  5599  a381 a573               fout2:	lda faclo
  5600  a383 18                 	clc
  5601  a384 7928a4             	adc foutbl+2+addprc,y
  5602  a387 8573               	sta faclo
  5603  a389 a572               	lda facmo
  5604  a38b 7927a4             	adc foutbl+1+addprc,y
  5605  a38e 8572               	sta facmo
  5606  a390 a571               	lda facmoh
  5607  a392 7926a4             	adc foutbl+1,y
  5608  a395 8571               	sta facmoh
  5609  a397 a570               	lda facho
  5610  a399 7925a4             	adc foutbl,y
  5611  a39c 8570               	sta facho
  5612  a39e e8                 	inx
  5613  a39f b003               	bcs fout41
  5614  a3a1 10de               	bpl fout2
  5615  a3a3 2c                 	!byte $2c    		; hop
  5616  a3a4 30db               fout41:	bmi fout2
  5617  a3a6 8a                 fout40:	txa
  5618  a3a7 9004               	bcc foutyp
  5619  a3a9 49ff               	eor #$ff
  5620  a3ab 690a               	adc #$0a
  5621  a3ad 692f               foutyp:	adc #$2f
  5622  a3af c8                 	iny
  5623  a3b0 c8                 	iny
  5624  a3b1 c8                 	iny
  5625  a3b2 c8                 	iny
  5626  a3b3 844f               	sty fdecpt
  5627  a3b5 a480               	ldy fbufpt
  5628  a3b7 c8                 	iny
  5629  a3b8 aa                 	tax
  5630  a3b9 297f               	and #$7f
  5631  a3bb 99ff01             	sta fbuffr-1,y
  5632  a3be c669               	dec deccnt
  5633  a3c0 d006               	bne stxbuf
  5634  a3c2 a92e               	lda #'.'
  5635  a3c4 c8                 	iny
  5636  a3c5 99ff01             	sta fbuffr-1,y
  5637  a3c8 8480               stxbuf:	sty fbufpt
  5638  a3ca a44f               	ldy fdecpt
  5639  a3cc 8a                 	txa
  5640  a3cd 49ff               	eor #$ff
  5641  a3cf 2980               	and #$80
  5642  a3d1 aa                 	tax
  5643  a3d2 c024               	cpy #fdcend-foutbl
  5644  a3d4 d0ab               	bne fout2
  5645  a3d6 a480               fouldy:	ldy fbufpt
  5646  a3d8 b9ff01             fout11:	lda fbuffr-1,y
  5647  a3db 88                 	dey
  5648  a3dc c930               	cmp #'0'
  5649  a3de f0f8               	beq fout11
  5650  a3e0 c92e               	cmp #'.'
  5651  a3e2 f001               	beq fout12
  5652  a3e4 c8                 	iny
  5653  a3e5 a92b               fout12:	lda #'+'
  5654  a3e7 a66a               	ldx tenexp
  5655  a3e9 f02e               	beq fout17
  5656  a3eb 1008               	bpl fout14
  5657  a3ed a900               	lda #0
  5658  a3ef 38                 	sec
  5659  a3f0 e56a               	sbc tenexp
  5660  a3f2 aa                 	tax
  5661  a3f3 a92d               	lda #'-'
  5662  a3f5 990102             fout14:	sta fbuffr+1,y
  5663  a3f8 a945               	lda #'e'
  5664  a3fa 990002             	sta fbuffr,y
  5665  a3fd 8a                 	txa
  5666  a3fe a22f               	ldx #$2f
  5667  a400 38                 	sec
  5668  a401 e8                 fout15:	inx
  5669  a402 e90a               	sbc #$0a
  5670  a404 b0fb               	bcs fout15
  5671  a406 693a               	adc #$3a
  5672  a408 990302             	sta fbuffr+3,y
  5673  a40b 8a                 	txa
  5674  a40c 990202             	sta fbuffr+2,y
  5675  a40f a900               	lda #0
  5676  a411 990402             	sta fbuffr+4,y
  5677  a414 f008               	beq fout20
  5678  a416 99ff01             fout19:	sta fbuffr-1,y
  5679  a419 a900               fout17:	lda #0
  5680  a41b 990002             	sta fbuffr,y
  5681  a41e 60                 fout20:	rts
  5682                          ; -------------------------------------------------------------------------------------------------
  5683                          ; constants
  5684                          
  5685  a41f 90                 n32768:	!byte $90        	; 32768 - must stay with fhalf and zero
  5686  a420 8000               fhalf:	!byte $80,0		; 0.5 for sqr
  5687  a422 000000             fzero:	!byte 0,0,0
  5688                          ; -------------------------------------------------------------------------------------------------
  5689                          ; power of ten table
  5690                          
  5691  a425 fa0a1f00           foutbl:	!byte $fa,$0a,$1f,$00   ; -100,000,000
  5692  a429 00989680           	!byte $00,$98,$96,$80   ; 10,000,000
  5693  a42d fff0bdc0           	!byte $ff,$f0,$bd,$c0   ; -1,000,000
  5694  a431 000186a0           	!byte $00,$01,$86,$a0   ; 100,000
  5695  a435 ffffd8f0           	!byte $ff,$ff,$d8,$f0   ; -10,000
  5696  a439 000003e8           	!byte $00,$00,$03,$e8   ; 1000
  5697  a43d ffffff9c           	!byte $ff,$ff,$ff,$9c   ; -100
  5698  a441 0000000a           	!byte $00,$00,$00,$0a   ; 10
  5699  a445 ffffffff           	!byte $ff,$ff,$ff,$ff   ; -1
  5700                          fdcend:
  5701                          ;	!byte $ff,$df,$0a,$80   ; -216,000 for time converter
  5702                          ;	!byte $00,$03,$4b,$c0   ; 216,000
  5703                          ;	!byte $ff,$ff,$73,$60   ; -36000
  5704                          ;	!byte $00,$00,$0e,$10   ; 3600
  5705                          ;	!byte $ff,$ff,$fd,$a8   ; -600
  5706                          ;	!byte $00,$00,$00,$3c   ; 60
  5707                          ;timend
  5708                          ; -------------------------------------------------------------------------------------------------
  5709                          ; SQR - square root function  sqr(a)
  5710                          ;   uses sqr(a) == a**0.5
  5711  a449 2001a1             sqr:	jsr movaf
  5712  a44c a920               	lda #<fhalf
  5713  a44e a0a4               	ldy #>fhalf
  5714  a450 2091a0             	jsr movfm
  5715                          ;	jmp fpwrt  		; last thing fetched is facexp into accx
  5716                          ; -------------------------------------------------------------------------------------------------
  5717                          ; EXP - exponentation x**y
  5718                          ;   if y = 0 then results = 1.
  5719                          ;   if x = 0 then results = 0.
  5720                          ;   if x > 0, if not check that y is an integer.
  5721                          ;   if so, negate x, so that log doesn't give fcerr.
  5722                          ;   if x is negative and y is odd, negate the result.
  5723                          ;   returned by exp.
  5724                          ;   to compute the use x**y=exp((y*log(x)).
  5725                          
  5726  a453 f070               fpwrt:	beq exp			; if fac=0, just exponentiaaate that
  5727  a455 a577               	lda argexp
  5728  a457 d003               	bne fpwrt1 		; if x <> 0
  5729  a459 4c0e9e             	jmp zerof1
  5730                          
  5731  a45c a259               fpwrt1:	ldx #<tempf3
  5732  a45e a000               	ldy #>tempf3
  5733  a460 20bda0             	jsr movmf
  5734                          
  5735                          ; y=0 already.  good in case no one calls int.
  5736  a463 a57c               	lda argsgn
  5737  a465 100f               	bpl fpwr1  		; no problems if x > 0
  5738  a467 20caa1             	jsr int			; integerize the fac
  5739  a46a a959               	lda #<tempf3		; get comperand adr
  5740  a46c a000               	ldy #>tempf3
  5741  a46e 2050a1             	jsr fcomp
  5742  a471 d003               	bne fpwr1
  5743  a473 98                 	tya
  5744  a474 a40c               	ldy integr
  5745  a476 20f3a0             fpwr1:	jsr movfa1
  5746  a479 98                 	tya
  5747  a47a 48                 	pha
  5748  a47b 20fc9e             	jsr log
  5749  a47e a959               	lda #<tempf3
  5750  a480 a000               	ldy #>tempf3
  5751  a482 203a9f             	jsr fmult
  5752  a485 20c5a4             	jsr exp
  5753  a488 68                 	pla
  5754  a489 4a                 	lsr
  5755  a48a 900a               	bcc negrts
  5756                          ; -------------------------------------------------------------------------------------------------
  5757                          ; NEG
  5758                          
  5759  a48c a56f               negop:	lda facexp
  5760  a48e f006               	beq negrts
  5761                          ; -------------------------------------------------------------------------------------------------
  5762                          ; sav41
  5763  a490 a574               sav41:	lda facsgn
  5764  a492 49ff               	eor #$ff
  5765  a494 8574               	sta facsgn
  5766  a496 60                 negrts:	rts
  5767                          ; -------------------------------------------------------------------------------------------------
  5768                          ; constants
  5769                          
  5770  a497 8138aa3b29         logeb2:	!byte $81,$38,$aa,$3b,$29	; log(e) base 2
  5771                          
  5772  a49c 07                 expcon:	!byte 7				; 8 exp constants (polynom 7)
  5773  a49d 7134583e56         	!byte $71,$34,$58,$3e,$56		
  5774  a4a2 74167eb31b         	!byte $74,$16,$7e,$b3,$1b
  5775  a4a7 772feee385         	!byte $77,$2f,$ee,$e3,$85
  5776  a4ac 7a1d841c2a         	!byte $7a,$1d,$84,$1c,$2a
  5777  a4b1 7c6359580a         	!byte $7c,$63,$59,$58,$0a
  5778  a4b6 7e75fde7c6         	!byte $7e,$75,$fd,$e7,$c6
  5779  a4bb 8031721810         	!byte $80,$31,$72,$18,$10
  5780  a4c0 8100000000         	!byte $81,0,0,0,0		; 1
  5781                          ; -------------------------------------------------------------------------------------------------
  5782                          ; EXP - multiply by log(e) base 2.
  5783                          
  5784  a4c5 a997               exp:	lda #<logeb2
  5785  a4c7 a0a4               	ldy #>logeb2
  5786  a4c9 203a9f             	jsr fmult
  5787  a4cc a57e               	lda facov
  5788  a4ce 6950               	adc #$50
  5789  a4d0 9003               	bcc stold
  5790  a4d2 2018a1             	jsr incrnd
  5791                          
  5792  a4d5 8561               stold:	sta oldov
  5793  a4d7 2004a1             	jsr movef
  5794  a4da a56f               	lda facexp
  5795  a4dc c988               	cmp #$88
  5796  a4de 9003               	bcc exp1
  5797  a4e0 20d69f             gomldv:	jsr mldvex
  5798  a4e3 20caa1             exp1:	jsr int
  5799  a4e6 a50c               	lda integr
  5800  a4e8 18                 	clc
  5801  a4e9 6981               	adc #$81
  5802  a4eb f0f3               	beq gomldv
  5803  a4ed 38                 	sec
  5804  a4ee e901               	sbc #1
  5805  a4f0 48                 	pha
  5806  a4f1 a205               	ldx #4+addprc
  5807  a4f3 b577               swaplp:	lda argexp,x
  5808  a4f5 b46f               	ldy facexp,x
  5809  a4f7 956f               	sta facexp,x
  5810  a4f9 9477               	sty argexp,x
  5811  a4fb ca                 	dex
  5812  a4fc 10f5               	bpl swaplp
  5813  a4fe a561               	lda oldov
  5814  a500 857e               	sta facov
  5815  a502 20629d             	jsr fsubt
  5816  a505 208ca4             	jsr negop
  5817  a508 a99c               	lda #<expcon
  5818  a50a a0a4               	ldy #>expcon
  5819  a50c 202ea5             	jsr poly
  5820  a50f a900               	lda #0
  5821  a511 857d               	sta arisgn
  5822  a513 68                 	pla
  5823  a514 20bb9f             	jsr mldexp
  5824  a517 60                 	rts
  5825                          ; -------------------------------------------------------------------------------------------------
  5826                          ; polyx - evaluate p(x**y)*x
  5827                          ;   pointer to degree is in y,a
  5828                          ;   the constants follow the degree for x=fac, compute
  5829                          ;   c0*x+c1*x**3+c2*x**5+c3*x**7... cn*x**(2*n-1)
  5830                          
  5831  a518 8580               polyx:	sta polypt
  5832  a51a 8481               	sty polypt+1
  5833  a51c 20b9a0             	jsr mov1f
  5834  a51f a962               	lda #<tempf1
  5835  a521 203a9f             	jsr fmult
  5836  a524 2032a5             	jsr poly1
  5837  a527 a962               	lda #<tempf1
  5838  a529 a000               	ldy #>tempf1
  5839  a52b 4c3a9f             	jmp fmult
  5840                          
  5841                          ; polynomial evaluator
  5842                          ; pointer to degree is in y,a
  5843  a52e 8580               poly:	sta polypt
  5844  a530 8481               	sty polypt+1
  5845  a532 20b6a0             poly1:	jsr mov2f
  5846  a535 a900               	lda #0
  5847  a537 1180               	ora (polypt),y		;  read system mem
  5848  a539 8575               	sta degree
  5849  a53b a480               	ldy polypt
  5850  a53d c8                 	iny
  5851  a53e 98                 	tya
  5852  a53f d002               	bne poly3
  5853  a541 e681               	inc polypt+1
  5854  a543 8580               poly3:	sta polypt
  5855  a545 a481               	ldy polypt+1
  5856  a547 203a9f             poly2:	jsr fmult
  5857  a54a a580               	lda polypt
  5858  a54c a481               	ldy polypt+1
  5859  a54e 18                 	clc
  5860  a54f 6905               	adc #4+addprc
  5861  a551 9001               	bcc poly4
  5862  a553 c8                 	iny
  5863  a554 8580               poly4:	sta polypt
  5864  a556 8481               	sty polypt+1
  5865  a558 207c9d             	jsr fadd
  5866  a55b a968               	lda #<tempf2
  5867  a55d a000               	ldy #>tempf2
  5868  a55f c675               	dec degree
  5869  a561 d0e4               	bne poly2
  5870  a563 60                 	rts
  5871                          ; -------------------------------------------------------------------------------------------------
  5872                          ; constants for RND
  5873  a564 9835447a           rmulc:	!byte $98,$35,$44,$7a	; 11879546
  5874  a568 6828b146           raddc:	!byte $68,$28,$b1,$46	; 3.92767774 e-4
  5875                          ; -------------------------------------------------------------------------------------------------
  5876                          ; RND - pseudo-random number generator.
  5877                          
  5878  a56c 2020a1             rnd:	jsr sign
  5879  a56f 301a               	bmi rnd1
  5880  a571 a68b               	ldx seedpt
  5881  a573 a48c               	ldy seedpt+1
  5882  a575 e8                 	inx
  5883  a576 d001               	bne rnd10
  5884  a578 c8                 	iny
  5885                          
  5886  a579 8a                 rnd10:	txa
  5887  a57a 2091a0             	jsr movfum
  5888  a57d a964               	lda #<rmulc
  5889  a57f a0a5               	ldy #>rmulc
  5890  a581 203a9f             	jsr fmult
  5891  a584 a968               	lda #<raddc
  5892  a586 a0a5               	ldy #>raddc
  5893  a588 207c9d             	jsr fadd
  5894  a58b a673               rnd1:	ldx faclo
  5895  a58d a570               	lda facho
  5896  a58f 8573               	sta faclo
  5897  a591 8670               	stx facho
  5898  a593 a671               	ldx facmoh
  5899  a595 a572               	lda facmo
  5900  a597 8571               	sta facmoh
  5901  a599 8672               	stx facmo
  5902  a59b a900               strnex:	lda #0
  5903  a59d 8574               	sta facsgn
  5904  a59f a56f               	lda facexp
  5905  a5a1 857e               	sta facov
  5906  a5a3 a980               	lda #$80
  5907  a5a5 856f               	sta facexp
  5908  a5a7 20ec9d             	jsr normal
  5909  a5aa a68b               	ldx seedpt
  5910  a5ac a48c               	ldy seedpt+1
  5911  a5ae e8                 	inx
  5912  a5af d001               	bne rnd20    		; if no carry
  5913  a5b1 c8                 	iny
  5914  a5b2 4cc9a0             rnd20:	jmp movumf
  5915                          ; -------------------------------------------------------------------------------------------------
  5916                          ; COS - cosinus function
  5917                          
  5918  a5b5 a935               cos:	lda #<pi2
  5919  a5b7 a0a6               	ldy #>pi2
  5920  a5b9 207c9d             	jsr fadd
  5921                          ; -------------------------------------------------------------------------------------------------
  5922                          ; SIN - sinus function
  5923                          
  5924  a5bc 2001a1             sin:	jsr movaf
  5925  a5bf a93a               	lda #<twopi
  5926  a5c1 a0a6               	ldy #>twopi
  5927  a5c3 a67c               	ldx argsgn
  5928  a5c5 2009a0             	jsr fdivf
  5929  a5c8 2001a1             	jsr movaf
  5930  a5cb 20caa1             	jsr int
  5931  a5ce a900               	lda #0
  5932  a5d0 857d               	sta arisgn
  5933  a5d2 20629d             	jsr fsubt
  5934  a5d5 a93f               	lda #<fr4
  5935  a5d7 a0a6               	ldy #>fr4
  5936  a5d9 205f9d             	jsr fsub
  5937  a5dc a574               	lda facsgn
  5938  a5de 48                 	pha
  5939  a5df 100f               	bpl sin1
  5940  a5e1 20599d             	jsr faddh
  5941  a5e4 a574               	lda facsgn
  5942  a5e6 300b               	bmi sin2
  5943  a5e8 ad5902             	lda tansgn
  5944  a5eb 49ff               	eor #$ff
  5945  a5ed 8d5902             	sta tansgn
  5946  a5f0 208ca4             sin1:	jsr negop
  5947  a5f3 a93f               sin2:	lda #<fr4
  5948  a5f5 a0a6               	ldy #>fr4
  5949  a5f7 207c9d             	jsr fadd
  5950  a5fa 68                 	pla
  5951  a5fb 1003               	bpl sin3
  5952  a5fd 208ca4             	jsr negop
  5953  a600 a944               sin3:	lda #<sincon
  5954  a602 a0a6               	ldy #>sincon
  5955  a604 4c18a5             	jmp polyx
  5956                          ; -------------------------------------------------------------------------------------------------
  5957                          ; TAN - tangent function
  5958                          
  5959  a607 20b9a0             tan:	jsr mov1f
  5960  a60a a900               	lda #0
  5961  a60c 8d5902             	sta tansgn
  5962  a60f 20bca5             	jsr sin
  5963  a612 a259               	ldx #<tempf3
  5964  a614 a000               	ldy #>tempf3
  5965  a616 20bda0             	jsr movmf
  5966  a619 a962               	lda #<tempf1
  5967  a61b a000               	ldy #>tempf1
  5968  a61d 2091a0             	jsr movfm
  5969  a620 a900               	lda #0
  5970  a622 8574               	sta facsgn
  5971  a624 ad5902             	lda tansgn
  5972  a627 2031a6             	jsr cosc
  5973  a62a a959               	lda #<tempf3
  5974  a62c a000               	ldy #>tempf3
  5975  a62e 4c11a0             	jmp fdiv
  5976                          
  5977  a631 48                 cosc:	pha
  5978  a632 4cf0a5             	jmp sin1
  5979                          ; -------------------------------------------------------------------------------------------------
  5980                          ; constants
  5981                          
  5982  a635 81490fdaa2         pi2:	!byte $81,$49,$0f,$da,$a2	; pi/2
  5983  a63a 83490fdaa2         twopi:	!byte $83,$49,$0f,$da,$a2	; 2pi
  5984  a63f 7f00000000         fr4:	!byte $7f,0,0,0,0		; 0.25
  5985                          
  5986  a644 05                 sincon:	!byte 5				; 6 sin+cos constants (polynom 5) 
  5987  a645 84e61a2d1b         	!byte $84,$e6,$1a,$2d,$1b
  5988  a64a 862807f6f8         	!byte $86,$28,$07,$f6,$f8
  5989  a64f 8799688901         	!byte $87,$99,$68,$89,1
  5990  a654 872335dfe1         	!byte $87,$23,$35,$df,$e1
  5991  a659 86a55de728         	!byte $86,$a5,$5d,$e7,$28
  5992  a65e 83490fdaa2         	!byte $83,$49,$0f,$da,$a2
  5993                          
  5994  a663 0b                 atncon:	!byte $0b			; 12 atn constants (polynom 11)
  5995  a664 76b383bdd3         	!byte $76,$b3,$83,$bd,$d3
  5996  a669 791ef4a6f5         	!byte $79,$1e,$f4,$a6,$f5
  5997  a66e 7b83fcb010         	!byte $7b,$83,$fc,$b0,$10
  5998  a673 7c0c1f67ca         	!byte $7c,$0c,$1f,$67,$ca
  5999  a678 7cde53cbc1         	!byte $7c,$de,$53,$cb,$c1
  6000  a67d 7d1464704c         	!byte $7d,$14,$64,$70,$4c
  6001  a682 7db7ea517a         	!byte $7d,$b7,$ea,$51,$7a
  6002  a687 7d6330887e         	!byte $7d,$63,$30,$88,$7e
  6003  a68c 7e9244993a         	!byte $7e,$92,$44,$99,$3a
  6004  a691 7e4ccc91c7         	!byte $7e,$4c,$cc,$91,$c7
  6005  a696 7faaaaaa13         	!byte $7f,$aa,$aa,$aa,$13
  6006  a69b 8100000000         	!byte $81,0,0,0,0
  6007                          ; -------------------------------------------------------------------------------------------------
  6008                          ; ATN
  6009                          
  6010  a6a0 a574               atn:	lda facsgn
  6011  a6a2 48                 	pha
  6012  a6a3 1003               	bpl atn1
  6013  a6a5 208ca4             	jsr negop
  6014  a6a8 a56f               atn1:	lda facexp
  6015  a6aa 48                 	pha
  6016  a6ab c981               	cmp #$81
  6017  a6ad 9007               	bcc atn2
  6018  a6af a9ce               	lda #<fone
  6019  a6b1 a09e               	ldy #>fone
  6020  a6b3 2011a0             	jsr fdiv
  6021  a6b6 a963               atn2:	lda #<atncon
  6022  a6b8 a0a6               	ldy #>atncon
  6023  a6ba 2018a5             	jsr polyx
  6024  a6bd 68                 	pla
  6025  a6be c981               	cmp #$81
  6026  a6c0 9007               	bcc atn3
  6027  a6c2 a935               	lda #<pi2
  6028  a6c4 a0a6               	ldy #>pi2
  6029  a6c6 205f9d             	jsr fsub
  6030  a6c9 68                 atn3:	pla
  6031  a6ca 104f               	bpl atn4
  6032  a6cc 4c8ca4             	jmp negop
  6033                          ; ******************************************* STRNG1 **********************************************
  6034                          ; 'string utility routines'
  6035                          ; PUDEF
  6036                          ;   puctrl takes assigns values for the print using characters (fill,comma,dot,dollar) from a
  6037                          ;   user string.
  6038                          
  6039  a6cf 209291             puctrl:	jsr sav13
  6040  a6d2 a8                 	tay
  6041  a6d3 f00f               	beq pucbye		; nothing,... done
  6042  a6d5 c004               	cpy #pumony-puchrs+1
  6043  a6d7 9002               	bcc puc50		; len < #pu chars
  6044  a6d9 a004               	ldy #pumony-puchrs+1	; len >= #pu chars
  6045  a6db 88                 puc50:	dey
  6046  a6dc b122               puc60:	lda (index),y
  6047  a6de 997302             	sta puchrs,y
  6048  a6e1 88                 	dey
  6049  a6e2 10f8               	bpl puc60
  6050  a6e4 60                 pucbye:	rts
  6051                          ; -------------------------------------------------------------------------------------------------
  6052                          ; STR
  6053                          ;   the str$ fnc takes a number and gives a string with the chars the output of the # would have
  6054                          ;   given.
  6055                          
  6056  a6e5 209aae             strd:	jsr chknum
  6057  a6e8 20f4a2             	jsr fout
  6058  a6eb 68                 	pla
  6059  a6ec 68                 	pla
  6060                          
  6061                          ; find length of number string
  6062  a6ed a000               foutst:	ldy #0
  6063  a6ef b90002             str010:	lda fbuffr,y
  6064  a6f2 f003               	beq str020
  6065  a6f4 c8                 	iny
  6066  a6f5 d0f8               	bne str010
  6067                          
  6068  a6f7 98                 str020:	tya			; length to .a
  6069  a6f8 2012a7             	jsr strspa
  6070                          ;	move from fbuffr to (dsctmp)
  6071  a6fb a000               	ldy #0
  6072  a6fd b90002             str030:	lda fbuffr,y
  6073  a700 f005               	beq str040
  6074  a702 916f               	sta (dsctmp+1),y
  6075  a704 c8                 	iny
  6076  a705 d0f6               	bne str030
  6077  a707 4c5ea7             str040:	jmp putnew
  6078                          ; -------------------------------------------------------------------------------------------------
  6079                          ; strini
  6080                          ;   get string space for the creation of a string and create a descriptor for it in dsctmp
  6081                          ;   enter:  strini -  facmo contains descriptor ptr
  6082                          ;   -  .a = length
  6083                          ;   strspa -  .a = length
  6084                          
  6085  a70a a672               strini:	ldx facmo
  6086  a70c a473               	ldy facmo+1
  6087  a70e 865c               	stx dscpnt		; dscpnt <- descriptor ptr
  6088  a710 845d               	sty dscpnt+1
  6089  a712 209cab             strspa:	jsr getspa		; allocate space
  6090  a715 856e               	sta dsctmp		; length
  6091  a717 866f               	stx dsctmp+1		; ptr to string
  6092  a719 8470               	sty dsctmp+2
  6093  a71b 60                 atn4:	rts
  6094                          ; -------------------------------------------------------------------------------------------------
  6095                          ; strlit
  6096                          ;   get string space for the creation of a string.
  6097                          ;   space is allocated and a copy is made of this substring. a temporary descriptor is made.
  6098                          ;   exit:   strng1 = ptr to start of string
  6099                          ;   strng2 = ptr to 1st char past terminator
  6100                          ;   facmo  = descriptor ptr for copy
  6101                          
  6102                          ;   strlit,strlt2: a string is searched until the end is reached or a matching terminating char is
  6103                          ;   found. this substring is copied to a new temporary string.
  6104                          ;   enter: .a,.y = ptr to string
  6105                          ;          .x = string bank#
  6106                          ;   putnew: temp descriptor dsctmp is put on the descr "stack" and facmo is its desc ptr.
  6107                          
  6108  a71c 48                 strlit:	pha
  6109  a71d a922               	lda #34			; set terminators
  6110  a71f 850c               	sta charac
  6111  a721 850d               	sta endchr
  6112  a723 68                 	pla
  6113  a724 857d               strlt2:	sta strng1		; strng1<-ptr to string
  6114  a726 847e               	sty strng1+1
  6115  a728 856f               	sta dsctmp+1		; ditto..
  6116  a72a 8470               	sty dsctmp+2
  6117  a72c a0ff               	ldy #$ff
  6118  a72e c8                 strget:	iny			; skim over string
  6119  a72f b17d               	lda (strng1),y
  6120  a731 f00c               	beq strfi1
  6121  a733 c50c               	cmp charac
  6122  a735 f004               	beq strfin
  6123  a737 c50d               	cmp endchr
  6124  a739 d0f3               	bne strget
  6125  a73b c922               strfin:	cmp #34
  6126  a73d f001               	beq strfi2
  6127  a73f 18                 strfi1:	clc
  6128  a740 846e               strfi2:	sty dsctmp
  6129  a742 98                 	tya
  6130  a743 657d               	adc strng1		; strng2 <- ptr to end of string
  6131  a745 8580               	sta strng2
  6132  a747 a67e               	ldx strng1+1
  6133  a749 9001               	bcc strst2
  6134  a74b e8                 	inx
  6135  a74c 8681               strst2:	stx strng2+1
  6136  a74e 98                 	tya			; .a <- length
  6137  a74f 200aa7             	jsr strini		; allocate space
  6138  a752 a202               	ldx #2
  6139                          
  6140  a754 b47d               sotl:	ldy strng1,x
  6141  a756 9422               	sty index,x
  6142  a758 ca                 	dex
  6143  a759 10f9               	bpl sotl
  6144                          ; entry point from leftd
  6145  a75b 20a9a7             glgr: 	jsr movdo		; copy it to end of string area
  6146                          
  6147  a75e a41d               putnew:	ldy temppt
  6148  a760 c00c               	cpy #strsiz+strsiz+strsiz
  6149  a762 d005               	bne putnw1
  6150  a764 a248               	ldx #errst
  6151  a766 4c2685             	jmp error
  6152                          
  6153                          ; compute address of this temp descriptor and temppt becomes offset to next descriptor.
  6154                          ; two descr pointers:
  6155                          ; facmo,lastpt <- tempst+temppt
  6156                          ; and:
  6157                          ; temppt <- temppt+strsiz
  6158  a769 a200               putnw1:	ldx #0			; move len,ptr,bank bytes
  6159                          
  6160  a76b b56e               putnwl:	lda dsctmp,x
  6161  a76d 9120               	sta (tempst),y		; length
  6162  a76f c8                 	iny
  6163  a770 e8                 	inx
  6164  a771 e004               	cpx #strsiz
  6165  a773 d0f6               	bne putnwl
  6166  a775 a521               	lda tempst+1
  6167  a777 8573               	sta facmo+1
  6168  a779 851f               	sta lastpt+1
  6169  a77b 18                 	clc
  6170  a77c a520               	lda tempst
  6171  a77e 651d               	adc temppt
  6172  a780 8572               	sta facmo
  6173  a782 851e               	sta lastpt
  6174  a784 9004               	bcc putnw2
  6175  a786 e673               	inc facmo+1
  6176  a788 e61f               	inc lastpt+1
  6177                          
  6178  a78a 841d               putnw2:	sty temppt
  6179  a78c a000               	ldy #0
  6180  a78e 847e               	sty facov
  6181  a790 88                 	dey
  6182  a791 8411               	sty valtyp		; $ff is string type
  6183  a793 60                 	rts
  6184                          ; -------------------------------------------------------------------------------------------------
  6185                          ; movins - move a string to top of free space
  6186                          ;   enter: movins  - strng1 is src descriptor ptr
  6187                          ;   movdo  - index = ptr to src string
  6188                          ;         .a = length
  6189                          ;   exit: index = ptr to source
  6190                          ;   frespc = ptr to dst link bytes
  6191                          
  6192  a794 a000               movins:	ldy #0
  6193  a796 b17d               	lda (strng1),y		; get length,ptr via descr ptr
  6194  a798 aa                 	tax
  6195  a799 c8                 	iny
  6196  a79a b17d               	lda (strng1),y		; index<-ptr to string
  6197  a79c 8522               	sta index
  6198  a79e c8                 	iny
  6199  a79f b17d               	lda (strng1),y
  6200  a7a1 8523               	sta index+1
  6201  a7a3 c8                 	iny
  6202  a7a4 b17d               	lda (strng1),y
  6203  a7a6 8524               	sta index+2
  6204  a7a8 8a                 	txa
  6205  a7a9 a8                 movdo:	tay
  6206  a7aa f00a               	beq mvdone
  6207  a7ac 48                 	pha
  6208  a7ad 88                 movlp:	dey			; move the string
  6209  a7ae b122               	lda (index),y
  6210  a7b0 913b               	sta (frespc),y
  6211  a7b2 98                 	tya
  6212  a7b3 d0f8               	bne movlp
  6213  a7b5 68                 	pla
  6214  a7b6 18                 mvdone:	clc			; adjust frespc ptr
  6215  a7b7 653b               	adc frespc
  6216  a7b9 853b               	sta frespc
  6217  a7bb 9002               	bcc mvstrt
  6218  a7bd e63c               	inc frespc+1
  6219  a7bf 60                 mvstrt:	rts
  6220                          ; -------------------------------------------------------------------------------------------------
  6221                          ; frestr
  6222                          ;   given a string descriptor pointer, determine if it can be freed and do so.
  6223                          ;   exit:  .a = length
  6224                          ;   index = ptr to string
  6225                          
  6226  a7c0 209cae             frestr:	jsr chkstr
  6227                          
  6228  a7c3 a572               frefac:	lda facmo		;  descptr ptr
  6229  a7c5 a473               	ldy facmo+1
  6230  a7c7 201ba8             fretmp:	jsr sav10
  6231  a7ca d036               	bne fre02		; one then scratch it
  6232  a7cc 20d0a8             	jsr stradj		; index points to link
  6233  a7cf 9031               	bcc fre02		; literal no fix
  6234  a7d1 20c2a8             	jsr mkgarb		; mark it as garbage
  6235  a7d4 48                 	pha			; save length on stack
  6236                          
  6237  a7d5 49ff               	eor #$ff		; put index back
  6238  a7d7 38                 	sec			; to first byte
  6239  a7d8 6522               	adc index
  6240  a7da a423               	ldy index+1
  6241  a7dc b001               	bcs res00
  6242  a7de 88                 	dey
  6243  a7df 8522               res00:	sta index
  6244  a7e1 8423               	sty index+1
  6245  a7e3 aa                 	tax			; lo into x
  6246  a7e4 68                 	pla			; pull length from stack
  6247  a7e5 a423               	ldy index+1
  6248  a7e7 c43a               	cpy fretop+1		; ptr(hi)
  6249  a7e9 d04d               	bne frerts
  6250  a7eb e439               	cpx fretop		; ptr(lo)
  6251  a7ed d049               	bne frerts
  6252                          
  6253                          ; string was last into string space
  6254                          ; save garbage collection some time by freeing up. (length + ptrsiz)
  6255  a7ef 48                 	pha			; save length on stack
  6256  a7f0 18                 	clc
  6257  a7f1 6539               	adc fretop
  6258  a7f3 9002               	bcc fre01
  6259  a7f5 e63a               	inc fretop+1
  6260  a7f7 18                 fre01:	clc
  6261  a7f8 6903               	adc #ptrsiz
  6262  a7fa 8539               	sta fretop
  6263  a7fc 9002               	bcc frepla
  6264  a7fe e63a               	inc fretop+1
  6265  a800 68                 frepla:	pla			; pull length off stack
  6266  a801 60                 	rts
  6267                          
  6268                          ; index is descripto ptr. set up return values as if string had been marked as garbage, as in above
  6269  a802 a000               fre02:	ldy #$00		; set up .a and index
  6270  a804 b122               	lda (index),y		; length
  6271  a806 48                 	pha
  6272  a807 c8                 	iny
  6273  a808 b122               	lda (index),y		; pointer lo
  6274  a80a 48                 	pha
  6275  a80b c8                 	iny
  6276  a80c b122               	lda (index),y		; pointer hi
  6277  a80e aa                 	tax
  6278  a80f c8                 	iny
  6279  a810 b122               	lda (index),y		; pointer bank
  6280  a812 8524               	sta index+2
  6281  a814 8623               	stx index+1
  6282  a816 68                 	pla
  6283  a817 8522               	sta index
  6284  a819 68                 	pla			; get back length
  6285  a81a 60                 	rts
  6286                          ; -------------------------------------------------------------------------------------------------
  6287                          ; sav10
  6288                          ;   if the descriptor pointer is on the top of string descriptor stack, pop it off.
  6289                          ;   enter:  .a,.y = descriptor ptr
  6290                          
  6291  a81b 8522               sav10:	sta index
  6292  a81d 8423               	sty index+1
  6293                          
  6294  a81f c41f               fretms:	cpy lastpt+1
  6295  a821 d015               	bne frerts
  6296  a823 c51e               	cmp lastpt
  6297  a825 d011               	bne frerts
  6298  a827 e904               	sbc #strsiz
  6299  a829 851e               	sta lastpt
  6300  a82b b002               	bcs fret10
  6301  a82d c61f               	dec lastpt+1
  6302  a82f 38                 fret10:	sec
  6303  a830 a51d               	lda temppt
  6304  a832 e904               	sbc #strsiz
  6305  a834 851d               	sta temppt
  6306  a836 a000               	ldy #0
  6307  a838 60                 frerts:	rts
  6308                          ; -------------------------------------------------------------------------------------------------
  6309                          ; string assignment
  6310                          ; inpcom perform the assignment of a string value to a string variable.
  6311                          ;   enter: forpnt = ptr to lhs var's data memory
  6312                          ;          facmo  = descriptor ptr to rhs string val
  6313                          ;   forpnt is checked to see if it ds$. special code handles ds$ assignments. also, if the rhs value
  6314                          ;   is not a temporary result (i.e., descriptor ptr points to the symbol tables), a copy of the
  6315                          ;   value is made.
  6316                          
  6317                          inpcom:
  6318                          ; detect ti$ 			; modified by vossi
  6319  a839 a54d               	lda varnam
  6320  a83b a44e               	ldy varnam+1
  6321  a83d c954               	cmp #'t'
  6322  a83f d007               	bne getspt
  6323  a841 c0c9               	cpy #$c9   		; 'i'+$80
  6324  a843 d003               	bne getspt
  6325  a845 4c1fab             	jmp mktime		; see ptrget, => ti$
  6326                          ; not ti$
  6327  a848 a473               getspt:	ldy facmo+1		; descr ptr for temp?
  6328  a84a c438               	cpy strend+1		; make a copy, if not...
  6329  a84c 9028               	bcc copy
  6330  a84e d006               	bne dntcpy
  6331  a850 a572               	lda facmo
  6332  a852 c537               	cmp strend
  6333  a854 9020               	bcc copy
  6334  a856 a572               dntcpy: lda facmo
  6335  a858 a473               	ldy facmo+1
  6336  a85a 855c               	sta dscpnt
  6337  a85c 845d               	sty dscpnt+1
  6338  a85e 201ba8             	jsr sav10
  6339  a861 20d0a8             	jsr stradj		; set up index to new string
  6340  a864 9003               	bcc dcop02
  6341  a866 20a8a8             	jsr bcklnk		; link new
  6342  a869 20b4a8             dcop02:	jsr fixold		; fix old...
  6343  a86c a003               	ldy #strsiz-1
  6344  a86e b15c               dcop01:	lda (dscpnt),y		; set the descriptor
  6345  a870 9152               	sta (forpnt),y
  6346  a872 88                 	dey
  6347  a873 10f9               	bpl dcop01
  6348  a875 60                 	rts
  6349                          ; -------------------------------------------------------------------------------------------------
  6350                          ; copy - make a copy of the source value. do the assignment of the duplicate.
  6351                          
  6352  a876 a000               copy:	ldy #0
  6353  a878 b172               	lda (facmo),y
  6354  a87a 200aa7             	jsr strini		; copy src value: make space for it
  6355  a87d a202               	ldx #2
  6356                          
  6357  a87f b45c               soth:	ldy dscpnt,x
  6358  a881 947d               	sty strng1,x
  6359  a883 ca                 	dex
  6360  a884 10f9               	bpl soth
  6361  a886 2094a7             	jsr movins		; move src to temp
  6362                          ; fix to fre get strings
  6363  a889 a57d               	lda strng1		; restore .a & .y
  6364  a88b a47e               	ldy strng1+1
  6365  a88d a67f               	ldx strng1+2
  6366  a88f 201fa8             	jsr fretms		; fre the temp string
  6367                          
  6368  a892 2000a9             	jsr stradd		; set up index
  6369  a895 9003               	bcc copy02		; ?fix back links
  6370  a897 20a8a8             	jsr bcklnk		; link new
  6371  a89a 20b4a8             copy02:	jsr fixold		;  fix old...
  6372  a89d a003               	ldy #strsiz-1		; fix var's descriptor
  6373  a89f b96e00             copy01:	lda dsctmp,y
  6374  a8a2 9152               	sta (forpnt),y
  6375  a8a4 88                 	dey
  6376  a8a5 10f8               	bpl copy01
  6377  a8a7 60                 	rts
  6378                          ; -------------------------------------------------------------------------------------------------
  6379                          ; bcklnk
  6380                          ;   fix the new string by setting its back link bytes to point to the destination descriptor.
  6381                          ;   enter: forpnt = descr ptr for dest
  6382                          
  6383  a8a8 a000               bcklnk:	ldy #$00
  6384  a8aa a552               	lda forpnt		; put in backwards link
  6385  a8ac 9122               	sta (index),y
  6386  a8ae c8                 	iny
  6387  a8af a553               	lda forpnt+1
  6388  a8b1 9122               	sta (index),y
  6389  a8b3 60                 	rts
  6390                          ; -------------------------------------------------------------------------------------------------
  6391                          ; fixold - if the destination has an old value, free it and mark it as garbage.
  6392                          ;   enter:  forpnt=dest descriptor ptr
  6393                          
  6394  a8b4 a202               fixold:	ldx #2
  6395  a8b6 b452               sump:	ldy forpnt,x
  6396  a8b8 9422               	sty index,x
  6397  a8ba ca                 	dex
  6398  a8bb 10f9               	bpl sump
  6399  a8bd 20d0a8             	jsr stradj		; point to old string
  6400  a8c0 903a               	bcc fnk05		; in text do not fix
  6401                          ;	jmp mkgarb		; mark as garbage
  6402                          ; -------------------------------------------------------------------------------------------------
  6403                          ; mkgarb - mark the string as garbage
  6404                          ;   enter:  index points to str link bytes
  6405                          ;   .x = length
  6406                          ;   exit:   .x,.a = length
  6407                          ;   .y = 0
  6408                          ;   index unchanged
  6409                          
  6410  a8c2 a002               mkgarb:	ldy #2
  6411  a8c4 a9ff               	lda #$ff
  6412  a8c6 9122               	sta (index),y		; mark bank#
  6413  a8c8 88                 	dey
  6414  a8c9 9122               	sta (index),y		; mark back link(hi) as junk
  6415  a8cb 88                 	dey
  6416  a8cc 8a                 	txa
  6417  a8cd 9122               	sta (index),y		; back link(lo)=len
  6418  a8cf 60                 	rts
  6419                          ; -------------------------------------------------------------------------------------------------
  6420                          ; stradj, stradd	
  6421                          ;   takes the pointer index which points to a descriptor and indexes to the desciptors string data.
  6422                          ;   if no action to take, (ds$ string or zero length string) we return with carry clear;
  6423                          ;   otherwise we return with the pointer set to the link bytes in the string
  6424                          ;   the length in .a and the carry set.
  6425                          ;   stradj - use index as descriptor ptr
  6426                          ;   stradd - use dsctmp as descriptor
  6427                          
  6428  a8d0 a000               stradj:	ldy #$00
  6429  a8d2 b122               	lda (index),y		; push length on stack
  6430  a8d4 48                 	pha
  6431  a8d5 f026               	beq sadj8		; length 0 do nothing
  6432  a8d7 c8                 	iny
  6433  a8d8 b122               	lda (index),y		; push lo byte
  6434  a8da 48                 	pha
  6435  a8db c8                 	iny
  6436  a8dc b122               	lda (index),y		; high byte in .x
  6437  a8de aa                 	tax
  6438  a8df c8                 	iny
  6439  a8e0 b122               	lda (index),y		; bank in .y
  6440  a8e2 a8                 	tay
  6441  a8e3 68                 	pla			; lo
  6442                          
  6443                          sadj3:
  6444                          	;cpx fretop+1
  6445                          	;bcc sadj8
  6446                          	;cmp fretop
  6447                          	;bcc sadj8
  6448  a8e4 c419               	cpy dsdesc+3		; is it ds$ string?
  6449  a8e6 d008               	bne sadj4
  6450  a8e8 e418               	cpx dsdesc+2
  6451  a8ea d004               	bne sadj4		; fix
  6452  a8ec c517               	cmp dsdesc+1
  6453  a8ee f00d               	beq sadj8
  6454  a8f0 8522               sadj4:	sta index		; ok, set pointer
  6455  a8f2 8623               	stx index+1
  6456  a8f4 8424               	sty index+2
  6457  a8f6 68                 	pla			; get back length
  6458  a8f7 aa                 	tax			; into x also
  6459  a8f8 208fa9             	jsr sav15
  6460  a8fb 38                 sadj6:	sec			; carry set
  6461  a8fc 60                 fnk05:	rts
  6462                          
  6463  a8fd 68                 sadj8:	pla			; clean up stack
  6464  a8fe 18                 	clc
  6465  a8ff 60                 	rts
  6466                          
  6467  a900 a56e               stradd:	lda dsctmp
  6468  a902 48                 	pha			; length on stack
  6469  a903 f0f8               	beq sadj8		; do nothing
  6470  a905 a56f               	lda dsctmp+1		; string ptr (lo)
  6471  a907 a670               	ldx dsctmp+2		; string ptr (hi)
  6472  a909 a471               	ldy dsctmp+3		; string ptr (bank)
  6473  a90b 4ce4a8             	jmp sadj3		; etc
  6474                          ; ******************************************* STRNG2 **********************************************
  6475                          ; 'string functions'
  6476                          ; cat - concatenate two strings
  6477                          
  6478  a90e a573               cat:	lda facmo+1		; (ptr)
  6479  a910 48                 	pha
  6480  a911 a572               	lda facmo
  6481  a913 48                 	pha
  6482  a914 206796             	jsr eval		; do 2nd operand
  6483  a917 209cae             	jsr chkstr		; must be string value
  6484  a91a 68                 	pla
  6485  a91b 857d               	sta strng1		; strng1 <- descr ptr for 1st opnd
  6486  a91d 68                 	pla
  6487  a91e 857e               	sta strng1+1
  6488  a920 a000               	ldy #0
  6489  a922 b17d               	lda (strng1),y		; len1+len2<256 ?
  6490  a924 8d5b02             	sta tttemp
  6491  a927 b172               	lda (facmo),y
  6492  a929 18                 	clc
  6493  a92a 6d5b02             	adc tttemp
  6494  a92d 9003               	bcc sizeok
  6495  a92f 4c0db1             	jmp errlen
  6496                          
  6497  a932 200aa7             sizeok:	jsr strini		; allocate for result
  6498  a935 2094a7             	jsr movins		; copy 1st operand
  6499  a938 204da9             	jsr sav47
  6500  a93b 20a9a7             	jsr movdo		; append 2nd string
  6501  a93e a57d               	lda strng1		; descriptor ptr for result
  6502  a940 a47e               	ldy strng1+1
  6503  a942 a67f               	ldx strng1+2
  6504  a944 20c7a7             	jsr fretmp
  6505  a947 205ea7             	jsr putnew
  6506  a94a 4c9795             	jmp tstop
  6507  a94d a55c               sav47:	lda dscpnt		; descr ptr 2nd opnd
  6508  a94f a45d               	ldy dscpnt+1
  6509  a951 4cc7a7             	jmp fretmp		; sets up index1!
  6510                          ; -------------------------------------------------------------------------------------------------
  6511                          ; CHR$ function
  6512                          
  6513  a954 206fae             chrd:	jsr conint
  6514  a957 8a                 	txa			; .a <- parameter value
  6515  a958 48                 	pha
  6516  a959 a901               	lda #1
  6517  a95b 2012a7             	jsr strspa		; space for 1 char
  6518  a95e 68                 	pla
  6519  a95f a000               	ldy #0
  6520  a961 916f               	sta (dsctmp+1),y	; store the char
  6521  a963 68                 chrd2:	pla
  6522  a964 68                 	pla
  6523  a965 4c5ea7             	jmp putnew		; another tmp descr...
  6524                          ; -------------------------------------------------------------------------------------------------
  6525                          ; LEFT$
  6526                          
  6527  a968 20dea9             leftd:	jsr pream
  6528  a96b 48                 	pha
  6529  a96c b15c               	lda (dscpnt),y
  6530  a96e 8d5b02             	sta tttemp
  6531  a971 68                 	pla
  6532  a972 cd5b02             	cmp tttemp
  6533  a975 98                 	tya
  6534                          ; if 2nd param>length, use length instead
  6535  a976 9004               rleft:	bcc rleft1
  6536  a978 b15c               	lda (dscpnt),y
  6537  a97a aa                 	tax
  6538  a97b 98                 	tya
  6539  a97c 48                 rleft1:	pha			; starting offset
  6540  a97d 8a                 rleft2:	txa			; length
  6541  a97e 48                 rleft3:	pha
  6542  a97f 2012a7             	jsr strspa		; get space for result
  6543  a982 204da9             	jsr sav47
  6544  a985 68                 	pla
  6545  a986 a8                 	tay
  6546  a987 68                 	pla
  6547                          ; add offset. index will point to 1st desired char.
  6548  a988 208fa9             	jsr sav15
  6549  a98b 98                 pulmor:	tya
  6550  a98c 4c5ba7             	jmp glgr 		; movdo followed by putnew
  6551  a98f 18                 sav15:	clc
  6552  a990 6522               sav14:	adc index
  6553  a992 8522               	sta index
  6554  a994 9002               	bcc sav16
  6555  a996 e623               	inc index+1
  6556  a998 60                 sav16:	rts
  6557                          ; -------------------------------------------------------------------------------------------------
  6558                          ; RIGHT$
  6559                          
  6560  a999 20dea9             rightd:	jsr pream
  6561  a99c 48                 	pha
  6562  a99d b15c               	lda (dscpnt),y
  6563  a99f 8d5b02             	sta tttemp
  6564  a9a2 68                 	pla
  6565  a9a3 18                 	clc
  6566  a9a4 ed5b02             	sbc tttemp		; places-length
  6567  a9a7 49ff               	eor #$ff		; if cy, then length will be used
  6568  a9a9 4c76a9             	jmp rleft
  6569                          
  6570  a9ac 2081b3             sav17:	jsr chrgot
  6571  a9af c929               	cmp #')'
  6572  a9b1 f046               	beq sav18
  6573  a9b3 4c63ae             	jmp combyt     		; check for comma and get a byte
  6574                          ; -------------------------------------------------------------------------------------------------
  6575                          ; MID$
  6576                          
  6577  a9b6 a9ff               midd:	lda #$ff
  6578  a9b8 8573               	sta faclo
  6579  a9ba 20aca9             	jsr sav17
  6580                          
  6581  a9bd 20dea9             mid2:	jsr pream
  6582  a9c0 f055               	beq gofuc
  6583  a9c2 ca                 	dex
  6584  a9c3 8a                 	txa			; 1st pos = 1st opnd - 1
  6585  a9c4 48                 	pha
  6586  a9c5 48                 	pha
  6587  a9c6 18                 	clc
  6588  a9c7 a200               	ldx #0
  6589  a9c9 b15c               	lda (dscpnt),y
  6590  a9cb 8d5b02             	sta tttemp
  6591  a9ce 68                 	pla
  6592  a9cf ed5b02             	sbc tttemp
  6593                          ; length of result = 0, if 1st pos > len str opnd
  6594                          ;                  = min(len str opnd - 1st pos, 3rd opnd)
  6595  a9d2 b0a9               	bcs rleft2
  6596  a9d4 49ff               	eor #$ff
  6597  a9d6 c573               	cmp faclo
  6598  a9d8 90a4               	bcc rleft3
  6599  a9da a573               	lda faclo
  6600  a9dc b0a0               	bcs rleft3
  6601                          ; -------------------------------------------------------------------------------------------------
  6602                          ; pream
  6603                          ;   exit pream: .x=.a=2nd param val
  6604                          ;   .y=0
  6605                          ;   dscpnt set up for 1st opnd
  6606                          
  6607  a9de 20e496             pream:	jsr chkcls		; ')'?
  6608  a9e1 68                 	pla
  6609  a9e2 a8                 	tay
  6610  a9e3 68                 	pla
  6611  a9e4 8560               	sta jmper+1		; pop return
  6612                          
  6613                          ; pop off:  return from caller of pream (see isfun should go back to eval instead.)
  6614                          ; .x<-stack (2nd param, byte val)
  6615                          ; dscpnt<-stack (descrp ptr 1st opnd)
  6616                          ; push back return to caller of pream.
  6617  a9e6 68                 	pla
  6618  a9e7 68                 	pla
  6619  a9e8 68                 	pla
  6620  a9e9 aa                 	tax
  6621  a9ea 68                 	pla
  6622  a9eb 855c               	sta dscpnt
  6623  a9ed 68                 	pla
  6624  a9ee 855d               	sta dscpnt+1
  6625  a9f0 68                 	pla
  6626  a9f1 a560               	lda jmper+1
  6627                          
  6628  a9f3 48                 	pha
  6629  a9f4 98                 	tya
  6630  a9f5 48                 	pha
  6631  a9f6 a000               	ldy #0
  6632  a9f8 8a                 	txa
  6633  a9f9 60                 sav18:	rts
  6634                          ; -------------------------------------------------------------------------------------------------
  6635                          ; LEN
  6636                          
  6637  a9fa 2000aa             len:	jsr len1
  6638  a9fd 4c7e9c             	jmp sngflt
  6639                          
  6640  aa00 20c0a7             len1:	jsr frestr
  6641  aa03 a200               	ldx #0
  6642  aa05 8611               	stx valtyp
  6643  aa07 a8                 	tay
  6644  aa08 60                 	rts
  6645                          ; -------------------------------------------------------------------------------------------------
  6646                          ; ASC
  6647                          
  6648  aa09 2000aa             asc:	jsr len1
  6649  aa0c f009               	beq gofuc
  6650  aa0e a000               	ldy #0
  6651  aa10 204fae             	jsr sav12
  6652  aa13 a8                 	tay
  6653  aa14 4c7e9c             	jmp sngflt
  6654                          
  6655  aa17 4c189b             gofuc:	jmp fcerr		; -> illegal quantity error, ready
  6656                          ; -------------------------------------------------------------------------------------------------
  6657                          ; VAL
  6658                          
  6659  aa1a 2000aa             val:	jsr len1
  6660  aa1d d003               	bne val1
  6661  aa1f 4c0c9e             	jmp zerofc
  6662                          
  6663  aa22 a202               val1:	ldx #2    		; strng2 := txtptr
  6664                          
  6665  aa24 b483               trug:	ldy txtptr,x
  6666  aa26 9480               	sty strng2,x
  6667  aa28 ca                 	dex
  6668  aa29 10f9               	bpl trug
  6669  aa2b a624               	ldx index1+2 
  6670  aa2d a622               	ldx index1
  6671  aa2f 8683               	stx txtptr
  6672  aa31 18                 	clc
  6673  aa32 6522               	adc index1
  6674  aa34 8525               	sta index2		; index2 := offset to end of str
  6675  aa36 a623               	ldx index1+1
  6676  aa38 8684               	stx txtptr+1
  6677  aa3a 9001               	bcc val2
  6678  aa3c e8                 	inx
  6679  aa3d 8626               val2:	stx index2+1
  6680  aa3f a000               	ldy #0
  6681  aa41 b125               	lda (index2),y
  6682  aa43 48                 	pha
  6683  aa44 98                 	tya
  6684  aa45 9125               	sta (index2),y
  6685  aa47 2081b3             	jsr chrgot
  6686  aa4a 20f1a1             	jsr fin
  6687  aa4d 68                 	pla
  6688  aa4e a000               	ldy #0
  6689  aa50 9125               	sta (index2),y
  6690  aa52 a680               st2txt:	ldx strng2		; restore text pointer
  6691  aa54 a481               	ldy strng2+1
  6692  aa56 8683               	stx txtptr
  6693  aa58 8484               	sty txtptr+1
  6694  aa5a 60                 	rts
  6695                          ; trash old token from isfun
  6696  aa5b 68                 errd:	pla
  6697  aa5c 20de96             	jsr parchk
  6698  aa5f 209aae             	jsr chknum		; check for numeric argument
  6699  aa62 206fae             	jsr conint		; get integer arg. in x
  6700  aa65 8a                 	txa
  6701  aa66 0a                 	asl
  6702  aa67 c958               	cmp #errbln		; check value against length of error pointer list
  6703  aa69 b0ac               	bcs gofuc
  6704  aa6b a8                 	tay
  6705  aa6c b96f82             	lda ebase,y 		; get address of message
  6706  aa6f 8525               	sta index2		; and create a temp descriptor pointing to it
  6707  aa71 b97082             	lda ebase+1,y
  6708  aa74 8526               	sta index2+1
  6709  aa76 a0ff               	ldy #$ff
  6710  aa78 a200               	ldx #0
  6711  aa7a c8                 erflp1:	iny	 		; count # of characters in message
  6712  aa7b b125               	lda (index2),y
  6713  aa7d f007               	beq errd1  		; quit when the end is found
  6714  aa7f c920               	cmp #$20   		; don't count non-printers
  6715  aa81 90f7               	bcc erflp1
  6716  aa83 e8                 	inx 			; it's a printer, so count it!
  6717  aa84 d0f4               	bne erflp1		; always
  6718  aa86 8a                 errd1:	txa
  6719  aa87 2012a7             	jsr strspa		; reserve a string
  6720  aa8a a0ff               	ldy #$ff
  6721  aa8c a200               	ldx #0
  6722  aa8e c8                 erflp2:	iny
  6723  aa8f b125               	lda (index2),y
  6724  aa91 f015               	beq errd2    		; done if null
  6725  aa93 c920               	cmp #$20
  6726  aa95 90f7               	bcc erflp2
  6727  aa97 8c5b02             	sty tttemp 		; save .y
  6728  aa9a 48                 	pha
  6729  aa9b 8a                 	txa        		; move .x to .y
  6730  aa9c a8                 	tay
  6731  aa9d 68                 	pla
  6732  aa9e 916f               	sta (dsctmp+1),y
  6733  aaa0 98                 	tya        		; move .y back to .x
  6734  aaa1 aa                 	tax
  6735  aaa2 ac5b02             	ldy tttemp  		; restore .y
  6736  aaa5 e8                 	inx
  6737  aaa6 d0e6               	bne erflp2		; always
  6738  aaa8 4c5ea7             errd2:	jmp putnew
  6739                          ; -------------------------------------------------------------------------------------------------
  6740                          ; gettim
  6741                          ;   time is passed to and from the system in all three registers in the following way:
  6742                          ;   .a  (tenth bit 0) (seconds)
  6743                          ;   .x  (tenth bit 1) (minutes)
  6744                          ;   .y  (am/pm bit) (tenth bits 3,2) (hours)
  6745                          ;   the hours, minutes, and seconds are bcd digits and the tenths digit is stored in the unused
  6746                          ;   bits of them.
  6747                          ;   gettim: get the time in the registers and unpack into tmhour,tmmin,tmsec,tmten
  6748                          ;   puts unpacked time into a string.
  6749                          
  6750  aaab 20deff             gettim:	jsr rdtim
  6751  aaae 48                 	pha			; save 10th bit 0
  6752  aaaf 297f               	and #$7f		; get seconds
  6753  aab1 8507               	sta tmsec
  6754  aab3 98                 	tya			; get hours
  6755  aab4 299f               	and #$9f
  6756  aab6 08                 	php			; save plus status
  6757  aab7 291f               	and #$1f		; get rid of pm bit, if set
  6758  aab9 c912               	cmp #$12		; treat 12 as 0
  6759  aabb d002               	bne *+4
  6760  aabd a900               	lda #0
  6761  aabf 28                 	plp 			; test for pm
  6762  aac0 1007               	bpl lkt50
  6763  aac2 78                 	sei			; pm bit set, adjust hours
  6764  aac3 f8                 	sed
  6765  aac4 18                 	clc
  6766  aac5 6912               	adc #$12
  6767  aac7 d8                 	cld
  6768  aac8 58                 	cli
  6769  aac9 8505               lkt50:	sta tmhour
  6770  aacb a900               	lda #0			; do 10ths
  6771  aacd 8508               	sta tmten
  6772  aacf 98                 	tya
  6773  aad0 2a                 	rol			; pm bit
  6774  aad1 2a                 	rol			; 10th bit 3
  6775  aad2 2608               	rol tmten
  6776  aad4 2a                 	rol			; 10th bit 2
  6777  aad5 2608               	rol tmten
  6778  aad7 8a                 	txa
  6779  aad8 2a                 	rol			; 10th bit 1
  6780  aad9 2608               	rol tmten
  6781  aadb 4a                 	lsr			; minutes
  6782  aadc 8506               	sta tmmin
  6783  aade 68                 	pla
  6784  aadf 2a                 	rol			; 10th bit 0
  6785  aae0 2608               	rol tmten
  6786                          
  6787  aae2 a908               	lda #8			; string space for 7 chars & 1 null
  6788  aae4 209cab             	jsr getspa
  6789  aae7 8622               	stx index1		; index1<- pointer to str space
  6790  aae9 8423               	sty index1+1
  6791  aaeb a8                 	tay			;  .y = 8
  6792                          ; put in the null terminator
  6793  aaec 88                 	dey
  6794  aaed a900               	lda #0
  6795  aaef 9122               	sta (index1),y
  6796  aaf1 88                 	dey
  6797                          ; do tenths, convert to ascii
  6798  aaf2 a508               	lda tmten
  6799  aaf4 18                 	clc
  6800  aaf5 6930               	adc #'0'
  6801  aaf7 9122               	sta (index1),y
  6802  aaf9 88                 	dey
  6803                          ; .y index to place for next digit
  6804                          ; .x index to next byte containing 2 packed
  6805                          ; bcd digits(rel to tmhour)
  6806  aafa a202               	ldx #2
  6807                          
  6808  aafc b505               gti70:	lda tmhour,x		; do low digit first
  6809  aafe 48                 	pha
  6810  aaff 290f               	and #$0f
  6811  ab01 18                 	clc
  6812  ab02 6930               	adc #'0'
  6813  ab04 9122               	sta (index1),y
  6814  ab06 88                 	dey			; now do high digit
  6815  ab07 68                 	pla
  6816  ab08 2970               	and #$70
  6817  ab0a 4a                 	lsr
  6818  ab0b 4a                 	lsr
  6819  ab0c 4a                 	lsr
  6820  ab0d 4a                 	lsr
  6821  ab0e 6930               	adc #'0'
  6822  ab10 9122               	sta (index1),y
  6823  ab12 88                 	dey
  6824  ab13 ca                 	dex
  6825  ab14 10e6               	bpl gti70
  6826  ab16 a522               	lda index1
  6827  ab18 a423               	ldy index1+1
  6828  ab1a a624               	ldx index1+2
  6829  ab1c 4c1ca7             	jmp strlit
  6830                          ; -------------------------------------------------------------------------------------------------
  6831                          ; ti$ routines - ti$ is assigned a value from a string whose descriptor is stored in fac.
  6832                          ; mktime
  6833                          
  6834  ab1f 20c3a7             mktime:	jsr frefac
  6835  ab22 48                 	pha
  6836  ab23 c906               	cmp #6
  6837  ab25 f004               	beq mktmb
  6838  ab27 c907               	cmp #7			; must receive 7 digits
  6839  ab29 d06e               	bne fcerr2
  6840                          
  6841  ab2b a000               mktmb:	ldy #0			; inx reg for packed digits
  6842  ab2d 8480               	sty fbufpt		; inx for unpacked chars
  6843                          
  6844                          ; loop around here three times to get hours, minutes and seconds. two bcd digits are packed into
  6845                          ; each byte indexed by "index2" and .y. expects tmhour, tmmin, tmsec to be stored consecutively.
  6846  ab2f 2086ab             mkti10:	jsr timnum		; get digit
  6847  ab32 0a                 	asl			; move digit into high nibble
  6848  ab33 0a                 	asl
  6849  ab34 0a                 	asl
  6850  ab35 0a                 	asl
  6851  ab36 990500             	sta tmhour,y
  6852  ab39 2086ab             	jsr timnum		; get and pack 2nd digit
  6853  ab3c 190500             	ora tmhour,y
  6854  ab3f 990500             	sta tmhour,y
  6855  ab42 c8                 	iny
  6856  ab43 c003               	cpy #3
  6857  ab45 d0e8               	bne mkti10
  6858  ab47 68                 	pla
  6859  ab48 c906               	cmp #6
  6860  ab4a f005               	beq mktmc
  6861  ab4c 2086ab             	jsr timnum		; get tenths
  6862  ab4f d002               	bne mktmd 		; always
  6863                          
  6864  ab51 a900               mktmc:	lda #0
  6865  ab53 8508               mktmd:	sta tmten
  6866                          ; adjust 24 hr clock, setting p.m. if needed
  6867  ab55 a505               	lda tmhour
  6868  ab57 c912               	cmp #$12		;  hr >= 12?
  6869  ab59 900a               	bcc mkti50
  6870  ab5b 78                 	sei
  6871  ab5c f8                 	sed			; decimal math
  6872  ab5d e912               	sbc #$12
  6873  ab5f d8                 	cld
  6874  ab60 58                 	cli
  6875  ab61 0980               	ora #$80		; p.m. bit
  6876  ab63 8505               	sta tmhour
  6877                          
  6878  ab65 a900               mkti50:	lda #0			; pack 10th bit 0
  6879  ab67 6608               	ror tmten
  6880  ab69 6a                 	ror
  6881  ab6a 0507               	ora tmsec
  6882  ab6c 48                 	pha
  6883  ab6d a900               	lda #0			; pack 10th bit 1
  6884  ab6f 6608               	ror tmten
  6885  ab71 6a                 	ror
  6886  ab72 0506               	ora tmmin
  6887  ab74 aa                 	tax
  6888  ab75 a900               	lda #0			; pack 10th bits 2,3
  6889  ab77 6608               	ror tmten
  6890  ab79 6a                 	ror
  6891  ab7a 6608               	ror tmten
  6892  ab7c 6a                 	ror
  6893  ab7d 4a                 	lsr
  6894  ab7e 0505               	ora tmhour
  6895  ab80 a8                 	tay
  6896  ab81 68                 	pla
  6897  ab82 18                 	clc			; c-clr => set time-of-day
  6898  ab83 4cdbff             	jmp settim		; set time as specified
  6899                          ; -------------------------------------------------------------------------------------------------
  6900                          ; timnum gets next digit
  6901                          ;   uses index2 as base ptr, .y<=fbufpt to get ascii digit
  6902                          ;   uses fbufpt+1 as temp for preserving .y
  6903                          ;   exit: .y unchanged
  6904                          ;         .a = unasciied digit value
  6905                          ;   fbufpt=fbufpt+1
  6906                          
  6907  ab86 8481               timnum:	sty fbufpt+1
  6908  ab88 a480               	ldy fbufpt
  6909  ab8a e680               	inc fbufpt
  6910  ab8c 204fae             	jsr sav12
  6911  ab8f 2092b3             	jsr qnum
  6912  ab92 b005               	bcs fcerr2
  6913  ab94 e92f               	sbc #$2f
  6914  ab96 a481               	ldy fbufpt+1
  6915  ab98 60                 	rts
  6916                          
  6917  ab99 4c189b             fcerr2:	jmp fcerr		; -> illegal quantity error, ready
  6918                          ; -------------------------------------------------------------------------------------------------
  6919                          ; garbage collection
  6920                          ;   get space for char string.
  6921                          ;   note may force garbage collection
  6922                          ;   entry:   ac = # of chars
  6923                          ;   exit:    ptr in y,x otherwise
  6924                          ;   blows off to 'out of string space' error
  6925                          ;   also preserves ac and sets frespc=
  6926                          ;   y,x= ->at space.
  6927                          ; ad53 getspa
  6928                          
  6929  ab9c 4613               getspa:	lsr garbfl
  6930  ab9e aa                 tryag2:	tax			; save in x also
  6931  ab9f f046               	beq getrts		; length of 0 no go...
  6932  aba1 48                 	pha			; save a (length) on stack
  6933  aba2 a539               	lda fretop		; lo byte
  6934  aba4 38                 	sec			; for subtract
  6935  aba5 e903               	sbc #ptrsiz		; minus 3 (link bytes)
  6936  aba7 a43a               	ldy fretop+1
  6937  aba9 b003               	bcs tryag3
  6938  abab f03b               	beq garbag		; make sure no wraparound to $ff page
  6939  abad 88                 	dey
  6940  abae 8522               tryag3:	sta index1		; save for later
  6941  abb0 8423               	sty index1+1
  6942  abb2 8a                 	txa
  6943  abb3 49ff               	eor #$ff
  6944  abb5 38                 	sec
  6945  abb6 6522               	adc index1
  6946  abb8 b00a               	bcs tryag4
  6947  abba 8d5b02             	sta tttemp		; prevent wraparound to $ff page
  6948  abbd 98                 	tya
  6949  abbe f028               	beq garbag
  6950  abc0 ad5b02             	lda tttemp
  6951  abc3 88                 	dey
  6952  abc4 c438               tryag4:	cpy strend+1
  6953  abc6 9020               	bcc garbag
  6954  abc8 d004               	bne strfre
  6955  abca c537               	cmp strend
  6956  abcc 901a               	bcc garbag
  6957  abce 853b               strfre:	sta frespc
  6958  abd0 843c               	sty frespc+1
  6959  abd2 a002               	ldy #$02		; flag string as garb.
  6960  abd4 a9ff               	lda #$ff		; garbage flag
  6961  abd6 9122               	sta (index1),y
  6962  abd8 88                 	dey
  6963  abd9 9122               	sta (index1),y		; flag
  6964  abdb 88                 	dey
  6965  abdc 68                 	pla			; length
  6966  abdd 9122               	sta (index1),y
  6967  abdf a63b               	ldx frespc
  6968  abe1 a43c               	ldy frespc+1
  6969  abe3 8639               	stx fretop
  6970  abe5 843a               	sty fretop+1
  6971                          
  6972  abe7 60                 getrts:	rts
  6973                          
  6974  abe8 a513               garbag:	lda garbfl
  6975  abea 3009               	bmi grbg99		; if out of memory
  6976  abec 20f8ab             	jsr garba2
  6977  abef 38                 	sec
  6978  abf0 6613               	ror garbfl
  6979  abf2 68                 	pla
  6980  abf3 d0a9               	bne tryag2  		; always
  6981                          
  6982  abf5 4c2485             grbg99:	jmp omerr  		; out of memory
  6983                          ; -------------------------------------------------------------------------------------------------
  6984                          ; garba2 - routine looks for and squashes out any unused string space it finds.
  6985                          ;   thus returning the space for future use by the string routines.
  6986                          ;   garba2 is called only when basic needs space of a fre instruction is used.
  6987                          
  6988  abf8 a51d               garba2:	lda temppt      	; get # of temporary strings
  6989  abfa f01f               	beq naa         	; skip if none
  6990                          ; create a back pointer on current temporary strings
  6991  abfc 48                 la:	pha			; save # of temps
  6992  abfd 20e4ac             	jsr slr1
  6993  ac00 f003               	beq la10
  6994  ac02 4c08ac             	jmp la20
  6995  ac05 4c15ac             la10	jmp la30
  6996  ac08 98                 la20:	tya			; .y now points to which temporary descriptor
  6997                          	         		; get location of temp descriptor
  6998  ac09 18                 	clc
  6999  ac0a 6520               	adc tempst
  7000  ac0c a000               	ldy #0
  7001  ac0e 9168               	sta (tempf2),y		; and create a back pointer to it
  7002  ac10 a521               	lda tempst+1
  7003  ac12 c8                 	iny
  7004  ac13 9168               	sta (tempf2),y
  7005                          
  7006  ac15 68                 la30:	pla
  7007  ac16 38                 	sec
  7008  ac17 e904               	sbc #4
  7009  ac19 d0e1               	bne la    		; repeat if this was not last temporary
  7010                          ; main body of garbage collect
  7011  ac1b a000               naa:	ldy #$00		; set up flag
  7012  ac1d 8462               	sty highds
  7013  ac1f a53d               	lda memtop		; get top of memory
  7014  ac21 a43e               	ldy memtop+1
  7015  ac23 856b               	sta grbtop		; set both pointers
  7016  ac25 8559               	sta grbpnt
  7017  ac27 853b               	sta frespc
  7018  ac29 846c               	sty grbtop+1
  7019  ac2b 845a               	sty grbpnt+1
  7020  ac2d 843c               	sty frespc+1
  7021                          
  7022                          ; do while (grbpnt <> fretop)
  7023  ac2f 2089ac             gloop:	jsr chkgrb		; check garbage string
  7024  ac32 d00c               	bne col01		; if not garbage string
  7025  ac34 a000               col00a:	ldy #0			; get length
  7026  ac36 b159               	lda (grbpnt),y
  7027  ac38 2006ad             	jsr movpnt		; move grbpnt to next
  7028  ac3b 38                 	sec
  7029  ac3c 6662               	ror highds		; indicate garbage string found
  7030  ac3e d0ef               	bne gloop		; always
  7031                          
  7032  ac40 2462               col01:	bit highds
  7033  ac42 102f               	bpl col03		; if garbare string not found
  7034  ac44 a200               	ldx #$00
  7035  ac46 8662               	stx highds		; clear indicator
  7036                          
  7037                          ; move a string over garbage
  7038  ac48 a002               col02:	ldy #$02		; move the link bytes
  7039                          
  7040  ac4a b159               col02a:	lda (grbpnt),y
  7041  ac4c 916b               	sta (grbtop),y
  7042  ac4e 88                 	dey
  7043  ac4f 10f9               	bpl col02a
  7044                          
  7045  ac51 2079ac             	jsr sav7
  7046  ac54 8a                 	txa			; put length-1 in .y
  7047  ac55 a8                 	tay
  7048                          
  7049  ac56 88                 glop1:	dey
  7050  ac57 b159               	lda (grbpnt),y
  7051  ac59 916b               	sta (grbtop),y
  7052  ac5b ca                 	dex
  7053  ac5c d0f8               	bne glop1
  7054                          
  7055  ac5e a002               	ldy #$02		; fix the descriptor
  7056  ac60 b96a00             col02b:	lda grbtop-1,y
  7057  ac63 9122               	sta (index1),y
  7058  ac65 88                 	dey
  7059  ac66 d0f8               	bne col02b
  7060  ac68 a559               	lda grbpnt		; check pointer
  7061  ac6a a45a               	ldy grbpnt+1
  7062  ac6c 2089ac             	jsr chkgrb		; check garbage string
  7063  ac6f f0c3               	beq col00a		; if garbage string found
  7064  ac71 d0d5               	bne col02		; always
  7065                          
  7066  ac73 2079ac             col03:	jsr sav7
  7067  ac76 4c2fac             	jmp gloop
  7068                          
  7069  ac79 a000               sav7:	ldy #0 			; skip over string body
  7070  ac7b b122               	lda (index1),y
  7071  ac7d aa                 	tax
  7072  ac7e 2015ad             	jsr movtop
  7073  ac81 853b               	sta frespc
  7074  ac83 843c               	sty frespc+1
  7075  ac85 8a                 	txa
  7076  ac86 4c06ad             	jmp movpnt
  7077                          ; -------------------------------------------------------------------------------------------------
  7078                          ; adb5 subroutines used for garbage collection
  7079                          ;   compare for y,a = fretop.
  7080                          ;   entry:   y,a = address of current string descriptor.
  7081                          ;   exit:    exit to caller if y,a = fretop.
  7082                          ;   else:    z flag set if garbage string.
  7083                          ;            z flag clear if not garbage string.
  7084                          ;   in either case pointers are setup for next loop and string movement.
  7085                          ;   exit to cfre4.
  7086                          ;   carry clear y,a <> fretop.
  7087                          
  7088  ac89 c43a               chkgrb:	cpy fretop+1		; end of strings ?
  7089  ac8b 9028               	bcc cfre4
  7090  ac8d d006               	bne cfre1		; if not equal
  7091  ac8f c539               	cmp fretop
  7092  ac91 f022               	beq cfre4
  7093  ac93 9020               	bcc cfre4
  7094                          
  7095  ac95 2462               cfre1:	bit highds		; check flag
  7096  ac97 3005               	bmi cfre2		; if empty string found
  7097  ac99 a903               	lda #ptrsiz		; skip pointers past
  7098  ac9b 2015ad             	jsr movtop		; move top pointer
  7099  ac9e a903               cfre2:	lda #ptrsiz		; skip pointers past
  7100  aca0 2006ad             	jsr movpnt		; move pointers
  7101  aca3 a002               	ldy #$02
  7102  aca5 b159               	lda (grbpnt),y		; garbage ?
  7103  aca7 c9ff               	cmp #$ff
  7104  aca9 d001               	bne cfre3		; if not garbage string
  7105  acab 60                 	rts
  7106                          
  7107  acac b159               cfre3:	lda (grbpnt),y		; to link bytes
  7108  acae 992200             	sta index1,y
  7109  acb1 88                 	dey
  7110  acb2 10f8               	bpl cfre3		; if three bytes not moved
  7111  acb4 60                 	rts
  7112                          ; mark temporary strings as garbage and exit
  7113  acb5 a51d               cfre4:	lda temppt  		; get # of temporary strings
  7114  acb7 f020               	beq naa2    		; skip if none
  7115                          
  7116                          ; mark current temporary strings as garbage
  7117  acb9 48                 fa:	pha     		; save # of temps
  7118  acba 20e4ac             	jsr slr1
  7119  acbd f003               	beq fa10
  7120  acbf 4cc5ac             	jmp fa20
  7121  acc2 4cd3ac             fa10:	jmp fa30
  7122  acc5 b120               fa20:	lda (tempst),y 		; get string length
  7123  acc7 a000               	ldy #0     		; set up index
  7124  acc9 9168               	sta (tempf2),y 		; replace back pointer
  7125  accb c8                 	iny
  7126  accc a9ff               	lda #$ff
  7127  acce 9168               	sta (tempf2),y
  7128  acd0 c8                 	iny
  7129  acd1 9168               	sta (tempf2),y
  7130                          
  7131  acd3 68                 fa30:	pla
  7132  acd4 38                 	sec
  7133  acd5 e904               	sbc #4
  7134  acd7 d0e0               	bne fa    		; repeat if this was not last temporary
  7135                          
  7136  acd9 68                 naa2:	pla			; throw away return address
  7137  acda 68                 	pla
  7138  acdb a53b               	lda frespc		; fix fretop and frespc
  7139  acdd a43c               	ldy frespc+1
  7140  acdf 8539               	sta fretop
  7141  ace1 843a               	sty fretop+1
  7142  ace3 60                 	rts
  7143                          	
  7144  ace4 a8                 slr1:	tay
  7145  ace5 88                 	dey
  7146  ace6 88                 	dey
  7147  ace7 b120               	lda (tempst),y  	; get high byte of address
  7148  ace9 8569               	sta tempf2+1    	; and save it
  7149  aceb 88                 	dey
  7150  acec b120               	lda (tempst),y  	; get low byte of address
  7151  acee 8568               	sta tempf2    		; and save it
  7152  acf0 88                 	dey
  7153  acf1 b120               	lda (tempst),y  	; get length of string
  7154  acf3 48                 	pha
  7155  acf4 18                 	clc
  7156  acf5 6568               	adc lowds
  7157  acf7 8568               	sta lowds
  7158  acf9 9002               	bcc slr10
  7159  acfb e669               	inc lowds+1
  7160  acfd 68                 slr10:	pla
  7161  acfe 60                 	rts
  7162  acff 8568               	sta tempf2  		; rather than body of the string
  7163  ad01 9002               	bcc slr2
  7164  ad03 e669               	inc tempf2+1
  7165  ad05 60                 slr2:	rts
  7166                          
  7167  ad06 49ff               movpnt:	eor #$ff		; comp and add
  7168  ad08 38                 	sec
  7169  ad09 6559               	adc grbpnt
  7170  ad0b a45a               	ldy grbpnt+1
  7171  ad0d b001               	bcs mov00
  7172  ad0f 88                 	dey
  7173  ad10 8559               mov00:	sta grbpnt
  7174  ad12 845a               	sty grbpnt+1
  7175  ad14 60                 	rts
  7176                          	
  7177  ad15 49ff               movtop:	eor #$ff		; comp and add
  7178  ad17 38                 	sec
  7179  ad18 656b               	adc grbtop
  7180  ad1a a46c               	ldy grbtop+1
  7181  ad1c b001               	bcs mov01
  7182  ad1e 88                 	dey
  7183  ad1f 856b               mov01:	sta grbtop
  7184  ad21 846c               	sty grbtop+1
  7185  ad23 60                 	rts
  7186                          ; -------------------------------------------------------------------------------------------------
  7187                          ; instrg - instring
  7188                          
  7189  ad24 4c189b             infcer:	jmp fcerr		; -> illegal quantity error, ready
  7190                          
  7191  ad27 a202               instrg:	ldx #2
  7192  ad29 b572               incop1:	lda facmo,x		; save pointer to temporary descriptor
  7193  ad2b 9da002             	sta tmpdes,x
  7194  ad2e ca                 	dex
  7195  ad2f 10f8               	bpl incop1
  7196  ad31 207a95             	jsr frmevl		; get next arg.
  7197  ad34 209cae             	jsr chkstr		; must be string
  7198  ad37 a202               	ldx #2
  7199  ad39 b572               incop2:	lda facmo,x		; and save it, too
  7200  ad3b 9da302             	sta tmpdes+3,x
  7201  ad3e ca                 	dex
  7202  ad3f 10f8               	bpl incop2
  7203                          
  7204  ad41 a201               	ldx #1
  7205  ad43 8673               	stx faclo		; if no starting position is given, 1 is assumed
  7206  ad45 20aca9             	jsr sav17
  7207  ad48 20e496             inst1:	jsr chkcls
  7208  ad4b a673               	ldx faclo
  7209  ad4d f0d5               	beq infcer		; s.a. of 0 is an error
  7210  ad4f ca                 	dex
  7211  ad50 8671               	stx positn
  7212                          
  7213  ad52 a205               	ldx #5			; move pointers to temp descriptors to zero page
  7214  ad54 bda002             inst2:	lda tmpdes,x
  7215  ad57 9562               	sta ptarg1,x
  7216  ad59 ca                 	dex
  7217  ad5a 10f8               	bpl inst2
  7218                          
  7219  ad5c a003               	ldy #3
  7220  ad5e b162               inst3:	lda (ptarg1),y
  7221  ad60 996800             	sta str1,y
  7222  ad63 88                 	dey
  7223  ad64 10f8               	bpl inst3
  7224                          
  7225  ad66 a003               	ldy #3
  7226  ad68 b165               inst4:	lda (ptarg2),y
  7227  ad6a 996c00             	sta str2,y
  7228  ad6d 88                 	dey
  7229  ad6e 10f8               	bpl inst4
  7230                          
  7231  ad70 a56c               	lda str2		; check if string 2 is null
  7232  ad72 f035               	beq instnf		; if so, return zero
  7233                          
  7234  ad74 a900               inst5:	lda #0
  7235  ad76 8572               	sta match
  7236  ad78 18                 	clc
  7237  ad79 a56c               	lda str2		; length of string 2
  7238  ad7b 6571               	adc positn
  7239  ad7d b02a               	bcs instnf		; too long, not found
  7240  ad7f c568               	cmp str1		; see if > length of string 1
  7241  ad81 9002               	bcc inst6		; < len. string 1
  7242  ad83 d024               	bne instnf		; must be >, not found
  7243  ad85 a472               inst6:	ldy match
  7244  ad87 c46c               	cpy str2		; if match len. = str. len, then found
  7245  ad89 f019               	beq instfd
  7246  ad8b 98                 	tya
  7247  ad8c 18                 	clc
  7248  ad8d 6571               	adc positn		; compare string1(s+p+m) with string2(m)
  7249  ad8f a8                 	tay
  7250  ad90 b169               	lda (str1+1),y
  7251  ad92 8570               	sta tmppos
  7252  ad94 a472               	ldy match
  7253  ad96 b16d               	lda (str2+1),y
  7254  ad98 c570               	cmp tmppos
  7255  ad9a f004               	beq inst7
  7256  ad9c e671               	inc positn		; not the same, start over from next position
  7257  ad9e d0d4               	bne inst5		; always
  7258  ada0 e672               inst7:	inc match		; count characters that match
  7259  ada2 d0e1               	bne inst6		; always
  7260                          
  7261  ada4 e671               instfd:	inc positn
  7262  ada6 a571               	lda positn
  7263  ada8 2c                 	!byte $2c
  7264  ada9 a900               instnf:	lda #0
  7265  adab 48                 	pha
  7266  adac ada302             	lda tmpdes+3		; free temp descriptors
  7267  adaf aca402             	ldy tmpdes+4
  7268  adb2 aea502             	ldx tmpdes+5
  7269  adb5 20c7a7             	jsr fretmp
  7270  adb8 ada002             	lda tmpdes
  7271  adbb aca102             	ldy tmpdes+1
  7272  adbe aea202             	ldx tmpdes+2
  7273  adc1 20c7a7             	jsr fretmp
  7274  adc4 68                 	pla 			; send result back as an integer
  7275  adc5 a8                 	tay
  7276  adc6 4c7e9c             	jmp sngflt
  7277                          ; ******************************************* DELETE **********************************************
  7278                          ; DELETE -  delete a range of source
  7279                          ;   syntax: delete from#,to#
  7280                          
  7281  adc9 4c0e97             nrange:	jmp snerr		; -> syntax error, ready
  7282                          
  7283  adcc f0fb               delete:	beq nrange		; bad..no range parms.
  7284  adce 2020ae             	jsr range		; get line # range
  7285  add1 f0f6               	beq nrange		; some range errors
  7286  add3 a56b               	lda lowtr		; save it
  7287  add5 a66c               	ldx lowtr+1
  7288  add7 8525               	sta index2
  7289  add9 8626               	stx index2+1
  7290  addb 20f786             	jsr fndlin		; find it
  7291  adde 9012               	bcc del300		; skip if not found
  7292  ade0 a001               	ldy #1
  7293  ade2 b16b               	lda (lowtr),y   	; at end of source ?
  7294  ade4 88                 	dey
  7295  ade5 aa                 	tax			; save it in case of swap
  7296  ade6 d004               	bne noteos
  7297  ade8 b16b               	lda (lowtr),y
  7298  adea f006               	beq del300 		; both zero means end-of-source
  7299  adec b16b               noteos:	lda (lowtr),y
  7300  adee 856b               	sta lowtr		; include to line #
  7301  adf0 866c               	stx lowtr+1
  7302  adf2 a525               del300:	lda index2		; check from#<to#
  7303  adf4 38                 	sec
  7304  adf5 e56b               	sbc lowtr		; gen neg delta
  7305  adf7 aa                 	tax
  7306  adf8 a526               	lda index2+1
  7307  adfa e56c               	sbc lowtr+1
  7308  adfc a8                 	tay
  7309  adfd b01e               	bcs notdel		; no good
  7310  adff 8a                 	txa
  7311  ae00 18                 	clc
  7312  ae01 652f               	adc txtend		; gen new end of source
  7313  ae03 852f               	sta txtend
  7314  ae05 98                 	tya
  7315  ae06 6530               	adc txtend+1
  7316  ae08 8530               	sta txtend+1
  7317  ae0a a000               	ldy #0
  7318  ae0c b16b               del500:	lda (lowtr),y   	; move source down
  7319  ae0e 9125               	sta (index2),y
  7320  ae10 c8                 	iny
  7321  ae11 d0f9               	bne del500
  7322  ae13 e66c               	inc lowtr+1
  7323  ae15 e626               	inc index2+1
  7324  ae17 a530               	lda txtend+1		; done one extra page
  7325  ae19 c526               	cmp index2+1
  7326  ae1b b0ef               	bcs del500		; no
  7327  ae1d 4c7986             notdel:	jmp fini		; relink and say ready
  7328                          ; -------------------------------------------------------------------------------------------------
  7329                          ; range - input range parms
  7330                          ;   exit: z=1, if range errors
  7331                          
  7332  ae20 9009               range:	bcc rng100		; from chrgot a # ?
  7333  ae22 f007               	beq rng100		; a terminator
  7334  ae24 c9ab               	cmp #tkminu		; a dash
  7335  ae26 f003               	beq rng100
  7336  ae28 a900               rngerr:	lda #0			; z=1, syntax error
  7337  ae2a 60                 	rts
  7338                          
  7339  ae2b 20298d             rng100:	jsr linget		; get #
  7340  ae2e 20f786             	jsr fndlin		; find or set ptrs
  7341  ae31 2081b3             	jsr chrgot		; get last char
  7342  ae34 f00c               	beq rng200		; skip done
  7343  ae36 c9ab               	cmp #tkminu		; a dash
  7344  ae38 d0ee               	bne rngerr		; syntax error
  7345  ae3a 207eb3             	jsr chrget		; yes - skip dash
  7346  ae3d 20298d             	jsr linget		; get to #
  7347  ae40 d0e6               	bne rngerr		; not a number err
  7348  ae42 a51b               rng200:	lda linnum
  7349  ae44 051c               	ora linnum+1		; was a # to input ?
  7350  ae46 d006               	bne rngrts		; yes
  7351  ae48 a9ff               	lda #$ff		; no - make max
  7352  ae4a 851b               	sta linnum
  7353  ae4c 851c               	sta linnum+1
  7354  ae4e 60                 rngrts:	rts			; z=0, no errors
  7355                          ; -------------------------------------------------------------------------------------------------
  7356  ae4f b122               sav12:	lda (index),y
  7357  ae51 60                 	rts
  7358                          ; ******************************************* BUTES1 **********************************************
  7359                          ; 'basic utility routines'
  7360                          ; stxtpt
  7361                          
  7362  ae52 18                 stxtpt:	clc
  7363  ae53 a52d               	lda txttab
  7364  ae55 69ff               	adc #255
  7365  ae57 8583               	sta txtptr
  7366  ae59 a52e               	lda txttab+1
  7367  ae5b 69ff               	adc #255
  7368  ae5d 8584               	sta txtptr+1
  7369  ae5f 60                 	rts
  7370                          ; -------------------------------------------------------------------------------------------------
  7371                          ; getnum - get positive integer
  7372                          
  7373  ae60 207bae             getnum:	jsr getpin
  7374                          ; check comma
  7375  ae63 20ea96             combyt:	jsr chkcom
  7376  ae66 4c6cae             	jmp getbyt
  7377                          
  7378  ae69 207eb3             gtbytc:	jsr chrget
  7379                          
  7380  ae6c 2097ae             getbyt:	jsr frmnum
  7381  ae6f 20859a             conint:	jsr posint
  7382  ae72 a672               	ldx facmo
  7383  ae74 d01e               	bne fcer1
  7384  ae76 a673               	ldx faclo
  7385  ae78 4c81b3             	jmp chrgot
  7386                          ; -------------------------------------------------------------------------------------------------
  7387                          ; getpin - evaluate the formula
  7388                          
  7389  ae7b 2097ae             getpin:	jsr frmnum
  7390                          
  7391  ae7e a574               getadr:	lda facsgn
  7392  ae80 3012               	bmi fcer1
  7393  ae82 a56f               	lda facexp
  7394  ae84 c991               	cmp #145
  7395  ae86 b00c               	bcs fcer1
  7396  ae88 2099a1             	jsr qint
  7397  ae8b a572               	lda facmo
  7398  ae8d a473               	ldy facmo+1
  7399  ae8f 841b               	sty poker
  7400  ae91 851c               	sta poker+1
  7401  ae93 60                 	rts
  7402                          
  7403                          bjmps:		  		; referenced in initialization routine
  7404  ae94 4c189b             fcer1:	jmp fcerr		; -> illegal quantity error, ready
  7405                          ; -------------------------------------------------------------------------------------------------
  7406                          ; these routines check for certain 'valtyp'
  7407                          ;   (c) is not preserved.
  7408                          ; frmnum
  7409                          
  7410  ae97 207a95             frmnum:	jsr frmevl
  7411                          
  7412  ae9a 18                 chknum:	clc
  7413  ae9b 24                 	!byte $24
  7414  ae9c 38                 chkstr:	sec
  7415                          
  7416  ae9d 2411               chkval:	bit valtyp
  7417  ae9f 3003               	bmi docstr
  7418  aea1 b003               	bcs chkerr
  7419  aea3 60                 chkok:	rts
  7420                          
  7421  aea4 b0fd               docstr:	bcs chkok
  7422  aea6 a242               chkerr:	ldx #errtm
  7423  aea8 4c2685             	jmp error
  7424                          ; -------------------------------------------------------------------------------------------------
  7425                          ; strprt - print the str whose descriptor is -> by facmo
  7426                          
  7427  aeab 20c3a7             strprt:	jsr frefac		; return temp -}
  7428  aeae aa                 	tax			; put count into counter
  7429  aeaf a000               	ldy #0
  7430  aeb1 e8                 	inx
  7431                          
  7432                          ; output x characters to device
  7433  aeb2 ca                 strp2:	dex
  7434  aeb3 f009               	beq strp3
  7435  aeb5 b122               	lda (index),y
  7436  aeb7 20cbae             	jsr ochr		; output one char
  7437  aeba c8                 	iny
  7438  aebb 4cb2ae             	jmp strp2		; next
  7439  aebe 60                 strp3:	rts
  7440                          ; -------------------------------------------------------------------------------------------------
  7441                          ; output space
  7442  aebf a51a               ospc:	lda channl
  7443  aec1 f003               	beq crtskp
  7444  aec3 a920               	lda #' '
  7445  aec5 2c                 	!byte $2c		; eat next two bytes
  7446  aec6 a91d               crtskp:	lda #29
  7447  aec8 2c                 	!byte $2c		; eat next two bytes
  7448  aec9 a93f               outqst:	lda #'?'
  7449                          ; output one character to device
  7450  aecb 2030b5             ochr:	jsr bsout		; output character
  7451  aece 29ff               	and #$ff
  7452  aed0 60                 	rts
  7453                          ; -------------------------------------------------------------------------------------------------
  7454                          ; 'dos utility routines.' -mgm 7/23/79-
  7455                          ;   this is the dos parser routine which looks at lines passed to it and varifies that the syntax
  7456                          ;   is proper.
  7457                          ;   entry (dosprs): a = parsts bit which must be zero.
  7458                          ;   exit:    a = parsts as follows
  7459                          ;
  7460                          ; i-i-i-i-i-i-i-i-i
  7461                          ; i7+6+5+4+3+2+1+0i
  7462                          ; i-i-i-i-i-i-i-i-i
  7463                          ;  ^ ^ ^ ^ ^ ^ ^ ^ ====>  fn1 this bit is set when the
  7464                          ;  | | | | | | | |             first filename is parsed
  7465                          ;  | | | | | | | ======>  fn2 set for second filename
  7466                          ;  | | | | | |=========>  la set when #lfn parsed
  7467                          ;  | | | | |===========>  fa set for device number
  7468                          ;  | | | | ============>  d1 set for first disk unit
  7469                          ;  | | | ==============>  d2 set for second disk unit
  7470                          ;  | | ================>  dosrcl set for record size
  7471                          ;  | ==================>  @ set when @ encountered.
  7472                          ;
  7473                          ; the following are the vaild bit patterns for parsts after parsing for the various keywords
  7474                          ;
  7475                          ;      7 6 5 4   3 2 1 0
  7476                          ; (format)
  7477                          ;  header   0 0 0 1   * 0 0 1
  7478                          ;  colect   0 0 0 *   * 0 0 0
  7479                          ;  backup   0 0 1 1   * 0 0 0
  7480                          ;  copy     0 0 1 1   * 0 0 0
  7481                          ;    or..   0 0 * *   * 0 1 1
  7482                          ;  concat   0 0 * *   * 0 1 1
  7483                          ;  bsave    * 0 0 *   * 0 0 1
  7484                          ;  dsave    * 0 0 *   * 0 0 1
  7485                          ;  bload    0 0 0 *   * 0 0 1
  7486                          ;  dload    0 0 0 *   * 0 0 1
  7487                          ;  catlog   0 0 0 *   * 0 0 *
  7488                          ;  rename   0 0 0 *   * 0 1 1
  7489                          ;  append   0 0 0 *   * 1 0 1
  7490                          ;  scrtch   0 0 0 *   * 0 0 1
  7491                          ;  dopen    * * 0 *   * 1 0 1
  7492                          ;  dclose   0 0 0 0   * * 0 0
  7493                          ;      ^ ^ ^ ^   ^ ^ ^ ^
  7494                          ;      @ l d d   f l f f
  7495                          ;      r r 2 1   a a n n
  7496                          ;      p e           2 1
  7497                          ;      l l
  7498                          ;
  7499                          ;    "0" bits are required to be clear.
  7500                          ;    "1" bits are required to be set.
  7501                          ;    "*" bits are optional parameters.
  7502                          ;
  7503                          ; entry (dosprs):  parstx shall be set to prevent any auxiliary options to be specified.
  7504                          ; entry (dosprx):  x = parstx bits whic must be zero.
  7505                          ; exit: x = parstx as follows
  7506                          ;
  7507                          ; i-i-i-i-i-i-i-i-i
  7508                          ; i7+6+5+4+3+2+1+0i
  7509                          ; i-i-i-i-i-i-i-i-i
  7510                          ;  ^ ^ ^ ^ ^ ^ ^ ^ ====>  bnk is set for bank option
  7511                          ;  < < < < < < < ======>  offl set for 1st address
  7512                          ;  < < < < < <=========>  offh set for 2nd address
  7513                          ;  < < < < <===========>  unused
  7514                          ;  < < < < ============>  unused
  7515                          ;  < < < = ============>  unused
  7516                          ;  < < = = ============>  unused
  7517                          ;  < = = = ============>  unused
  7518                          
  7519                          ; the following are the vaild bit patterns for parstx after parsing for the various keywords
  7520                          ; only two stmts are allowed bits set in parstx.
  7521                          
  7522                          ;      7 6 5 4   3 2 1 0
  7523                          ; (format)
  7524                          ;  bsave    0 0 0 0   0 * * *
  7525                          ;  bload    0 0 0 0   0 0 * *
  7526                          ;      ^ ^ ^ ^   ^ ^ ^ ^
  7527                          ;      ? ? ? ?   ? o o b
  7528                          ;                  f f n
  7529                          ;                  h l k
  7530                          ;    "0" bits are required to be clear.
  7531                          ;    "1" bits are required to be set.
  7532                          ;    "*" bits are optional parameters.
  7533                          
  7534  aed1 ffffffff0e086f     dostbl:	!byte $ff,$ff,$ff,$ff,doslfn,dosdsk,$6f
  7535                          
  7536                          ; dospar
  7537                          
  7538  aed8 a900               dospar:	lda #0
  7539                          ; special error flag entry
  7540  aeda a2ff               dosprs:	ldx    #$ff		; no aux options!
  7541                          ; spec aux error flag entry
  7542  aedc 48                 dosprx:	pha			; save error flags
  7543  aedd 8a                 	txa
  7544  aede 48                 	pha
  7545  aedf a900               	lda #0
  7546  aee1 8589               	sta parsts
  7547  aee3 858a               	sta parstx
  7548                          
  7549  aee5 a226               	ldx #dosspc-1		; clear dos scratch area
  7550  aee7 9d0002             dos01:	sta fbuffr,x
  7551  aeea ca                 	dex
  7552  aeeb d0fa               	bne dos01
  7553  aeed a206               	ldx #dossa-dosofl	; set some defaults from table
  7554  aeef bdd1ae             dos02:	lda dostbl,x
  7555  aef2 9d1b02             	sta dosofl,x
  7556  aef5 ca                 	dex
  7557  aef6 10f7               	bpl dos02
  7558  aef8 a5b7               	lda ddisk		; get default drive
  7559  aefa a205               	ldx #5			; disdsk
  7560  aefc 9d1b02             	sta dosofl,x		; store as default (overwrite fixed table value)
  7561  aeff ae5702             	ldx dfbank
  7562  af02 8e1a02             	stx dosbnk
  7563                          
  7564  af05 2081b3             	jsr chrgot		; get current chr
  7565  af08 d00e               	bne parse1		; if not end of statement
  7566                          
  7567  af0a 68                 done:	pla			; get aux error flag
  7568  af0b 258a               	and parstx		;  repeated,illegal params?
  7569  af0d d05c               	bne dn20
  7570  af0f 68                 	pla			; get error flags
  7571  af10 203db1             	jsr prmrpt
  7572  af13 a589               	lda parsts
  7573  af15 a68a               	ldx parstx
  7574  af17 60                 	rts
  7575                          
  7576  af18 c923               parse1:	cmp #'#'
  7577  af1a f03c               	beq logadr		; if logical file number
  7578  af1c c957               	cmp #'w'
  7579  af1e f04e               	beq reclen		; if record length
  7580  af20 c94c               	cmp #'l'
  7581  af22 f04a               	beq reclen		; if record length
  7582  af24 c952               	cmp #'r'
  7583  af26 d016               	bne dos5		; if not ????
  7584  af28 207eb3             	jsr chrget		; move on
  7585  af2b 4c1fb0             	jmp delim1
  7586                          
  7587  af2e 20a6b0             on1:	jsr on
  7588  af31 4c1bb0             sav60:	jmp del1
  7589                          
  7590  af34 20b3b0             unit1:	jsr unit		; do unit# parsing
  7591  af37 d0f8               	bne sav60    		; always
  7592                          
  7593  af39 20c4b0             bank1:	jsr bank
  7594  af3c f0f3               	beq sav60    		; always
  7595                          
  7596  af3e c944               dos5:	cmp #'d'
  7597  af40 f058               	beq drv1
  7598  af42 c991               	cmp #tkon		; "on" token
  7599  af44 f0e8               	beq on1
  7600  af46 c942               	cmp #'b'
  7601  af48 f0ef               	beq bank1
  7602  af4a c955               	cmp #'u'
  7603  af4c f0e6               	beq unit1
  7604  af4e c950               	cmp #'p'
  7605  af50 f068               	beq doffl
  7606  af52 c949               	cmp #'i'
  7607  af54 d03a               	bne dos10		; if not identifier
  7608  af56 f05b               	beq ident
  7609                          	
  7610  af58 a904               logadr:	lda #4
  7611  af5a 203db1             	jsr prmrpt		; check for repeated parameter
  7612  af5d 2012b1             	jsr getval
  7613  af60 e000               	cpx #0
  7614  af62 f04c               	beq qtyer2		; if illegal value
  7615  af64 8e1f02             	stx dosla
  7616  af67 a904               	lda #4			; set logical address flag
  7617  af69 d0c6               	bne sav60		; get next parameter
  7618  af6b 4c0e97             dn20:	jmp snerr
  7619                          	
  7620  af6e aa                 reclen:	tax			; save char
  7621  af6f a940               	lda #$40
  7622  af71 203db1             	jsr prmrpt		; check for repeated parameter
  7623  af74 e057               	cpx #'w'
  7624  af76 d006               	bne recoo
  7625  af78 207eb3             	jsr chrget
  7626  af7b 4c8caf             	jmp recon		; set parsts
  7627  af7e 2012b1             recoo:	jsr getval
  7628  af81 e000               	cpx #0
  7629  af83 f02b               	beq qtyer2		; zero illegal dosrcl
  7630  af85 e0ff               	cpx #255
  7631  af87 f027               	beq qtyer2		; illegal dosrcl
  7632  af89 8e2202             	stx dosrcl		; store parcel
  7633                          
  7634  af8c a940               recon:	lda #$40		; set dosrcl flag &
  7635  af8e d01e               	bne tacky1
  7636                          
  7637  af90 c922               dos10:	cmp #$22;"
  7638  af92 f065               	beq name1
  7639  af94 c928               	cmp #'('
  7640  af96 f061               	beq name1
  7641  af98 d0d1               	bne dn20
  7642                          
  7643  af9a a910               drv1:	lda #$10
  7644  af9c 203db1             	jsr prmrpt		; check for repeated parameter
  7645  af9f 2012b1             	jsr getval
  7646  afa2 e002               	cpx #2
  7647  afa4 b00a               	bcs qtyer2		; illegal drv# if >1
  7648  afa6 8e1102             	stx dosds1
  7649  afa9 8e1602             	stx dosds2
  7650  afac a910               	lda #$10
  7651  afae d06b               tacky1:	bne del1
  7652                          
  7653  afb0 4ca3b0             qtyer2:	jmp qtyerr
  7654                          	
  7655  afb3 ad2502             ident:	lda didchk
  7656  afb6 f02a               	beq idcon		; only 1 dosdid allowed
  7657  afb8 d0b1               	bne dn20
  7658                          
  7659  afba a902               doffl:	lda #$02		; chk aux status
  7660  afbc 2042b1             	jsr prxrpt
  7661  afbf 2025b1             	jsr getoff		; get offset value
  7662  afc2 8c1b02             	sty dosofl
  7663  afc5 8d1c02             	sta dosofl+1
  7664  afc8 a902               	lda #$02
  7665  afca 058a               dlimx1:	ora parstx		; set aux status bits
  7666  afcc 858a               	sta parstx
  7667  afce d04f               	bne delim1		; try for nxt param
  7668                          
  7669  afd0 a904               doffh:	lda #$04
  7670  afd2 2042b1             	jsr prxrpt
  7671  afd5 2025b1             	jsr getoff
  7672  afd8 8c1d02             	sty dosofh
  7673  afdb 8d1e02             	sta dosofh+1
  7674  afde a904               	lda #$04
  7675  afe0 d0e8               	bne dlimx1		; set aux status
  7676                          
  7677  afe2 207eb3             idcon:	jsr chrget		; get next character
  7678  afe5 8d2302             	sta dosdid		; m(txtptr => dosdid
  7679  afe8 207eb3             	jsr chrget
  7680  afeb 8d2402             	sta dosdid+1
  7681  afee a9ff               	lda #$ff
  7682  aff0 8d2502             	sta didchk		; set dosdid flag &
  7683  aff3 207eb3             	jsr chrget		; continue
  7684  aff6 4c1fb0             	jmp delim1
  7685                          	
  7686  aff9 a901               name1:	lda #1			; name1 allwd only once
  7687  affb 20dfb0             	jsr newnam		; do name parsing
  7688  affe 8d1002             	sta dosf1l
  7689  b001 850f               	sta xcnt		; save temp value
  7690  b003 a900               	lda #<fbuffr
  7691  b005 8d1202             	sta dosf1a
  7692  b008 a902               	lda #>fbuffr
  7693  b00a 8d1302             	sta dosf1a+1
  7694                          
  7695  b00d a000               	ldy #0
  7696  b00f b122               loop6:	lda (index),y
  7697  b011 990002             	sta fbuffr,y		;  set char in buffer
  7698  b014 c8                 	iny
  7699  b015 c40f               	cpy xcnt
  7700  b017 90f6               	bcc loop6		; if not full name
  7701  b019 a901               	lda #1			; set name1 flag
  7702                          
  7703  b01b 0589               del1:	ora parsts
  7704  b01d 8589               	sta parsts
  7705                          
  7706  b01f 2081b3             delim1:	jsr chrgot
  7707  b022 d019               	bne nxxx
  7708  b024 4c0aaf             done1:	jmp done		; <cr>/<>  => done
  7709                          
  7710  b027 c991               next6:	cmp #tkon
  7711  b029 d003               	bne next6a
  7712  b02b 4c2eaf             	jmp on1
  7713  b02e c9a4               next6a:	cmp #tkto		; "to" token
  7714  b030 f002               	beq next6b
  7715  b032 d06d               	bne sav61		; sntax error
  7716                          
  7717                          ; if "to" is not followed by an offset param, then do file2 params. otherwise, do high
  7718                          ; offset and continue with file0 options.
  7719  b034 207eb3             next6b:	jsr chrget
  7720  b037 c950               	cmp #'p'
  7721  b039 d00f               	bne pars22
  7722  b03b f093               	beq doffh
  7723                          
  7724  b03d c92c               nxxx:	cmp #','
  7725  b03f d0e6               	bne next6
  7726  b041 207eb3             	jsr chrget
  7727  b044 4c18af             	jmp parse1
  7728                          
  7729  b047 207eb3             parse2:	jsr chrget
  7730  b04a c944               pars22:	cmp #'d'
  7731  b04c f010               	beq drv2
  7732  b04e c991               	cmp #tkon		; "on" token
  7733  b050 f01f               	beq on2
  7734  b052 c955               	cmp #'u'
  7735  b054 f021               	beq unit2
  7736  b056 c922               	cmp #$22;"
  7737  b058 f022               	beq name2
  7738  b05a c928               	cmp #'('
  7739  b05c f01e               	beq name2
  7740                          
  7741  b05e a920               drv2:	lda #$20
  7742  b060 203db1             	jsr prmrpt		; check for repeated parameter
  7743  b063 2012b1             	jsr getval
  7744  b066 e002               	cpx #2
  7745  b068 b039               	bcs qtyerr		; illegal drive #
  7746  b06a 8e1602             	stx dosds2
  7747  b06d a920               	lda #$20
  7748  b06f d01b               	bne del2
  7749                          
  7750  b071 20a6b0             on2:	jsr on
  7751  b074 4c8cb0             	jmp del2
  7752                          
  7753  b077 20b3b0             unit2:	jsr unit		; do unit# parsing
  7754  b07a d010               	bne del2  		; always
  7755                          
  7756  b07c a902               name2:	lda #2			; name2 allowed only once
  7757  b07e 20dfb0             	jsr newnam
  7758  b081 8d1502             	sta dosf2l
  7759  b084 8e1702             	stx dosf2a
  7760  b087 8c1802             	sty dosf2a+1
  7761  b08a a902               	lda #2			; set filename2 flag &
  7762                          
  7763  b08c 0589               del2:	ora parsts		; set flag in status
  7764  b08e 8589               	sta parsts
  7765  b090 2081b3             	jsr chrgot
  7766  b093 f08f               	beq done1		; done on <cr>/<}
  7767  b095 c92c               	cmp #','
  7768  b097 f0ae               	beq parse2
  7769  b099 c991               	cmp #tkon		; "on" token
  7770  b09b f0d4               	beq on2
  7771  b09d c955               	cmp #'u'
  7772  b09f f0d6               	beq unit2
  7773                          
  7774  b0a1 d039               sav61:	bne sner
  7775                          	
  7776  b0a3 4c189b             qtyerr:	jmp fcerr		; "illegal quantity"
  7777                          
  7778  b0a6 207eb3             on:	jsr chrget
  7779  b0a9 c955               	cmp #'u'
  7780  b0ab f006               	beq unit		; if character is a "u"
  7781  b0ad c942               	cmp #'b'
  7782  b0af f013               	beq bank
  7783  b0b1 d029               	bne sner
  7784                          
  7785  b0b3 2012b1             unit:	jsr getval
  7786  b0b6 e020               	cpx #32
  7787  b0b8 b0e9               	bcs qtyerr		; error if >31
  7788  b0ba e003               	cpx #3
  7789  b0bc 90e5               	bcc qtyerr		; error if <3
  7790  b0be 8e2002             	stx dosfa
  7791  b0c1 a908               	lda #8
  7792  b0c3 60                 	rts
  7793                          
  7794  b0c4 a901               bank:	lda #$01		; repeated param?
  7795  b0c6 2042b1             	jsr prxrpt
  7796  b0c9 2012b1             	jsr getval
  7797  b0cc e010               	cpx #mxbank		; bank too large?
  7798  b0ce b0d3               	bcs qtyerr
  7799  b0d0 8e1a02             	stx dosbnk
  7800  b0d3 a901               	lda #$01
  7801  b0d5 058a               	ora parstx		; set bnk bit in aux status
  7802  b0d7 858a               	sta parstx
  7803  b0d9 a900               	lda #0			;  .a=std status wrd, no bits to set
  7804  b0db 60                 	rts
  7805                          
  7806  b0dc 4c0e97             sner:	jmp snerr		; jump syntax error
  7807                          
  7808  b0df 203db1             newnam:	jsr prmrpt		; check for repeated parameter
  7809  b0e2 209291             	jsr sav13
  7810  b0e5 aa                 	tax		; save length of string
  7811  b0e6 f0bb               	beq qtyerr		; if length = 0
  7812  b0e8 a000               	ldy #0
  7813  b0ea 204fae             	jsr sav12
  7814  b0ed c940               	cmp #'@'
  7815  b0ef d012               	bne lenchk
  7816  b0f1 a980               	lda #$80
  7817  b0f3 203db1             	jsr prmrpt
  7818  b0f6 a589               	lda parsts
  7819  b0f8 0980               	ora #$80		; set "@" flag
  7820  b0fa 8589               	sta parsts
  7821  b0fc ca                 	dex			; decrement length
  7822  b0fd e622               	inc index1		; increment past "@"
  7823  b0ff d002               	bne lenchk		; if no carry
  7824  b101 e623               	inc index1+1
  7825                          
  7826  b103 8a                 lenchk:	txa
  7827  b104 c911               	cmp #17
  7828  b106 b005               	bcs errlen		; if length < 17
  7829  b108 a622               	ldx index1
  7830  b10a a423               	ldy index1+1
  7831  b10c 60                 	rts
  7832                          
  7833  b10d a244               errlen:	ldx #errls
  7834  b10f 4c2685             	jmp error		; filename too long
  7835                          ; get nextvalue routine
  7836  b112 207eb3             getval:	jsr chrget		; get nxt chr
  7837  b115 f0c5               gtvl2:	beq sner		; if end of statement
  7838  b117 9009               	bcc gtvl5		; can be numeric
  7839  b119 20e796             	jsr chkopn		; or a "("
  7840  b11c 206cae             	jsr getbyt		; anything else is an error
  7841  b11f 4ce496             	jmp chkcls		; need closing ")"
  7842                          
  7843  b122 4c6cae             gtvl5:	jmp getbyt		; evaluate it
  7844                          
  7845                          ; get next 2byte expr routine
  7846                          ;   exit:  .a,.y (high,low) value
  7847  b125 207eb3             getoff:	jsr chrget		; get nxt chr
  7848  b128 f0b2               	beq sner		; if end of statement
  7849  b12a 900e               	bcc gtff5		; can be num. const
  7850  b12c 20e796             	jsr chkopn		; or a "("
  7851  b12f 207bae             	jsr getpin		; expr
  7852  b132 20e496             	jsr chkcls		; need closing ")"
  7853  b135 a41b               	ldy poker
  7854  b137 a51c               	lda poker+1
  7855  b139 60                 	rts
  7856                          
  7857  b13a 4c7bae             gtff5:	jmp getpin		; evaluate it
  7858                          	
  7859                          ; prmrpt  checks for a repeated parameter.
  7860                          ;   entry   a contains parsts flag to check.
  7861  b13d 2589               prmrpt:	and parsts		; and with parsts
  7862  b13f d09b               	bne sner		; if bit previously set
  7863  b141 60                 	rts
  7864                          
  7865                          ; prxrpt  checks for a repeated parameter.
  7866                          ;   entry   a contains parstx flag to check.
  7867  b142 258a               prxrpt:	and parstx		; and with parstx
  7868  b144 d096               	bne sner		; if bit previously set
  7869  b146 60                 	rts
  7870                          ; ******************************************* BUTES2 **********************************************
  7871                          ; cbm 2001 disk verb processors - author rsr 7-24-79
  7872                          ; tabfcb - table of fcb processing strings.
  7873                          
  7874                          tabfcb:
  7875                          tclr=*-tabfcb
  7876  b147 ff                 	!byte <fclrm1		; clear
  7877                          tcat=*-tabfcb
  7878  b148 01                 	!byte fcat-1		; catalog
  7879                          topn=*-tabfcb
  7880  b149 05                 	!byte fopn-1		; dopen dsave dload
  7881                          tapn=*-tabfcb
  7882  b14a 16                 	!byte fapn-1		; append
  7883                          thed=*-tabfcb
  7884  b14b 1b                 	!byte fhed-1		; header
  7885                          tcoll=*-tabfcb
  7886  b14c 21                 	!byte fcoll-1		; collect
  7887                          tbak=*-tabfcb
  7888  b14d 23                 	!byte fbak-1		; backup
  7889                          tcopy=*-tabfcb
  7890  b14e 27                 	!byte fcopy-1		; copy
  7891                          tconc=*-tabfcb
  7892  b14f 0d                 	!byte fconc-1		; concat
  7893                          tren=*-tabfcb
  7894  b150 2f                 	!byte fren-1		; rename
  7895                          tscr=*-tabfcb
  7896  b151 37                 	!byte fscr-1		; scratch
  7897                          trec=*-tabfcb
  7898  b152 3b                 	!byte frec-1		; record
  7899                          
  7900                          xsca =$c2		; send dossca
  7901                          xid =$d0		; sends disk id
  7902                          xd1 =$d1		; sends dosds1
  7903                          xd2 =$d2		; sends dosds2
  7904                          xrec =$e0		; sends s for seq or dosrcl
  7905                          xwrt =$e1		; sends w or l
  7906                          xrcl =$e2		; send low ((poker))
  7907                          xfat =$f0		; sends "@" if specified
  7908                          xfn1 =$f1		; sends filename1
  7909                          xfn2 =$f2		; sends filename2
  7910                          
  7911                          ; tabld - token table definitions
  7912                          
  7913                          tabld				; used to build disk command strings
  7914                          fclr =*-tabld
  7915                          fclrm1 =fclr-1
  7916  b153 49d1               	!byte 'i',xd1
  7917                          fcat =*-tabld
  7918  b155 24d13af1           	!byte '$',xd1,':',xfn1
  7919                          
  7920                          fopn =*-tabld
  7921  b159 f0d13af12ce12ce0   	!byte xfat,xd1,':',xfn1,',',xwrt,',',xrec
  7922                          
  7923                          fconc =*-tabld
  7924  b161 43d23af23dd23af2...	!byte 'c',xd2,':',xfn2,'=',xd2,':',xfn2,','
  7925                          fapn =*-tabld
  7926  b16a d13af12c41         	!byte xd1,':',xfn1,',','a'
  7927                          
  7928                          fhed =*-tabld
  7929  b16f 4ed13af12cd0       	!byte 'n',xd1,':',xfn1,',',xid
  7930                          
  7931                          fcoll =*-tabld
  7932  b175 56d1               	!byte 'v',xd1
  7933                          
  7934                          fbak =*-tabld
  7935  b177 44d23dd1           	!byte 'd',xd2,'=',xd1
  7936                          
  7937                          fcopy =*-tabld
  7938  b17b 43d23af23dd13af1   	!byte 'c',xd2,':',xfn2,'=',xd1,':',xfn1
  7939                          
  7940                          fren =*-tabld
  7941  b183 52d13af23dd13af1   	!byte 'r',xd1,':',xfn2,'=',xd1,':',xfn1
  7942                          
  7943                          fscr =*-tabld
  7944  b18b 53d13af1           	!byte 's',xd1,':',xfn1
  7945                          
  7946                          frec =*-tabld
  7947  b18f 50c2e2e0           	!byte 'p',xsca,xrcl,xrec
  7948                          ; -------------------------------------------------------------------------------------------------
  7949                          ; send parameters to device
  7950                          ;   entry  a number of bytes in format.
  7951                          ;   y --> tabld entry.
  7952                          
  7953  b193 2073b2             sav20:	jsr chk2
  7954  b196 a002               	ldy #topn		; table offset
  7955  b198 a904               sav21:	lda #4			; length
  7956                          
  7957  b19a 850f               sendp:	sta xcnt		; save number of string bytes
  7958  b19c b947b1             	lda tabfcb,y		; get pointer into tabld
  7959  b19f 48                 	pha
  7960  b1a0 2007b3             	jsr oldclr		; clear old status
  7961                          
  7962  b1a3 a200               	ldx #0
  7963                          
  7964  b1a5 68                 sdp1:	pla
  7965  b1a6 c60f               	dec xcnt
  7966  b1a8 3048               	bmi tranr
  7967  b1aa a8                 	tay
  7968  b1ab c8                 	iny			; move down table
  7969  b1ac 98                 	tya
  7970  b1ad 48                 	pha
  7971  b1ae b953b1             	lda tabld,y		; get next entry
  7972  b1b1 1037               	bpl sdp5		; if not escape code
  7973  b1b3 c9c2               	cmp #xsca		; if not secondary address
  7974  b1b5 f04a               	beq rsca
  7975  b1b7 c9d0               	cmp #xid
  7976  b1b9 f055               	beq rid			; if disk id
  7977  b1bb c9e2               	cmp #xrcl
  7978  b1bd f06f               	beq rdcn		; if record number
  7979  b1bf c9e1               	cmp #xwrt
  7980  b1c1 f059               	beq rwrt		; if w or l
  7981  b1c3 c9f0               	cmp #xfat
  7982  b1c5 f03f               	beq rfat		; if "@" symbol request
  7983  b1c7 c9f1               	cmp #xfn1
  7984  b1c9 f06d               	beq rsfn		; if filename 1
  7985  b1cb c9f2               	cmp #xfn2
  7986  b1cd f021               	beq gordfn		; if filename 2
  7987  b1cf c9e0               	cmp #xrec
  7988  b1d1 d005               	bne sdp2		; if not record type
  7989  b1d3 ad2202             	lda dosrcl		; get rec #
  7990  b1d6 d012               	bne sdp5		; always branch
  7991  b1d8 c9d1               sdp2:	cmp #xd1
  7992  b1da d005               	bne sdp3		; if not drive 1
  7993  b1dc ad1102             	lda dosds1
  7994  b1df 1007               	bpl sdp4		; always branch
  7995  b1e1 c9d2               sdp3:	cmp #xd2
  7996  b1e3 d0c0               	bne sdp1		; if not drive 2, continue
  7997  b1e5 ad1602             	lda dosds2
  7998  b1e8 0930               sdp4:	ora #'0' 		; change # to ascii
  7999                          
  8000  b1ea 9d2602             sdp5:	sta dosstr,x		; else into buffer
  8001  b1ed e8                 	inx
  8002  b1ee d0b5               	bne sdp1		; always
  8003                          
  8004  b1f0 f057               gordfn:	beq rdfn
  8005                          
  8006  b1f2 8a                 tranr:	txa			; length to a
  8007  b1f3 48                 	pha
  8008  b1f4 a226               	ldx #<dosstr		; set filename
  8009  b1f6 a002               	ldy #>dosstr
  8010  b1f8 8662               	stx highds		;  set up vector for filename
  8011  b1fa 8463               	sty highds+1
  8012  b1fc 2051b3             	jsr sav3
  8013  b1ff 68                 	pla
  8014  b200 60                 	rts
  8015                          
  8016  b201 ad2102             rsca:	lda dossa		; secondary address (record)
  8017  b204 d0e4               	bne sdp5		; always
  8018                          
  8019  b206 2489               rfat:	bit parsts
  8020  b208 3002               	bmi rfata
  8021  b20a 1099               	bpl sdp1		; if @ not encountered
  8022  b20c a940               rfata:	lda #'@'
  8023  b20e d0da               	bne sdp5		; always
  8024                          
  8025                          ; id subroutine
  8026  b210 ad2302             rid:	lda dosdid		; include id
  8027  b213 9d2602             	sta dosstr,x
  8028  b216 e8                 	inx
  8029  b217 ad2402             	lda dosdid+1
  8030  b21a d0ce               	bne sdp5		; always
  8031                          
  8032  b21c ad2202             rwrt:	lda dosrcl		; chk for l or w
  8033  b21f f004               	beq rwrt1		; zero then write
  8034  b221 a94c               	lda #'l'
  8035  b223 d0c5               	bne sdp5		; always
  8036                          
  8037  b225 a953               rwrt1:	lda #'s'		; send w,s
  8038  b227 8d2202             	sta dosrcl
  8039  b22a a957               	lda #'w'
  8040  b22c d0bc               	bne sdp5		; always
  8041                          
  8042                          ; move record number
  8043  b22e a51b               rdcn:	lda poker
  8044  b230 9d2602             	sta dosstr,x
  8045  b233 a51c               	lda poker+1
  8046  b235 e8                 	inx
  8047  b236 d0b2               	bne sdp5		; always
  8048                          
  8049                          ; move file names.
  8050  b238 ad1202             rsfn:	lda dosf1a
  8051  b23b 8522               	sta index1
  8052  b23d ad1302             	lda dosf1a+1
  8053  b240 8523               	sta index1+1
  8054  b242 ac1002             	ldy dosf1l
  8055  b245 f021               	beq rdrt0		; if null string
  8056  b247 d00f               	bne xrfn		; always
  8057                          
  8058  b249 ad1702             rdfn:	lda dosf2a
  8059  b24c 8522               	sta index1
  8060  b24e ad1802             	lda dosf2a+1
  8061  b251 8523               	sta index1+1
  8062  b253 ac1502             	ldy dosf2l
  8063  b256 f010               	beq rdrt0		; if null string
  8064                          
  8065  b258 840e               xrfn:	sty count
  8066  b25a a000               	ldy #0			; move name to dosstr
  8067  b25c b122               rdmov:	lda (index1),y
  8068  b25e 9d2602             	sta dosstr,x
  8069  b261 e8                 	inx
  8070  b262 c8                 	iny
  8071  b263 c40e               	cpy count
  8072  b265 d0f5               	bne rdmov		; if move not complete
  8073  b267 24                 	!byte $24		; hop
  8074  b268 ca                 rdrt0:	dex			; case cdd=sd
  8075                          
  8076  b269 4ca5b1             rdrt1:	jmp sdp1		; get next symbol
  8077                          ; -------------------------------------------------------------------------------------------------
  8078                          ; syntax checker
  8079                          ;   routines for dos.write
  8080                          
  8081  b26c 29e6               chk1:	and #$e6		; for header,dload,scrtch
  8082  b26e f003               	beq chk2		; chk opt parms
  8083  b270 4c0e97             chker1:	jmp snerr		; -> syntax error, ready
  8084                          
  8085  b273 a589               chk2:	lda parsts		; for dsave
  8086  b275 2901               	and #1
  8087  b277 c901               	cmp #1			; chk req'd parms
  8088  b279 d0f5               	bne chker1		; error if 1 missing
  8089  b27b a589               	lda parsts		; reload for return
  8090  b27d 60                 	rts
  8091                          
  8092  b27e 29e7               chk3:	and #$e7		; for colect
  8093  b280 d0ee               	bne chker1		; chk opt parms
  8094  b282 60                 	rts
  8095                          
  8096  b283 29c4               chk4:	and #$c4		; for copy,concat
  8097  b285 d0e9               	bne chker1		; chk opt parms
  8098  b287 a589               	lda parsts
  8099  b289 2903               chk5:	and #3			; for rename
  8100  b28b c903               	cmp #3			; chk req'd parms
  8101  b28d d0e1               	bne chker1
  8102  b28f a589               	lda parsts		; reload for return
  8103  b291 60                 	rts
  8104                          
  8105  b292 2905               chk6:	and #5			; for append,dopen
  8106  b294 c905               	cmp #5			; chk req'd parms
  8107  b296 d0d8               	bne chker1
  8108  b298 a589               	lda parsts		; reload for rts
  8109  b29a 60                 	rts
  8110                          ; -------------------------------------------------------------------------------------------------
  8111                          ; error on channel read
  8112                          
  8113  b29b a900               errchl:	lda #0			; no filename
  8114  b29d 20bdff             	jsr setnam
  8115  b2a0 a06f               	ldy #$6f		; .y=sa
  8116  b2a2 202793             	jsr ochanl		; open special channel
  8117  b2a5 a20e               	ldx #doslfn		; make it the input channel
  8118  b2a7 2036b5             	jsr chkin
  8119  b2aa a0ff               	ldy #$ff		; for offset
  8120                          
  8121  b2ac c8                 loop1:	iny
  8122  b2ad 202ab5             	jsr basin
  8123  b2b0 c90d               	cmp #cr			; check for end
  8124  b2b2 f006               	beq errend
  8125  b2b4 9117               	sta (dsdesc+1),y
  8126  b2b6 c027               	cpy #39
  8127  b2b8 d0f2               	bne loop1
  8128  b2ba a900               errend lda #00
  8129  b2bc 9117               	sta (dsdesc+1),y
  8130  b2be a928               	lda #40			; get 40 char str
  8131  b2c0 8516               	sta dsdesc		; we have 40 chrs
  8132  b2c2 20ccff             	jsr clrch
  8133  b2c5 a90e               	lda #doslfn		; close channel and restore default chnls
  8134  b2c7 18                 	clc
  8135  b2c8 204fb5             	jsr tclose
  8136  b2cb 4c1c93             	jmp dcat0		; restore default channel ...
  8137                          
  8138                          ; r-u-sure subroutine
  8139  b2ce 209e9c             rusure:	jsr tstdir		; chk for direct
  8140  b2d1 d032               	bne ansyes		; z clr=not direct
  8141  b2d3 a214               	ldx #msg30
  8142  b2d5 20d5a2             	jsr msg			; prompt user
  8143  b2d8 20ccff             	jsr clrch		; clear channel for basin
  8144  b2db 202ab5             	jsr basin		; next char
  8145  b2de c959               	cmp #'y'
  8146  b2e0 d019               	bne ansno		; if 1st <> 'y'
  8147  b2e2 202ab5             	jsr basin		; next chr
  8148  b2e5 c90d               	cmp #cr
  8149  b2e7 f01c               	beq ansyes		; if short form of yes (y,cr)
  8150  b2e9 c945               	cmp #'e'
  8151  b2eb d00e               	bne ansno		; if not 'e'
  8152  b2ed 202ab5             	jsr basin
  8153  b2f0 c953               	cmp #'s'
  8154  b2f2 d007               	bne ansno		; if not 's'
  8155  b2f4 202ab5             	jsr basin
  8156  b2f7 c90d               	cmp #cr
  8157  b2f9 f00a               	beq ansyes		; if 'yes',cr
  8158                          
  8159                          ; if not yes, input until cr received
  8160  b2fb c90d               ansno:	cmp #cr
  8161  b2fd 38                 	sec			; carry set =no&direct
  8162  b2fe f006               	beq ansbye		; if cr received, exit
  8163  b300 202ab5             	jsr basin
  8164  b303 d0f6               	bne ansno		; continue to ignore
  8165                          
  8166                          ; here if answer 'yes'
  8167  b305 18                 ansyes:	clc			; carry clr =not direct
  8168  b306 60                 ansbye:	rts
  8169                          
  8170                          ; oldclr subroutine
  8171                          ;   clears ds$: set string length to zero.
  8172                          ;   clears st
  8173  b307 a900               oldclr:	lda #0
  8174  b309 8516               	sta dsdesc		; kill ds$
  8175  b30b 18                 	clc
  8176  b30c 4c1ab5             	jmp storst		; kill st
  8177                          
  8178  b30f 209291             sav77:	jsr sav13
  8179  b312 8d1002             	sta dosf1l
  8180  b315 a522               	lda index1		; save address of string
  8181  b317 a423               	ldy index1+1
  8182  b319 8d1202             	sta dosf1a
  8183  b31c 8c1302             	sty dosf1a+1
  8184  b31f 60                 	rts
  8185                          ; -------------------------------------------------------------------------------------------------
  8186                          ; parser for load,save and verify verbs
  8187                          ;   (file name option)
  8188                          ;   (opt device #) dflt=DEFDEV
  8189                          ;   (eot cmd) dflt=0=no
  8190                          
  8191  b320 a200               plsv:	ldx #0
  8192  b322 8e1002             	stx dosf1l		; set file name length to zero
  8193  b325 8e2102             	stx dossa		; set secondary address to zero
  8194  b328 8e1f02             	stx dosla		; clear logical address
  8195  b32b a6b7               	ldx ddisk		; default device
  8196  b32d 8e2002             	stx dosfa		; set physical address to 8 (disk)
  8197                          
  8198  b330 2081b3             	jsr chrgot
  8199  b333 f00f               	beq plsvx		; if no paramters
  8200  b335 200fb3             	jsr sav77
  8201                          
  8202  b338 2062b3             	jsr plsv27
  8203  b33b 8e2002             	stx dosfa		; save device channel
  8204                          
  8205  b33e 2062b3             	jsr plsv27
  8206  b341 8e2102             	stx dossa		; set secondary address
  8207                          
  8208  b344 ad1202             plsvx:	lda dosf1a
  8209  b347 ae1302             	ldx dosf1a+1
  8210  b34a 8562               	sta highds		; set up vector to filename
  8211  b34c 8663               	stx highds+1
  8212  b34e ad1002             	lda dosf1l		; .a=filename length
  8213  b351 a262               sav3:	ldx #<highds		; page 0 addr of vector
  8214  b353 20bdff             	jsr setnam
  8215  b356 ad1f02             	lda dosla		; set logical file info
  8216  b359 ae2002             	ldx dosfa
  8217  b35c ac2102             	ldy dossa
  8218  b35f 4cbaff             	jmp setlfs
  8219                          
  8220  b362 2081b3             plsv27:	jsr chrgot
  8221  b365 f0dd               	beq plsvx
  8222  b367 4c5d92             	jmp copg
  8223                          
  8224  b36a 20ea96             plsv30:	jsr chkcom
  8225  b36d 2081b3             plsv32:	jsr chrgot
  8226  b370 d003               	bne plsrts		; if not end of statement
  8227  b372 4c0e97             	jmp snerr		; -> syntax error, ready
  8228                          
  8229  b375 60                 plsrts:	rts
  8230                          
  8231  b376 208c9a             flpint:	jsr ayint
  8232  b379 a572               	lda facmo
  8233  b37b a473               	ldy faclo
  8234  b37d 60                 	rts
  8235                          ; -------------------------------------------------------------------------------------------------
  8236                          ; 'chrget routine'
  8237                          ;   chrget is called to get the next character from the text buffer pointed to by txtptr which is
  8238                          ;   incremented before the access is made.
  8239                          ;
  8240                          ;   chrgot is called to get the current character from the buffer pointed to by txtptr.
  8241                          
  8242                          ;   qnum is called to test for a ascii numeric character.
  8243                          ;   entry:  txtptr points to the buffer.
  8244                          ;   exit:  .a = character from buffer.
  8245                          ;          .y = 0
  8246                          ;   txtptr is updated (chrget).
  8247                          ;   c bit = 0, character in .a is numeric.
  8248                          ;         = 1, character in .a is non-numeric.
  8249                          ;   z bit = 0, the not end of statement.
  8250                          ;         = 1, end of statement "" or end of line.
  8251                          
  8252                          ; chrget
  8253  b37e 6c9002             chrget:	jmp (ichrge)
  8254                          
  8255                          ; chrgot
  8256  b381 6c8e02             chrgot:	jmp (ichrgo)
  8257                          
  8258  b384 e683               nchrge:	inc txtptr		; increment text pointer
  8259  b386 d002               	bne nchrgo		; if no carry into msb
  8260  b388 e684               	inc txtptr+1
  8261                          
  8262  b38a a000               nchrgo:	ldy #0
  8263  b38c b183               	lda (txtptr),y
  8264  b38e c920               	cmp #$20		; span blanks
  8265  b390 f0ec               	beq chrget		; if blank character
  8266                          
  8267                          ; if the character in .a is numeric then the following code clears the carry bit.
  8268  b392 c93a               qnum:	cmp #':'
  8269  b394 b005               	bcs qnrts
  8270  b396 e92f               	sbc #$2f		; '0'-1
  8271  b398 38                 	sec
  8272  b399 e9d0               	sbc #$d0		; $100-'0'
  8273  b39b 60                 qnrts:	rts
  8274                          ; ******************************************** INIT ***********************************************
  8275                          ; 'init'
  8276                          ; initop - set variabales based upon top of memory.
  8277                          ;
  8278                          ;   for the 64k conversion, several variables have been allocated at the top of user memory and the
  8279                          ;   top of the string area is set below them. these areas are:
  8280                          ;   input buffer
  8281                          ;   ds$ string space
  8282                          ;   temporary descriptor stack
  8283                          ;   random seed
  8284                          ;   "zero" value
  8285                          ;   for all other versions, the input buffer is allocated at the top of the text bank and the other
  8286                          ;   items are put at the top of the string bank.
  8287                          ;   note, the highest usable location is assumed to be identical in the two segments; after
  8288                          ;   allocation here, the highest usable location in text is pointed to by buffpt and memtop in the
  8289                          ;   string bank.
  8290                          
  8291  b39c 2052b5             initop:	jsr clall		; restore default i/o channels
  8292  b39f 38                 	sec
  8293  b3a0 2099ff             	jsr topmem		; get top of ram
  8294  b3a3 8ea602             	stx highst		; save highest offset
  8295  b3a6 8ca702             	sty highst+1
  8296                          
  8297  b3a9 38                 	sec
  8298  b3aa 8a                 	txa
  8299  b3ab e9a1               	sbc #<bufsiz
  8300  b3ad 8586               	sta buffpt
  8301  b3af aa                 	tax
  8302  b3b0 98                 	tya
  8303  b3b1 e900               	sbc #>bufsiz
  8304  b3b3 8587               	sta buffpt+1
  8305  b3b5 a8                 	tay
  8306  b3b6 38                 	sec
  8307  b3b7 8a                 	txa
  8308  b3b8 e92b               	sbc #40+ptrsiz		; 40 char ds$ string
  8309  b3ba 8517               	sta dsdesc+1
  8310  b3bc aa                 	tax
  8311  b3bd b001               	bcs itp04
  8312  b3bf 88                 	dey
  8313  b3c0 8418               itp04:	sty dsdesc+2
  8314                          
  8315  b3c2 38                 	sec			; 3 temp descriptors
  8316  b3c3 8a                 	txa
  8317  b3c4 e90c               	sbc #strsiz+strsiz+strsiz
  8318  b3c6 8520               	sta tempst
  8319  b3c8 aa                 	tax
  8320  b3c9 b001               	bcs itp03
  8321  b3cb 88                 	dey
  8322  b3cc 8421               itp03:	sty tempst+1
  8323                          
  8324  b3ce 38                 	sec
  8325  b3cf 8a                 	txa
  8326  b3d0 e907               	sbc #7			;  5 seed, 1 comma, 1 unused byte
  8327  b3d2 858b               	sta seedpt
  8328  b3d4 aa                 	tax
  8329  b3d5 b001               	bcs itp02
  8330  b3d7 88                 	dey
  8331  b3d8 848c               itp02:	sty seedpt+1
  8332                          
  8333  b3da 38                 	sec
  8334  b3db 8a                 	txa
  8335  b3dc e904               	sbc #strsiz		; "zero" descriptor
  8336  b3de aa                 	tax
  8337  b3df b001               	bcs itp06
  8338  b3e1 88                 	dey
  8339                          
  8340  b3e2 863d               itp06:	stx memtop		; top of str bank
  8341  b3e4 843e               	sty memtop+1
  8342                          
  8343                          ; set some banks
  8344  b3e6 853f               	sta memtop+2
  8345  b3e8 8519               	sta dsdesc+3
  8346                          
  8347  b3ea a006               	ldy #6
  8348  b3ec b912b4             itp01:	lda rseed-1,y		; move seed to ram
  8349  b3ef 918b               	sta (seedpt),y
  8350  b3f1 88                 	dey
  8351  b3f2 d0f8               	bne itp01		; if move not complete
  8352                          
  8353  b3f4 98                 	tya			; zero out "zero", .a<-0
  8354  b3f5 a204               	ldx #strsiz
  8355  b3f7 913d               itp05:	sta (memtop),y
  8356  b3f9 c8                 	iny
  8357  b3fa ca                 	dex
  8358  b3fb d0fa               	bne itp05
  8359                          
  8360  b3fd a928               	lda #40 		; do ds$ link bytes
  8361  b3ff a8                 	tay
  8362  b400 9117               	sta (dsdesc+1),y	; length
  8363  b402 c8                 	iny
  8364  b403 a9ff               	lda #$ff		; garbage bytes
  8365  b405 9117               	sta (dsdesc+1),y
  8366  b407 c8                 	iny
  8367  b408 9117               	sta (dsdesc+1),y
  8368                          
  8369  b40a a53d               settop:	lda memtop		; reset top of strings
  8370  b40c a43e               	ldy memtop+1
  8371  b40e 8539               	sta fretop
  8372  b410 843a               	sty fretop+1
  8373  b412 60                 	rts
  8374                          
  8375  b413 804fc752582c       rseed:	!byte $80,$4f,$c7,$52,$58,','
  8376                          ; -------------------------------------------------------------------------------------------------
  8377                          ; init - this initializes the basic interpreter and should
  8378                          ;   be located where it will be wiped out in ram if code is all in ram.
  8379                          
  8380  b419 20fbb4             init:	jsr initv		; init vectors
  8381                          ; always init0 after vector initialization
  8382  b41c a202               init0:	ldx #2			; init usr
  8383  b41e bd94ae             init05:	lda bjmps,x
  8384  b421 9502               	sta usrpok,x
  8385  b423 ca                 	dex
  8386  b424 10f8               	bpl init05
  8387  b426 855f               	sta jmper		; always a jmp op
  8388                          
  8389                          ; move small routines to page 0
  8390  b428 a204               	ldx #initl		; length of routine
  8391  b42a bd06b5             init10:	lda initat-1,x
  8392  b42d 9d5902             	sta ldaabs-1,x		; move to ram
  8393  b430 ca                 	dex
  8394  b431 d0f7               	bne init10		; if move not complete
  8395                          
  8396  b433 8676               	stx bits		; clear cells
  8397  b435 861a               	stx channl
  8398  b437 8616               	stx dsdesc
  8399  b439 8e5802             	stx dolu
  8400  b43c 861d               	stx temppt
  8401  b43e ca                 	dex
  8402  b43f 861e               	stx lastpt
  8403  b441 861f               	stx lastpt+1
  8404                          
  8405                          ; set pointers to bottom of dynamic areas. (only for areas which start in a new bank.
  8406                          ; bottom and top limits will be the same in each bank.)
  8407  b443 38                 	sec			; get bottom of memory
  8408  b444 209cff             	jsr membot
  8409  b447 862d               	stx txttab		; save for text entry
  8410  b449 842e               	sty txttab+1
  8411  b44b 209cb3             	jsr initop
  8412                          
  8413                          ; set text pointer and output signon message
  8414  b44e a000               	ldy #0
  8415  b450 98                 	tya
  8416  b451 912d               	sta (txttab),y
  8417  b453 e62d               	inc txttab
  8418  b455 d002               	bne init20
  8419  b457 e62e               	inc txttab+1
  8420                          
  8421  b459 a9ff               init20:	lda #TITLECOL
  8422  b45b 85cf               	sta color
  8423  b45d a226               	ldx #asigon
  8424  b45f 20d5a2             	jsr msg			; output cbm sign-on
  8425                          
  8426  b462 a943               	lda #BYTESCOL
  8427  b464 85cf               	sta color
  8428                          
  8429  b466 a53d               	lda memtop		; calc free memory
  8430  b468 38                 	sec
  8431  b469 e52d               	sbc txttab
  8432  b46b aa                 	tax
  8433  b46c a53e               	lda memtop+1
  8434  b46e e52e               	sbc txttab+1
  8435  b470 20c6a2             	jsr linprt		; print
  8436                          
  8437  b473 a93e               	lda #TITLE2COL
  8438  b475 85cf               	sta color
  8439                          
  8440  b477 a228               	ldx #awords
  8441  b479 20d5a2             	jsr msg			; output bytes free, (c)
  8442                          
  8443  b47c a9e7               	lda #TEXTCOL
  8444  b47e 85cf               	sta color
  8445                          	
  8446  b480 2064b5             	jsr logo		; print logo
  8447                          
  8448  b483 20188a             	jsr scrtch		; set variables
  8449  b486 a20b               	ldx #<warm 		; fix for bob russell
  8450  b488 a0b5               	ldy #>warm
  8451  b48a 206fff             	jsr vreset
  8452  b48d a908               	lda #8			; set disk default to 8
  8453  b48f 85b7               	sta ddisk
  8454  b491 58                 	cli
  8455  b492 4c8e85             	jmp ready		; indicate ready, and start
  8456                          ; -------------------------------------------------------------------------------------------------
  8457                          ; signon
  8458                          
  8459  b495 932a2a2a204c4332...signon:	!scr clrscr,"*** LC256  COMMODORE BASIC V4.0 PLUS ***",cr,cr,0
  8460  b4c1 2042415349432042...words:	!scr " BASIC BYTES FREE (C)  2024 VOSSI",cr,cr,0
  8461                          
  8462  b4e5 29859b859488d289...bvtrs:	!word nerror,nmain,ncrnch,nqplop,ngone
  8463  b4ef 6a967d958ab384b3...	!word neval,nfrmev,nchrgo,nchrge,flpint,givayf
  8464                          
  8465  b4fb a215               initv:	ldx #initv-bvtrs-1		; init vectors
  8466                          
  8467  b4fd bde5b4             initv5:	lda bvtrs,x
  8468  b500 9d8002             	sta ierror,x
  8469  b503 ca                 	dex
  8470  b504 10f7               	bpl initv5
  8471  b506 60                 	rts
  8472                          ; -------------------------------------------------------------------------------------------------
  8473                          ; initat
  8474                          ;   this code is moved to page 0 ram during initialization.
  8475                          ;   this code gets altered (ldaadr, staadr) throughout execution. it is very fast this way.
  8476                          
  8477                          initat:
  8478  b507 adffff             	lda memend
  8479  b50a 60                 	rts
  8480                          initl =*-initat		; length of move
  8481                          ; -------------------------------------------------------------------------------------------------
  8482                          ; warm entry point
  8483                          ;   do some i/o initialization
  8484                          
  8485  b50b 78                 warm:	sei			; disable interrupts
  8486  b50c 207bff             	jsr ioinit
  8487  b50f 2052b5             	jsr clall
  8488  b512 207eff             	jsr cint		; screen init
  8489  b515 58                 	cli			; enable ints
  8490  b516 4c8e85             	jmp ready
  8491                          ; ******************************************* SYSCAL **********************************************
  8492                          ; 'interface system calls.'
  8493                          
  8494  b519 38                 readst:	sec
  8495                          
  8496  b51a 4cb7ff             storst:	jmp krdst		; return i/o status byte
  8497                          
  8498  b51d 18                 open:	clc
  8499  b51e 20c0ff             opn10:	jsr kopen		; open logical file
  8500  b521 b033               	bcs ioerr
  8501  b523 60                 	rts
  8502                          
  8503  b524 20e4ff             getin:	jsr kgetin		; get a byte
  8504  b527 b02d               	bcs ioerr
  8505  b529 60                 	rts
  8506                          
  8507  b52a 20cfff             basin:	jsr kbasin		; get a byte
  8508  b52d b027               	bcs ioerr
  8509  b52f 60                 	rts
  8510                          
  8511  b530 20d2ff             bsout:	jsr kbsout		; send a byte
  8512  b533 b021               	bcs ioerr
  8513  b535 60                 	rts
  8514                          
  8515  b536 20c6ff             chkin:	jsr kchkin		; open channel in
  8516  b539 b01b               	bcs ioerr
  8517  b53b 60                 	rts
  8518                          
  8519  b53c 20c9ff             chkout:	jsr kchout		; open   -     out
  8520  b53f b015               	bcs ioerr
  8521  b541 60                 	rts
  8522                          
  8523  b542 20d5ff             load:	jsr kload		; load from file
  8524  b545 b00f               	bcs ioerr
  8525  b547 60                 	rts
  8526                          
  8527  b548 20d8ff             save:	jsr ksave		; save to    -
  8528  b54b b009               	bcs ioerr
  8529  b54d 60                 logox:	rts
  8530                          
  8531  b54e 38                 close:	sec
  8532  b54f 4cc3ff             tclose:	jmp kclose
  8533                          
  8534  b552 18                 clall:	clc			; c-clr => close 'em all
  8535  b553 4ce7ff             	jmp kclall		; close all files
  8536                          
  8537                          ; ioerr - .a = error number
  8538                          ;   cy = 1
  8539                          ;   print error message and go to ready.
  8540  b556 18                 ioerr:	clc
  8541  b557 2a                 	rol
  8542  b558 48                 	pha
  8543  b559 a90e               	lda #doslfn		; close cmd channel in case
  8544  b55b 18                 	clc
  8545  b55c 204fb5             	jsr tclose
  8546  b55f 68                 	pla
  8547  b560 aa                 	tax
  8548  b561 4c2685             	jmp error
  8549                          endprg:
  8550                          ; -------------------------------------------------------------------------------------------------
  8551                          ; print logo
  8552  b564 24ea               logo:	bit mode
  8553  b566 10e5               	bpl logox			; logo only in mode 7 / 256 colors
  8554                          	
  8555  b568 a918               	lda #24
  8556  b56a 85f8               	sta x0				; store x
  8557  b56c a900               	lda #0
  8558  b56e 85f2               	sta y0				; store y
  8559  b570 85f0               	sta temp1			; old bank
  8560  b572 a900               	lda #<(logodata)
  8561  b574 85c1               	sta source_pointer		; store source address
  8562  b576 a9c0               	lda #>(logodata)
  8563  b578 85c2               	sta source_pointer+1
  8564  b57a 4c10b8             	jmp imglogo
  8565                          ; -------------------------------------------------------------------------------------------------
  8566                          ; select default disk unit
  8567                          dunit:
  8568  b57d 2014bf             	jsr Getbyte			; get byte parameter
  8569  b580 c908               	cmp #8				; range 8-31
  8570  b582 907c               	bcc Verror1			; too small
  8571  b584 c920               	cmp #32
  8572  b586 b078               	bcs Verror1			; too large
  8573  b588 85b7               	sta ddisk			; store new default unit
  8574  b58a 60                 	rts
  8575                          ; ****************************************** ZONE VDP *********************************************
  8576                          !zone vdp
  8577                          ; enable/disable screen, set backdrop color
  8578                          ;   parameter 1: 1/0= on/off +2= PAL +4= mode 7, +8 YJK (only mode 7), parameter 2: backdrop color
  8579                          VDPMode:
  8580  b58b 2014bf             	jsr Getbyte			; get byte parameter
  8581  b58e c910               	cmp #15+1
  8582  b590 b06e               	bcs Verror1			; >15 -> error
  8583  b592 85f0               	sta temp1			; remember
  8584  b594 290c               	and #$0c			; isolate yjk and mode bits
  8585  b596 c908               	cmp #$08
  8586  b598 f066               	beq Verror1			; yjk in mode 6 not allowed -> error
  8587                          
  8588  b59a 20ea96             	jsr chkcom			; check comma
  8589  b59d 2014bf             	jsr Getbyte			; get byte
  8590  b5a0 aa                 	tax				; remember color
  8591  b5a1 a5f0               	lda temp1			; get new mode
  8592  b5a3 2904               	and #$04			; isolate graphics 6/7 bit
  8593  b5a5 d004               	bne vmcolor			; -> skip mode7
  8594  b5a7 e010               	cpx #COLORS6
  8595  b5a9 b055               	bcs Verror1			; >colors -> error
  8596  b5ab 8a                 vmcolor:txa				; get color
  8597  b5ac a4f0               	ldy temp1			; get mode
  8598  b5ae 4c72ff             	jmp vmode
  8599                          ; -------------------------------------------------------------------------------------------------
  8600                          ; select draw/text color
  8601                          VDPColor:
  8602  b5b1 2014bf             	jsr Getbyte			; get byte parameter
  8603  b5b4 24ea               	bit mode
  8604  b5b6 3004               	bmi +				; -> skip mode7
  8605  b5b8 c910               	cmp #COLORS6
  8606  b5ba b044               	bcs Verror1			; >colors -> error
  8607  b5bc 85cf               +	sta color			; store new color
  8608  b5be 60                 	rts
  8609                          ; -------------------------------------------------------------------------------------------------
  8610                          ; clear screen with backgroundcolor
  8611                          VDPClear:
  8612  b5bf 2014bf             	jsr Getbyte			; get byte parameter
  8613                          
  8614  b5c2 24ea               	bit mode
  8615  b5c4 3014               	bmi +				; -> skip mode7
  8616                          ; mode6
  8617  b5c6 c910               	cmp #COLORS6
  8618  b5c8 b036               	bcs Verror1			; >colors -> error
  8619  b5ca 85ee               	sta bgcolor			; remember 4bit color
  8620  b5cc 0a                 	asl				; shift to high nibble for left pixel
  8621  b5cd 0a                 	asl
  8622  b5ce 0a                 	asl
  8623  b5cf 0a                 	asl
  8624  b5d0 85ef               	sta bgcolor_left		; store left color for print subs
  8625  b5d2 05ee               	ora bgcolor			; add color for right pixel
  8626  b5d4 8d8b03             	sta bgcolor_del
  8627  b5d7 4c78ff             	jmp vclear
  8628  b5da 85ee               +	sta bgcolor			; store new background color
  8629  b5dc 8d8b03             	sta bgcolor_del
  8630  b5df 4c78ff             	jmp vclear
  8631                          ; -------------------------------------------------------------------------------------------------
  8632                          ; set dot x, y (preserves x, y)
  8633                          VDPDot:
  8634  b5e2 202bbf             	jsr Getint			; get 16bit parameter
  8635  b5e5 a572               	lda inth
  8636  b5e7 c5f7               	cmp sizex+1
  8637  b5e9 b015               	bcs Verror1			; hi too large -> error
  8638  b5eb 85f9               	sta x0+1
  8639  b5ed a573               	lda intl
  8640  b5ef 85f8               	sta x0				; store x
  8641                          ; y
  8642  b5f1 20ea96             	jsr chkcom			; check comma
  8643  b5f4 2014bf             	jsr Getbyte			; get next byte
  8644  b5f7 c9d4               	cmp #SIZEY			; > ymax ?
  8645  b5f9 b005               	bcs Verror1			; ..too large
  8646  b5fb 85f2               	sta y0				; store y
  8647                          
  8648  b5fd 4cb7bd             	jmp SetPixel			; calc pixel address in VRAM
  8649                          ; -------------------------------------------------------------------------------------------------
  8650                          ; illegal quantity error
  8651  b600 4c189b             Verror1:jmp fcerr			; -> illegal quantity error
  8652                          ; -------------------------------------------------------------------------------------------------
  8653                          ; set graphics cursor x, y
  8654                          VDPSet:
  8655  b603 202bbf             	jsr Getint			; get 16bit parameter
  8656  b606 a572               	lda inth
  8657  b608 c5f7               	cmp sizex+1
  8658  b60a b0f4               	bcs Verror1			; hi too large -> error
  8659  b60c 85f9               	sta x0+1
  8660  b60e a573               	lda intl
  8661  b610 85f8               	sta x0				; store x
  8662                          ; y
  8663  b612 20ea96             	jsr chkcom			; check comma
  8664  b615 2014bf             	jsr Getbyte			; get next byte
  8665  b618 c9d4               	cmp #SIZEY			; > ymax ?
  8666  b61a b0e4               	bcs Verror1			; ..too large
  8667  b61c 85f2               	sta y0				; store y
  8668  b61e 60                 	rts
  8669                          ; -------------------------------------------------------------------------------------------------
  8670                          ; line x, y to x1, y1 (x, y is set to target)
  8671                          VDPLine:
  8672  b61f 202bbf             	jsr Getint			; get 16bit integer
  8673  b622 a572               	lda inth
  8674  b624 c5f7               	cmp sizex+1
  8675  b626 b0d8               	bcs Verror1			; hi too large -> error
  8676  b628 85f9               	sta x0+1
  8677  b62a a573               	lda intl
  8678  b62c 85f8               	sta x0				; store x
  8679                          ; y
  8680  b62e 20ea96             	jsr chkcom			; check comma
  8681  b631 2014bf             	jsr Getbyte			; get next byte
  8682  b634 c9d4               	cmp #SIZEY			; > ymax ?
  8683  b636 b0c8               	bcs Verror1			; ..too large
  8684  b638 85f2               	sta y0				; store y
  8685                          ; x1
  8686  b63a 20ea96             	jsr chkcom
  8687                          ; draw line to x1, y1 (x, y is set to target)
  8688                          VDPDraw:
  8689  b63d 202bbf             	jsr Getint			; get 16bit integer
  8690  b640 a572               	lda inth
  8691  b642 c5f7               	cmp sizex+1
  8692  b644 b0ba               	bcs Verror1			; hi too large -> error
  8693  b646 85fb               	sta x1+1
  8694  b648 a573               	lda intl
  8695  b64a 85fa               	sta x1				; store x1
  8696                          ; y1
  8697  b64c 20ea96             	jsr chkcom
  8698  b64f 2014bf             	jsr Getbyte			; get next byte
  8699  b652 c9d4               	cmp #SIZEY			; > ymax ?
  8700  b654 b0aa               	bcs Verror1			; ..too large
  8701  b656 85f3               	sta y1				; store y1
  8702                          
  8703  b658 4c36be             vdraw:	jmp DrawLine			; draw line sub
  8704                          ; -------------------------------------------------------------------------------------------------
  8705                          ; frame x, y (lower left) to x1, y1 (upper right)
  8706                          VDPFrame:
  8707  b65b 202bbf             	jsr Getint			; get 16bit parameter
  8708  b65e a572               	lda inth
  8709  b660 c5f7               	cmp sizex+1
  8710  b662 b09c               	bcs Verror1			; hi too large -> error
  8711  b664 85f9               	sta x0+1			; store x
  8712  b666 85f1               	sta temp2			; remember x0
  8713  b668 a573               	lda intl
  8714  b66a 85f8               	sta x0
  8715  b66c 85f0               	sta temp1
  8716                          ; y
  8717  b66e 20ea96             	jsr chkcom			; check comma
  8718  b671 2014bf             	jsr Getbyte			; get next byte
  8719  b674 c9d4               	cmp #SIZEY			; > ymax ?
  8720  b676 b073               	bcs Verror2			; ..too large
  8721  b678 85f2               	sta y0				; store y
  8722                          ; x1
  8723  b67a 20ea96             	jsr chkcom
  8724  b67d 202bbf             	jsr Getint			; get 16bit parameter
  8725  b680 a572               	lda inth
  8726  b682 c5f7               	cmp sizex+1
  8727  b684 b065               	bcs Verror2			; hi too large -> error
  8728  b686 85fb               	sta x1+1			; store x1
  8729  b688 8d9003             	sta wtemp+1			; remember x1
  8730  b68b a573               	lda intl
  8731  b68d 85fa               	sta x1
  8732  b68f 8d8f03             	sta wtemp
  8733                          ; y1
  8734  b692 20ea96             	jsr chkcom
  8735  b695 2014bf             	jsr Getbyte			; get next byte
  8736  b698 c9d4               	cmp #SIZEY			; > ymax ?
  8737  b69a b04f               	bcs Verror2			; ..too large
  8738  b69c 85f3               	sta y1				; store y1
  8739  b69e 85f4               	sta temp3			; remember y1
  8740                          ; check x < x1
  8741  b6a0 a5fb               	lda x1+1
  8742  b6a2 c5f9               	cmp x0+1
  8743  b6a4 9045               	bcc Verror2			; x1 hi < x0 hi -> error
  8744  b6a6 d006               	bne vfchky			; x1 hi > x0 hi -> ok
  8745                          ; hi equal - compare lo
  8746  b6a8 a5fa               	lda x1
  8747  b6aa c5f8               	cmp x0
  8748  b6ac 903d               	bcc Verror2			; x1 > x -> error
  8749                          ; check y1 < y
  8750  b6ae a5f2               vfchky:	lda y0
  8751  b6b0 48                 	pha				; remember y0
  8752  b6b1 c5f3               	cmp y1
  8753  b6b3 9036               	bcc Verror2			; y > y1 -> error
  8754                          ; draw
  8755  b6b5 a5f2               	lda y0
  8756  b6b7 85f3               	sta y1
  8757  b6b9 2036be             	jsr DrawLine			; draw ine sub
  8758  b6bc ad8f03             	lda wtemp			; get original x1
  8759  b6bf 85fa               	sta x1
  8760  b6c1 ad9003             	lda wtemp+1
  8761  b6c4 85fb               	sta x1+1
  8762  b6c6 a5f4               	lda temp3			; get original y1
  8763  b6c8 85f3               	sta y1
  8764  b6ca 2036be             	jsr DrawLine			; draw line sub
  8765  b6cd a5f0               	lda temp1			; get original x0
  8766  b6cf 85fa               	sta x1
  8767  b6d1 a5f1               	lda temp2
  8768  b6d3 85fb               	sta x1+1
  8769  b6d5 a5f4               	lda temp3			; get original y1
  8770  b6d7 85f3               	sta y1
  8771  b6d9 2036be             	jsr DrawLine			; draw line sub
  8772  b6dc a5f0               	lda temp1			; get original x0
  8773  b6de 85fa               	sta x1
  8774  b6e0 a5f1               	lda temp2
  8775  b6e2 85fb               	sta x1+1
  8776  b6e4 68                 	pla				; get original y0
  8777  b6e5 85f3               	sta y1
  8778  b6e7 2036be             	jsr DrawLine			; draw line sub
  8779  b6ea 60                 	rts
  8780                          ; -------------------------------------------------------------------------------------------------
  8781                          ; illegal quantity error
  8782  b6eb 4c189b             Verror2:jmp fcerr			; -> illegal quantity error
  8783                          ; -------------------------------------------------------------------------------------------------
  8784                          ; block x, y (lower left) size dx, dy (dx, dy > 0) (mode 6 only even x size used!)
  8785                          VDPBlock:
  8786  b6ee 202bbf             	jsr Getint			; get 16bit parameter
  8787  b6f1 a572               	lda inth
  8788  b6f3 c5f7               	cmp sizex+1
  8789  b6f5 b0f4               	bcs Verror2			; hi too large -> error
  8790  b6f7 85f9               	sta x0+1
  8791  b6f9 a573               	lda intl
  8792  b6fb 85f8               	sta x0				; store x
  8793                          ; y
  8794  b6fd 20ea96             	jsr chkcom			; check comma
  8795  b700 2014bf             	jsr Getbyte			; get next byte
  8796  b703 c9d4               	cmp #SIZEY			; > ymax ?
  8797  b705 b0e4               	bcs Verror2			; ..too large
  8798  b707 85f2               	sta y0				; store y
  8799                          ; dx
  8800  b709 20ea96             	jsr chkcom
  8801  b70c 202bbf              	jsr Getint			; get 16bit parameter
  8802  b70f a572               	lda inth
  8803  b711 18                 	clc
  8804  b712 6573               	adc intl
  8805  b714 f0d5               	beq Verror2			; 0 not allowed -> error
  8806  b716 a572               	lda inth
  8807                          
  8808  b718 85fd               	sta dx+1
  8809  b71a c5f7               	cmp sizex+1
  8810  b71c 900a               	bcc vbdxok			; hi < sizex hi-> ok
  8811  b71e d0cb               	bne Verror2			; hi..too large -> error
  8812  b720 a573               	lda intl
  8813  b722 c5f6               	cmp sizex			; check lo
  8814  b724 9002               	bcc vbdxok			; lo < -> ok
  8815  b726 d0c3               	bne Verror2			; lo..too large -> error
  8816  b728 a573               vbdxok:	lda intl
  8817  b72a 85fc               	sta dx
  8818                          ; dy
  8819  b72c 20ea96             	jsr chkcom
  8820  b72f 2014bf             	jsr Getbyte			; get next byte
  8821  b732 f0b7               	beq Verror2			; 0 not allowed -> error
  8822  b734 c9d5               	cmp #SIZEY+1
  8823  b736 b0b3               	bcs Verror2			; ..too large
  8824  b738 85f5               	sta dy
  8825                          ; check dx
  8826  b73a a5fc               	lda dx
  8827  b73c 38                 	sec
  8828  b73d e901               	sbc #1				; calc dx - 1
  8829  b73f aa                 	tax
  8830  b740 a5fd               	lda dx+1
  8831  b742 e900               	sbc #0
  8832  b744 a8                 	tay
  8833  b745 8a                 	txa
  8834  b746 18                 	clc
  8835  b747 65f8               	adc x0				; calc x + dx
  8836  b749 aa                 	tax
  8837  b74a 98                 	tya
  8838  b74b 65f9               	adc x0+1
  8839  b74d c5f7               	cmp sizex+1
  8840  b74f b079               	bcs Verror3			; hi too large -> error
  8841                          ; calc upper left y, check dy
  8842  b751 a5f2               	lda y0
  8843  b753 18                 	clc
  8844  b754 6901               	adc #1				; calc y1 = y + 1 - dy
  8845  b756 38                 	sec				;         = y - (dy - 1)
  8846  b757 e5f5               	sbc dy
  8847  b759 906f               	bcc Verror3			; < 0 -> error
  8848  b75b 85f3               	sta y1
  8849                          
  8850  b75d a9208d01dca9918d...	+VdpCommand zero, zero, zero, x0, x0+1, y1, dx, dx+1, dy, color, zero, HMMV
  8851  b7c7 4c84ff             	jmp waitcmd			; wait for command execution
  8852                          ; -------------------------------------------------------------------------------------------------
  8853                          ; illegal quantity error
  8854  b7ca 4c189b             Verror3:jmp fcerr			; -> illegal quantity error
  8855  b7cd 4c0e97             Verrors:jmp snerr			; -> syntax error
  8856                          ; -------------------------------------------------------------------------------------------------
  8857                          ; copy image to x, y from address, bank (size dx, dy of image in first two bytes)
  8858                          ; only in mode 7 available!
  8859                          VDPImage:
  8860  b7d0 24ea               	bit mode
  8861  b7d2 10f9               	bpl Verrors			; in mode 6 invalid -> syntax error
  8862                          	
  8863  b7d4 2014bf             	jsr Getbyte			; get byte parameter
  8864  b7d7 85f8               	sta x0				; store x
  8865                          ; y
  8866  b7d9 20ea96             	jsr chkcom			; check comma
  8867  b7dc 2014bf             	jsr Getbyte			; get next byte
  8868  b7df c9d4               	cmp #SIZEY			; > ymax ?
  8869  b7e1 b0e7               	bcs Verror3			; ..too large
  8870  b7e3 85f2               	sta y0				; store y
  8871                          ; address
  8872  b7e5 20ea96             	jsr chkcom
  8873  b7e8 202bbf             	jsr Getint
  8874  b7eb a573               	lda intl
  8875  b7ed 85c1               	sta source_pointer		; store source address
  8876  b7ef a572               	lda inth
  8877  b7f1 85c2               	sta source_pointer+1
  8878                          ; bank
  8879  b7f3 20ea96             	jsr chkcom
  8880  b7f6 2014bf             	jsr Getbyte			; get byte
  8881  b7f9 c910               	cmp #mxbank
  8882  b7fb b0cd               	bcs Verror3			; bank > max bank -> error
  8883  b7fd 85f1               	sta temp2			; remember
  8884                          
  8885  b7ff ad40de             	lda via2+prb			; get MMU reg
  8886  b802 290f               	and #%00001111			; isolate RAM0 bank
  8887  b804 85f0               	sta temp1			; remember
  8888  b806 a9f0               	lda #%11110000			; clear RAM0 bank bits# 0-3
  8889  b808 2d40de             	and via2+prb
  8890  b80b 05f1               	ora temp2
  8891  b80d 8d40de             	sta via2+prb 			; set RAM bank
  8892                          
  8893  b810 a000               imglogo:ldy #0				; x counter
  8894  b812 84fd               	sty dx+1			; clear dx high
  8895  b814 b1c1               	lda (source_pointer),y		; load size x
  8896  b816 85fc               	sta dx
  8897  b818 d004               	bne vimgdy
  8898  b81a a901               	lda #$01
  8899  b81c 85fd               	sta dx+1
  8900  b81e c8                 vimgdy:	iny
  8901  b81f b1c1               	lda (source_pointer),y		; load size y
  8902                          ; calc y1
  8903  b821 38                 	sec
  8904  b822 e901               	sbc #1				; y1 = img size y - 1 + y
  8905  b824 18                 	clc
  8906  b825 65f2               	adc y0
  8907  b827 b0a1               	bcs Verror3			; >255 -> error
  8908  b829 c9d4               	cmp #SIZEY
  8909  b82b b09d               	bcs Verror3			; too large -> error
  8910  b82d 85f3               	sta y1
  8911                          
  8912  b82f a5c1               	lda source_pointer
  8913  b831 18                 	clc
  8914  b832 6902               	adc #2				; add 2 for first data byte
  8915  b834 85c1               	sta source_pointer
  8916  b836 a5c2               	lda source_pointer+1
  8917  b838 6900               	adc #0
  8918  b83a 85c2               	sta source_pointer+1
  8919                          ; calc vram address
  8920  b83c a5f2               vimgylp:lda y0
  8921  b83e 29c0               	and #$c0			; isolate bit 6+7 (16k bank)
  8922  b840 c5eb               	cmp lastvbank			; same bank like last time ?
  8923  b842 f00d               	beq vimgadr			; ..yes -> skip set bank
  8924  b844 85eb               	sta lastvbank			; remember bank
  8925                          ; set bank
  8926  b846 0a                 	asl				; address bits 14+15 -> bit 0+1
  8927  b847 2a                 	rol
  8928  b848 2a                 	rol
  8929  b849 8d01dca98e8d01dc   	+VdpSetReg 14			; set VRAM bank
  8930                          ; set address
  8931  b851 a4cf               vimgadr:ldy color
  8932  b853 a5f2               	lda y0				; get y again
  8933  b855 293f               	and #$3f			; remove VRAM address bit 14+15
  8934  b857 a6f8               	ldx x0
  8935                          	+VdpWait WAIT23,16
  8936  b859 8e01dc09408d01dc   	+VdpWriteAddress
  8937  b861 eaeaeaeaea         	+VdpWait WAITVRAM1,10
  8938                          
  8939  b866 a000               	ldy #0				; x counter
  8940  b868 b1c1               vimglp:	lda (source_pointer),y		; load data byte
  8941  b86a 8d00dc             	sta VDPRamWrite			; write byte to VRAM
  8942  b86d c8                 	iny
  8943  b86e c4fc               	cpy dx				; dx reached ?
  8944  b870 eaea               	+VdpWait WAITVRAM,16
  8945  b872 d0f4               	bne vimglp			; ..no -> next byte
  8946                          
  8947  b874 a4f2               	ldy y0
  8948  b876 c4f3               	cpy y1				; last line reached ?
  8949  b878 f013               	beq vimgx			; ..yes -> exit
  8950                          
  8951  b87a c8                 	iny				; next y
  8952  b87b 84f2               	sty y0
  8953  b87d a5c1               	lda source_pointer
  8954  b87f 18                 	clc
  8955  b880 65fc               	adc dx				; add dx for next source line
  8956  b882 85c1               	sta source_pointer
  8957  b884 a5c2               	lda source_pointer+1
  8958  b886 65fd               	adc dx+1
  8959  b888 85c2               	sta source_pointer+1
  8960  b88a 4c3cb8             	jmp vimgylp			; next line
  8961                          
  8962                          vimgx:	
  8963  b88d a9f0               	lda #%11110000			; clear RAM0 bank bits# 0-3
  8964  b88f 2d40de             	and via2+prb
  8965  b892 05f0               	ora temp1
  8966  b894 8d40de             	sta via2+prb 			; restore RAM bank
  8967  b897 60                 	rts
  8968                          ; -------------------------------------------------------------------------------------------------
  8969                          ; test(x) function returns pixel color (set y with SET)
  8970                          VDPTest:
  8971  b898 202ebf             	jsr facint			; fac to integer
  8972  b89b a572               	lda inth
  8973  b89d c5f7               	cmp sizex+1
  8974  b89f b04e               	bcs Verror4			; hi too large -> error
  8975  b8a1 85f9               	sta x0+1
  8976  b8a3 a573               	lda intl
  8977  b8a5 85f8               	sta x0				; store x
  8978                          ; read vram
  8979  b8a7 a5f2               	lda y0
  8980  b8a9 29c0               	and #$c0			; isolate bit 6+7 (16k bank)
  8981  b8ab c5eb               	cmp lastvbank			; same bank like last line ?
  8982  b8ad f00d               	beq vtadr			; ..yes -> skip set bank
  8983  b8af 85eb               	sta lastvbank			; remember bank
  8984                          ; set bank
  8985  b8b1 0a                 	asl				; address bits 14+15 -> bit 0+1
  8986  b8b2 2a                 	rol
  8987  b8b3 2a                 	rol
  8988  b8b4 8d01dca98e8d01dc   	+VdpSetReg 14			; set VRAM bank
  8989                          ; set address
  8990  b8bc a5f2               vtadr:	lda y0				; get y again
  8991  b8be 293f               	and #$3f			; remove VRAM address bit 14+15
  8992  b8c0 aa                 	tax
  8993  b8c1 a5f8               	lda x0
  8994  b8c3 24ea               	bit mode
  8995  b8c5 3003               	bmi +				; skip in mode 7
  8996  b8c7 46f9               	lsr x0+1			; mode6: shift x right because two pixels in a byte
  8997  b8c9 6a                 	ror
  8998                          +	+VdpWait WAIT23,19-1
  8999  b8ca 8d01dc             	sta VDPControl			; write address bits 0-7
  9000  b8cd ea                 	+VdpWait WAIT12,3-1	
  9001  b8ce 8e01dc             	stx VDPControl
  9002  b8d1 eaeaeaeaeaeaeaea...	+VdpWait WAITVRAM1,3-1
  9003  b8da ac80dc             	ldy VDPRamRead
  9004  b8dd 24ea                	bit mode
  9005  b8df 300d                	bmi vtx				; skip in mode 7
  9006                          ; get mode6 pixel color
  9007  b8e1 a5f8                	lda x0
  9008  b8e3 4a                  	lsr				; x bit#0 in carry
  9009  b8e4 98                  	tya				; color in a
  9010  b8e5 b004                	bcs vtm6			; right pixel -> skip
  9011  b8e7 4a                  	lsr				; shift left pixel to lo nibble
  9012  b8e8 4a                  	lsr
  9013  b8e9 4a                  	lsr
  9014  b8ea 4a                  	lsr
  9015  b8eb 290f               vtm6:	and #$0f			; clear upper nibble
  9016  b8ed a8                 	tay
  9017  b8ee 60                 vtx:	rts				; function return color in y
  9018                          ; -------------------------------------------------------------------------------------------------
  9019                          ; illegal quantity error
  9020  b8ef 4c189b             Verror4:jmp fcerr			; -> illegal quantity error
  9021                          ; -------------------------------------------------------------------------------------------------
  9022                          ; circle at x, y with radius r
  9023                          ; x1,y1 = centre, intl = radius, cy = alt. radius, temp2,4 calculated add/sub values (for opt. x2)
  9024                          ; x0,y0 calculated values for SetPixel
  9025                          VDPCircle:
  9026  b8f2 202bbf             	jsr Getint			; get 16bit parameter
  9027  b8f5 a572               	lda inth
  9028  b8f7 c5f7               	cmp sizex+1
  9029  b8f9 b0f4               	bcs Verror4			; hi too large -> error
  9030  b8fb 85fb               	sta x1+1
  9031  b8fd a573               	lda intl
  9032  b8ff 85fa               	sta x1				; store x1
  9033                          ; y
  9034  b901 20ea96             	jsr chkcom			; check comma
  9035  b904 2014bf             	jsr Getbyte			; get next byte
  9036  b907 c9d4               	cmp #SIZEY			; > ymax ?
  9037  b909 b0e4               	bcs Verror4			; ..too large
  9038  b90b 85f3               	sta y1				; store y1
  9039                          ; r
  9040  b90d 20ea96             	jsr chkcom			; check comma
  9041  b910 2014bf             	jsr Getbyte			; get byte
  9042                          ; calc x+r
  9043  b913 24ea               	bit mode			; check mode
  9044  b915 3001               	bmi +				; skip mode 7
  9045  b917 0a                 	asl				; double r for x check in mode 6
  9046  b918 85f1               +	sta temp2			; remember check radius for active mode
  9047  b91a 18                 	clc				; r already in a
  9048  b91b 65fa               	adc x1
  9049  b91d 85f8               	sta x0
  9050  b91f a5fb               	lda x1+1
  9051  b921 6900               	adc #0
  9052                          ; check > xmax
  9053  b923 c5f7               	cmp sizex+1			; check high
  9054  b925 9008               	bcc vcirxok			; ..smaller max -> ok
  9055  b927 d0c6               	bne Verror4			; ..too large -> error
  9056  b929 a5f8               	lda x0
  9057  b92b c5f6               	cmp sizex			; check low
  9058  b92d b0c0               	bcs Verror4			; ..too large
  9059                          ; calc x-r + check < 0
  9060  b92f a5fa               vcirxok:lda x1				; calc x - r
  9061  b931 38                 	sec
  9062  b932 e5f1               	sbc temp2			; check radius
  9063  b934 a5fb               	lda x1+1
  9064  b936 e900               	sbc #0
  9065  b938 30b5               	bmi Verror4			; negative -> error
  9066                          ; calc y+r
  9067  b93a a5f3               	lda y1				; calc y + r
  9068  b93c 18                 	clc
  9069  b93d 6573               	adc intl			; intl = r
  9070  b93f c9d4               	cmp #SIZEY
  9071  b941 b0ac               	bcs Verror4			; ..too large
  9072                          ; calc y-r + check < 0
  9073  b943 a5f3               vciryok:lda y1				; calc y - r
  9074  b945 38                 	sec
  9075  b946 e573               	sbc intl			; intl = r
  9076  b948 90a5               	bcc Verror4			; negative -> error
  9077                          
  9078  b94a a900               	lda #0
  9079  b94c 85f4               	sta cy
  9080  b94e a573               	lda intl
  9081  b950 85fc               	sta tx
  9082                          vcirlp:
  9083                          ; calc add/sub values for opt. mode 6 double x-radius
  9084  b952 a573               	lda intl
  9085  b954 a6f4               	ldx cy
  9086  b956 24ea               	bit mode			; check mode
  9087  b958 3006               	bmi +				; skip mode 7
  9088                          ; mode 6 x values *2
  9089  b95a 0a                 	asl				; x *2
  9090  b95b a8                 	tay
  9091  b95c 8a                 	txa
  9092  b95d 0a                 	asl				; y *2
  9093  b95e aa                 	tax
  9094  b95f 98                 	tya
  9095  b960 85f1               +	sta temp2			; add/sub value for x
  9096  b962 86f5               	stx temp4			; add/sub value for x
  9097                          ; dot 1
  9098  b964 a5fa               	lda x1
  9099  b966 18                 	clc
  9100  b967 65f1               	adc temp2			; add radius
  9101  b969 85f8               	sta x0
  9102  b96b a5fb               	lda x1+1
  9103  b96d 6900               	adc #0
  9104  b96f 85f9               	sta x0+1
  9105  b971 a5f3               	lda y1
  9106  b973 18                 	clc
  9107  b974 65f4               	adc cy				; add y
  9108  b976 85f2               	sta y0
  9109  b978 20b7bd             	jsr SetPixel			; calc pixel position
  9110                          ; dot 2
  9111  b97b a5f3               	lda y1
  9112  b97d 38                 	sec
  9113  b97e e5f4               	sbc cy				; sub y
  9114  b980 85f2               	sta y0
  9115  b982 20b7bd             	jsr SetPixel			; calc pixel position
  9116                          ; dot 3
  9117  b985 a5fa               	lda x1
  9118  b987 38                 	sec
  9119  b988 e5f1               	sbc temp2			; sub radius
  9120  b98a 85f8               	sta x0
  9121  b98c a5fb               	lda x1+1
  9122  b98e e900               	sbc #0
  9123  b990 85f9               	sta x0+1
  9124  b992 20b7bd             	jsr SetPixel			; calc pixel position
  9125                          ; dot 4
  9126  b995 a5f3               	lda y1
  9127  b997 18                 	clc
  9128  b998 65f4               	adc cy				; add y
  9129  b99a 85f2               	sta y0
  9130  b99c 20b7bd             	jsr SetPixel			; calc pixel position
  9131                          ; dot 5
  9132  b99f a5fa               	lda x1
  9133  b9a1 18                 	clc
  9134  b9a2 65f5               	adc temp4			; add y
  9135  b9a4 85f8               	sta x0
  9136  b9a6 a5fb               	lda x1+1
  9137  b9a8 6900               	adc #0
  9138  b9aa 85f9               	sta x0+1
  9139  b9ac a5f3               	lda y1
  9140  b9ae 18                 	clc
  9141  b9af 6573               	adc intl			; add radius
  9142  b9b1 85f2               	sta y0
  9143  b9b3 20b7bd             	jsr SetPixel			; calc pixel position
  9144                          ; dot 6
  9145  b9b6 a5f3               	lda y1
  9146  b9b8 38                 	sec
  9147  b9b9 e573               	sbc intl			; sub radius
  9148  b9bb 85f2               	sta y0
  9149  b9bd 20b7bd             	jsr SetPixel			; calc pixel position
  9150                          ; dot 7
  9151  b9c0 a5fa               	lda x1
  9152  b9c2 38                 	sec
  9153  b9c3 e5f5               	sbc temp4			; sub y
  9154  b9c5 85f8               	sta x0
  9155  b9c7 a5fb               	lda x1+1
  9156  b9c9 e900               	sbc #0
  9157  b9cb 85f9               	sta x0+1
  9158  b9cd 20b7bd             	jsr SetPixel			; calc pixel position
  9159                          ; dot 8
  9160  b9d0 a5f3               	lda y1
  9161  b9d2 18                 	clc
  9162  b9d3 6573               	adc intl			; add radius
  9163  b9d5 85f2               	sta y0
  9164  b9d7 20b7bd             	jsr SetPixel			; calc pixel position
  9165                          
  9166  b9da a6f4               	ldx cy
  9167  b9dc e8                 	inx				; y = y+1
  9168  b9dd 86f4               	stx cy
  9169                          ; finished ?
  9170  b9df a573               	lda intl
  9171  b9e1 c5f4               	cmp cy
  9172  b9e3 901d               	bcc vcirx			; radius < y+1 -> end
  9173                          
  9174  b9e5 a5fc               	lda tx
  9175  b9e7 c5f4               	cmp cy				; tx < y ?
  9176  b9e9 b00f               	bcs vcirtxy			; ..no -> tx = tx - y
  9177                          
  9178  b9eb c673               	dec intl			; intl = intl-1
  9179  b9ed a573               	lda intl
  9180  b9ef 18                 	clc
  9181  b9f0 65fc               	adc tx
  9182  b9f2 38                 	sec
  9183  b9f3 e5f4               	sbc cy
  9184  b9f5 85fc               	sta tx
  9185  b9f7 4c52b9             	jmp vcirlp			; next dots
  9186                          
  9187  b9fa 38                 vcirtxy:sec
  9188  b9fb e5f4               	sbc cy				; tx = tx - y
  9189  b9fd 85fc               	sta tx
  9190  b9ff 4c52b9             	jmp vcirlp			; next dots
  9191                          
  9192  ba02 a5fa               vcirx:	lda x1				; resture centre
  9193  ba04 85f8               	sta x0
  9194  ba06 a5fb               	lda x1+1
  9195  ba08 85f9               	sta x0+1
  9196  ba0a a5f3               	lda y1
  9197  ba0c 85f2               	sta y0
  9198  ba0e 60                 	rts
  9199                          ; -------------------------------------------------------------------------------------------------
  9200                          ; illegal quantity error
  9201  ba0f 4c189b             Verror5:jmp fcerr			; -> illegal quantity error
  9202                          ; -------------------------------------------------------------------------------------------------
  9203                          ; SPRITE n,p,f set sprite n=0-31 to pattern p=0-63 (incl. sprite_colors, flags f= bit#5-7) 
  9204                          VDPSprite:
  9205  ba12 2014bf             	jsr Getbyte			; get byte parameter
  9206  ba15 c920               	cmp #SPRITES
  9207  ba17 b0f6               	bcs Verror5			; >sprites -> error
  9208  ba19 85f0               	sta temp1			; remember
  9209                          
  9210  ba1b 20ea96             	jsr chkcom
  9211  ba1e 2014bf             	jsr Getbyte			; get byte parameter
  9212  ba21 c940               	cmp #PATTERNS
  9213  ba23 b0ea               	bcs Verror5			; >patterns -> error
  9214  ba25 85f1               	sta temp2			; remember
  9215                          
  9216  ba27 20ea96             	jsr chkcom
  9217  ba2a 2014bf             	jsr Getbyte			; get next byte
  9218  ba2d 29e0               	and #$e0			; isolate bit#5-7
  9219  ba2f 85f4               	sta temp3
  9220                          
  9221  ba31 24eb1002700ea903...	+VdpSpriteBank			; switch to sprite bank
  9222                          ; set color table pointer to new pattern for the sprite
  9223  ba45 a5f1               	lda temp2			; get pattern no
  9224  ba47 0a                 	asl				; *8 for color table position
  9225  ba48 0a                 	asl
  9226  ba49 85f1               	sta temp2			; store pattern no *4 for 16x16 pattern
  9227  ba4b 0a                 	asl 
  9228  ba4c 26c2               	rol source_pointer+1		; carry to hi bit#0
  9229  ba4e 18                 	clc
  9230  ba4f 65fe               	adc sprite_colors		; add color table base lo
  9231  ba51 85c1               	sta source_pointer		; store color pointer lo
  9232  ba53 a5c2               	lda source_pointer+1
  9233  ba55 2901               	and #$01			; clear color pointer hi except bit #0
  9234  ba57 65ff               	adc sprite_colors+1		; add color table base hi
  9235  ba59 85c2               	sta source_pointer+1		; store color pointer hi
  9236                          ; set VRAM color table pointer to first pattern
  9237  ba5b a900               	lda #$00
  9238  ba5d 85c4               	sta pointer1+1			; clear VRAM color hi
  9239  ba5f a6f0               	ldx temp1			; get sprite no
  9240  ba61 a5f4               	lda temp3
  9241  ba63 9d6103             	sta sprite_flags,x
  9242  ba66 8a                 	txa
  9243  ba67 0a                 	asl				; *16 for color table position
  9244  ba68 0a                 	asl
  9245  ba69 0a                 	asl 
  9246  ba6a 0a                 	asl
  9247  ba6b 26c4               	rol pointer1+1
  9248                          ; set VRAM address
  9249  ba6d 8d01dc             	sta VDPControl			; store color table adr lo
  9250  ba70 a5c4               	lda pointer1+1
  9251  ba72 0978               	ora #(>SpriteColorTable&$3e)|$40; add color table base bit#9-13  +bit#6 for write VRAM
  9252                          	+VdpWait WAIT12,8
  9253  ba74 8d01dc             	sta VDPControl
  9254                          	+VdpWait WAITVRAM1,33-1
  9255                          ; set color+flags
  9256  ba77 a000               	ldy #0				; clear source counter
  9257  ba79 b1c1               sprlp:	lda (source_pointer),y
  9258  ba7b aa                 	tax				; remember
  9259  ba7c 4a                 	lsr				; upper nibble color to bit#0-3
  9260  ba7d 4a                 	lsr
  9261  ba7e 4a                 	lsr
  9262  ba7f 4a                 	lsr
  9263  ba80 05f4               	ora temp3			; add flags
  9264  ba82 8d00dc             	sta VDPRamWrite
  9265  ba85 8a                 	txa
  9266  ba86 290f               	and #$0f			; isolate low nibble color
  9267  ba88 05f4               	ora temp3			; add flags
  9268  ba8a eaeaeaeaea         	+VdpWait WAITVRAM,10
  9269  ba8f 8d00dc             	sta VDPRamWrite
  9270                          	+VdpWait WAITVRAM,28
  9271  ba92 c8                 	iny
  9272  ba93 c008               	cpy #8				; finished ?
  9273  ba95 d0e2               	bne sprlp			; ..no -> next byte
  9274                          ; store new pattern no for sprite n
  9275  ba97 a5f0               	lda temp1			; get no.
  9276  ba99 0a                 	asl				; 4 attribute bytes each sprite
  9277  ba9a 0a                 	asl
  9278  ba9b 18                 	clc
  9279  ba9c 6902               	adc #2				; add 2 for pattern pos. in table
  9280                          	+VdpWait WAIT23,20
  9281  ba9e 8d01dc             	sta VDPControl
  9282  baa1 a97a               	lda #(>SpriteAttributeTable&$3f)|$40	; bit#8-13 attribute table + bit#6 for write VRAM
  9283                          	+VdpWait WAIT12,5-1
  9284  baa3 8d01dc             	sta VDPControl
  9285                          
  9286  baa6 a5f1               	lda temp2			; pattern no. *4
  9287  baa8 eaeaeaea           	+VdpWait WAITVRAM1,13-1
  9288  baac 8d00dc             	sta VDPRamWrite			; store new pattern no
  9289  baaf 60                 	rts
  9290                          ; -------------------------------------------------------------------------------------------------
  9291                          ; illegal quantity error
  9292  bab0 4c189b             Verror6:jmp fcerr			; -> illegal quantity error
  9293                          ; -------------------------------------------------------------------------------------------------
  9294                          ; SCOLOR mode6: set platte color / mode7: set sprite color
  9295                          VDPSColor:
  9296  bab3 24ea               	bit mode			; check mode
  9297  bab5 1003               	bpl +				; mode 6 -> skip
  9298  bab7 4c02bb             	jmp VDPSpriteColor		; mode7 -> sprite color
  9299                          ; SCOLOR n,r,g,b set palette color n to red, green, blue (each 0-7)
  9300  baba 2014bf             +	jsr Getbyte			; get byte parameter
  9301  babd c910               	cmp #COLORS6
  9302  babf b0ef               	bcs Verror6			; >colors -> error
  9303  bac1 85f0               	sta temp1			; remember color no.
  9304                          ; red
  9305  bac3 20ea96             	jsr chkcom
  9306  bac6 2014bf             	jsr Getbyte
  9307  bac9 c908               	cmp #8
  9308  bacb b0e3               	bcs Verror6			; >7 -> error
  9309  bacd 0a                 	asl				; shift to high nibble
  9310  bace 0a                 	asl
  9311  bacf 0a                 	asl
  9312  bad0 0a                 	asl
  9313  bad1 85f1               	sta temp2			; remember red
  9314                          ; green
  9315  bad3 20ea96             	jsr chkcom
  9316  bad6 2014bf             	jsr Getbyte			; get byte parameter
  9317  bad9 c908               	cmp #8
  9318  badb b0d3               	bcs Verror6			; >7 -> error
  9319  badd 85f4               	sta temp3			; remember green
  9320                          ; blue
  9321  badf 20ea96             	jsr chkcom
  9322  bae2 2014bf             	jsr Getbyte
  9323  bae5 c908               	cmp #8
  9324  bae7 b0c7               	bcs Verror6			; >7 -> error
  9325  bae9 05f1               	ora temp2			; or red to high nibble
  9326  baeb a8                 	tay				; remember in y
  9327                          ; write color to vdp
  9328  baec a5f0               	lda temp1
  9329  baee 8d01dca9908d01dc   	+VdpSetReg 16			; select pallete no
  9330  baf6 eaeaea             	+VdpWait WAIT23,3-1 
  9331  baf9 8c02dc             	sty VDPPalette			; store blue+red
  9332  bafc a5f4               	lda temp3			; get green	
  9333                          	+VdpWait WAIT12,6
  9334  bafe 8d02dc             	sta VDPPalette			; store blue+red
  9335  bb01 60                 	rts
  9336                          
  9337                          ; SCOLOR n,c set uni color sprite n=0-31 with color c + sprite_flags 
  9338                          VDPSpriteColor:
  9339  bb02 2014bf             	jsr Getbyte			; get byte parameter
  9340  bb05 c920               	cmp #SPRITES
  9341  bb07 b0a7               	bcs Verror6			; >sprites -> error
  9342  bb09 85f0               	sta temp1			; remember
  9343                          
  9344  bb0b 20ea96             	jsr chkcom
  9345  bb0e 2014bf             	jsr Getbyte			; get byte
  9346  bb11 c910               	cmp #16
  9347  bb13 b09b               	bcs Verror6			; color > 15 -> error
  9348                          
  9349  bb15 a6f0               	ldx temp1
  9350  bb17 1d6103             	ora sprite_flags,x
  9351  bb1a a8                 	tay				; remember color+flags
  9352                          
  9353  bb1b 24eb1002700ea903...	+VdpSpriteBank			; switch to sprite bank
  9354                          ; set VRAM color table pointer to first pattern
  9355  bb2f a900               	lda #$00
  9356  bb31 85c4               	sta pointer1+1			; clear VRAM color hi
  9357  bb33 a5f0               	lda temp1			; get sprite no
  9358  bb35 0a                 	asl				; *16 for color table position
  9359  bb36 0a                 	asl
  9360  bb37 0a                 	asl 
  9361  bb38 0a                 	asl
  9362  bb39 26c4               	rol pointer1+1
  9363                          ; set VRAM address
  9364  bb3b 8d01dc             	sta VDPControl			; store color table adr lo
  9365  bb3e a5c4               	lda pointer1+1
  9366  bb40 0978               	ora #(>SpriteColorTable&$3e)|$40; add color table base bit#9-13  +bit#6 for write VRAM
  9367                          	+VdpWait WAIT12,8
  9368  bb42 8d01dc             	sta VDPControl
  9369                          
  9370  bb45 eaeaeaeaeaeaeaea   	+VdpWait WAITVRAM1,5-1
  9371                          ; set color+flags
  9372  bb4d a210               	ldx #16				; 16 color lines
  9373  bb4f 8c00dc             scollp:	sty VDPRamWrite
  9374  bb52 eaeaeaeaeaea       	+VdpWait WAITVRAM,8
  9375  bb58 ca                 	dex				; color lines finished ?
  9376  bb59 d0f4               	bne scollp			; ..no -> next byte
  9377                          
  9378  bb5b 60                 	rts
  9379                          ; -------------------------------------------------------------------------------------------------
  9380                          ; SPOS n,x,y move sprite n=0-31 to x,y position 
  9381                          VDPSpritePos:
  9382  bb5c 2014bf             	jsr Getbyte			; get byte parameter
  9383  bb5f c920               	cmp #SPRITES
  9384  bb61 b04b               	bcs Verror7			; >sprites -> error
  9385  bb63 85f0               	sta temp1			; remember
  9386                          ; x
  9387  bb65 20ea96             	jsr chkcom			; check comma
  9388  bb68 2014bf             	jsr Getbyte			; get byte
  9389  bb6b 85fa               	sta x1				; remember x
  9390                          ; y
  9391  bb6d 20ea96             	jsr chkcom			; check comma
  9392  bb70 2014bf             	jsr Getbyte			; get next byte
  9393  bb73 85f3               	sta y1
  9394                          
  9395  bb75 24eb1002700ea903...	+VdpSpriteBank			; switch to sprite bank
  9396  bb89 a5f0               	lda temp1			; get no.
  9397  bb8b 0a                 	asl				; 4 attribute bytes each sprite
  9398  bb8c 0a                 	asl
  9399                          	+VdpWait WAIT23,17-1		; (5 cycles in VdpSpriteBank)
  9400  bb8d 8d01dc             	sta VDPControl
  9401  bb90 a97a               	lda #(>SpriteAttributeTable&$3f)|$40	; bit#8-13 attribute table + bit#6 for write VRAM
  9402                          	+VdpWait WAIT12,5-1
  9403  bb92 8d01dc             	sta VDPControl
  9404                          
  9405  bb95 a5f3               	lda y1
  9406  bb97 eaeaeaeaeaeaea     	+VdpWait WAITVRAM1,6
  9407  bb9e 8d00dc             	sta VDPRamWrite
  9408  bba1 a5fa               	lda x1
  9409  bba3 eaeaeaeaeaeaea     	+VdpWait WAITVRAM,6
  9410  bbaa 8d00dc             	sta VDPRamWrite
  9411  bbad 60                 	rts
  9412                          ; -------------------------------------------------------------------------------------------------
  9413                          ; illegal quantity error
  9414  bbae 4c189b             Verror7:jmp fcerr			; -> illegal quantity error
  9415                          ; -------------------------------------------------------------------------------------------------
  9416                          ; SDATA p,cnt,adr,b copy cnt=1-64 x 40 bytes to patterntable, sprite_colors=0-63 from address, bank 
  9417                          VDPSpriteData:
  9418  bbb1 2014bf             	jsr Getbyte			; get byte parameter
  9419  bbb4 c940               	cmp #PATTERNS
  9420  bbb6 b0f6               	bcs Verror7			; >patterns -> error
  9421  bbb8 85f0               	sta temp1			; remember
  9422                          ; count
  9423  bbba 20ea96             	jsr chkcom			; check comma
  9424  bbbd 2014bf             	jsr Getbyte			; get byte
  9425  bbc0 f0ec               	beq Verror7			; 0 not allowed -> error
  9426  bbc2 85f4               	sta temp3			; store pattern counter
  9427  bbc4 18                 	clc
  9428  bbc5 65f0               	adc temp1
  9429  bbc7 b0e5               	bcs Verror7			; >patterns -> error
  9430                          ; address
  9431  bbc9 20ea96             	jsr chkcom			; check comma
  9432  bbcc 202bbf             	jsr Getint			; get 16bit int
  9433  bbcf a573               	lda intl
  9434  bbd1 85c1               	sta source_pointer		; set pointer to address
  9435  bbd3 a572               	lda inth
  9436  bbd5 85c2               	sta source_pointer+1
  9437                          ; bank
  9438  bbd7 20ea96             	jsr chkcom
  9439  bbda 2014bf             	jsr Getbyte			; get byte
  9440  bbdd c910               	cmp #mxbank
  9441  bbdf b0cd               	bcs Verror7			; bank > max bank -> error
  9442  bbe1 85f1               	sta temp2
  9443                          
  9444  bbe3 24eb1002700ea903...	+VdpSpriteBank			; switch to sprite bank
  9445                          ; set color table pointer to first pattern
  9446  bbf7 a5f0               	lda temp1			; get start pattern
  9447  bbf9 0a                 	asl				; *8 for color table position
  9448  bbfa 0a                 	asl
  9449  bbfb 0a                 	asl 
  9450  bbfc 85f0               	sta temp1			; pattern address lo
  9451  bbfe 26c4               	rol pointer1+1			; carry to hi bit#0
  9452  bc00 18                 	clc
  9453  bc01 65fe               	adc sprite_colors		; add color table base lo
  9454  bc03 85c3               	sta pointer1			; store color pointer lo
  9455  bc05 a5c4               	lda pointer1+1			; get hi
  9456  bc07 2901               	and #$01			; clear color pointer hi except bit #0
  9457  bc09 aa                 	tax				; remember
  9458  bc0a 65ff               	adc sprite_colors+1		; add color table base hi
  9459  bc0c 85c4               	sta pointer1+1			; store color pointer hi
  9460                          ; calc pattern table address
  9461  bc0e 8a                 	txa
  9462  bc0f 06f0               	asl temp1			; *4 (*32 total) for pattern start address in VRAM
  9463  bc11 2a                 	rol
  9464  bc12 06f0               	asl temp1
  9465  bc14 2a                 	rol
  9466  bc15 0970               	ora #(>SpritePatternTable&$3f)|$40 	; add pattern table base bit#8-13 +bit#6 for write VRAM
  9467  bc17 aa                 	tax				; pattern address hi
  9468                          ; set VRAM address
  9469  bc18 a5f0               	lda temp1			; get pattern table adr lo
  9470  bc1a 8d01dc             	sta VDPControl
  9471                          ; switch to source bank while waiting for VDP
  9472  bc1d ad40de             	lda via2+prb			; get MMU reg
  9473  bc20 290f               	and #%00001111			; isolate RAM0 bank
  9474  bc22 85f5               	sta temp4			; remember
  9475  bc24 a9f0               	lda #%11110000			; clear RAM0 bank bits# 0-3
  9476  bc26 2d40de             	and via2+prb
  9477  bc29 05f1               	ora temp2
  9478  bc2b 8d40de             	sta via2+prb 			; set RAM bank
  9479                          
  9480                          	+VdpWait WAIT12,15-1
  9481  bc2e 8e01dc             	stx VDPControl
  9482                          
  9483  bc31 eaeaeaea           	+VdpWait WAITVRAM1,12
  9484                          ; copy pattern
  9485  bc35 a000               sdcpylp:ldy #0
  9486  bc37 b1c1               sdpatlp:lda (source_pointer),y		; get source byte
  9487  bc39 c8                 	iny
  9488  bc3a 8d00dc             	sta VDPRamWrite
  9489  bc3d eaeaea             	+VdpWait WAITVRAM,15-1
  9490  bc40 c020               	cpy #SPRX/8*SPRY		; pattern finished ?
  9491  bc42 d0f3               	bne sdpatlp			; ..no -> next byte
  9492                          ; copy colors
  9493  bc44 a5c1               	lda source_pointer
  9494  bc46 18                 	clc
  9495  bc47 6920               	adc #(SPRX/8*SPRY)		; set to source color data
  9496  bc49 85c1               	sta source_pointer
  9497  bc4b a5c2               	lda source_pointer+1
  9498  bc4d 6900               	adc #0
  9499  bc4f 85c2               	sta source_pointer+1
  9500                          
  9501  bc51 a000               	ldy #0
  9502  bc53 b1c1               sdcollp:lda (source_pointer),y		; get source byte
  9503  bc55 aa                 	tax				; remember data
  9504  bc56 a9f0               	lda #%11110000			; clear RAM0 bank bits# 0-3
  9505  bc58 2d40de             	and via2+prb
  9506  bc5b 8d40de             	sta via2+prb 			; set RAM0 bank for sprite color data
  9507  bc5e 8a                 	txa
  9508  bc5f 91c3               	sta (pointer1),y		; store to color table 
  9509  bc61 a9f0               	lda #%11110000
  9510  bc63 2d40de             	and via2+prb
  9511  bc66 05f1               	ora temp2
  9512  bc68 8d40de             	sta via2+prb 			; set source RAM bank
  9513  bc6b c8                 	iny
  9514  bc6c c008               	cpy #8				; 8 color-bytes (16 nibbles) finished ?
  9515  bc6e d0e3               	bne sdcollp			; ..no -> next byte
  9516                          
  9517  bc70 a5c1               	lda source_pointer
  9518  bc72 18                 	clc
  9519  bc73 6908               	adc #8				; next source pattern
  9520  bc75 85c1               	sta source_pointer
  9521  bc77 a5c2               	lda source_pointer+1
  9522  bc79 6900               	adc #0
  9523  bc7b 85c2               	sta source_pointer+1
  9524                          
  9525  bc7d a5c3               	lda pointer1
  9526  bc7f 18                 	clc
  9527  bc80 6908               	adc #8				; next color table entry
  9528  bc82 85c3               	sta pointer1
  9529  bc84 a5c4               	lda pointer1+1
  9530  bc86 6900               	adc #0
  9531  bc88 85c4               	sta pointer1+1
  9532                          
  9533  bc8a c6f4               	dec temp3			; dec pattern counter
  9534  bc8c d0a7               	bne sdcpylp			; copy next pattern
  9535                          
  9536  bc8e a9f0               	lda #%11110000			; clear RAM0 bank bits# 0-3
  9537  bc90 2d40de             	and via2+prb
  9538  bc93 05f5               	ora temp4
  9539  bc95 8d40de             	sta via2+prb 			; restore RAM bank
  9540  bc98 60                 	rts
  9541                          ; -------------------------------------------------------------------------------------------------
  9542                          ; set userfont datasource to address
  9543                          VDPUserfont:
  9544  bc99 202bbf             	jsr Getint
  9545  bc9c a573               	lda intl
  9546  bc9e 8d8d03             	sta userfont_adr		; store userfont address
  9547  bca1 a572               	lda inth
  9548  bca3 8d8e03             	sta userfont_adr+1
  9549  bca6 60                 	rts
  9550                          ; -------------------------------------------------------------------------------------------------
  9551                          ; illegal quantity error
  9552  bca7 4c189b             Verror8:jmp fcerr			; -> illegal quantity error
  9553                          ; -------------------------------------------------------------------------------------------------
  9554                          ; copy screen data from x,y size dx, dy to x1,y1 (dx, dy > 0) (mode 6 only even x size used!)
  9555                          VDPCopy:
  9556  bcaa 202bbf             	jsr Getint			; get 16bit parameter
  9557  bcad a572               	lda inth
  9558  bcaf c5f7               	cmp sizex+1
  9559  bcb1 b0f4               	bcs Verror8			; hi too large -> error
  9560  bcb3 85f9               	sta x0+1
  9561  bcb5 a573               	lda intl
  9562  bcb7 85f8               	sta x0				; store x
  9563                          ; y
  9564  bcb9 20ea96             	jsr chkcom			; check comma
  9565  bcbc 2014bf             	jsr Getbyte			; get next byte
  9566  bcbf c9d4               	cmp #SIZEY			; > ymax ?
  9567  bcc1 b0e4               	bcs Verror8			; ..too large
  9568  bcc3 85f2               	sta y0				; store y
  9569                          ; dx
  9570  bcc5 20ea96             	jsr chkcom
  9571  bcc8 202bbf              	jsr Getint			; get 16bit parameter
  9572  bccb a572               	lda inth
  9573  bccd 18                 	clc
  9574  bcce 6573               	adc intl
  9575  bcd0 f0d5               	beq Verror8			; 0 not allowed -> error
  9576  bcd2 a572               	lda inth
  9577                          
  9578  bcd4 85fd               	sta dx+1
  9579  bcd6 c5f7               	cmp sizex+1
  9580  bcd8 900a               	bcc vcpdxok			; hi < sizex hi-> ok
  9581  bcda d0cb               	bne Verror8			; hi..too large -> error
  9582  bcdc a573               	lda intl
  9583  bcde c5f6               	cmp sizex			; check lo
  9584  bce0 9002               	bcc vcpdxok			; lo < -> ok
  9585  bce2 d0c3               	bne Verror8			; lo..too large -> error
  9586  bce4 a573               vcpdxok:lda intl
  9587  bce6 85fc               	sta dx
  9588                          ; dy
  9589  bce8 20ea96             	jsr chkcom
  9590  bceb 2014bf             	jsr Getbyte			; get next byte
  9591  bcee f0b7               	beq Verror8			; 0 not allowed -> error
  9592  bcf0 c9d5               	cmp #SIZEY+1
  9593  bcf2 b0b3               	bcs Verror8			; ..too large
  9594  bcf4 85f5               	sta dy
  9595                          ; x1
  9596  bcf6 20ea96             	jsr chkcom
  9597  bcf9 202bbf             	jsr Getint			; get 16bit parameter
  9598  bcfc a572               	lda inth
  9599  bcfe c5f7               	cmp sizex+1
  9600  bd00 b0a5               	bcs Verror8			; hi too large -> error
  9601  bd02 85fb               	sta x1+1
  9602  bd04 a573               	lda intl
  9603  bd06 85fa               	sta x1				; store x1
  9604                          ; y
  9605  bd08 20ea96             	jsr chkcom			; check comma
  9606  bd0b 2014bf             	jsr Getbyte			; get next byte
  9607  bd0e c9d4               	cmp #SIZEY			; > ymax ?
  9608  bd10 b095               fferra:	bcs Verror8			; ..too large
  9609  bd12 85f3               	sta y1				; store y1
  9610                          ; check x0+dx
  9611  bd14 a5fc               	lda dx
  9612  bd16 38                 	sec
  9613  bd17 e901               	sbc #1				; calc dx - 1
  9614  bd19 aa                 	tax				; remember
  9615  bd1a a5fd               	lda dx+1
  9616  bd1c e900               	sbc #0
  9617  bd1e a8                 	tay				; remember dx hi
  9618  bd1f 8a                 	txa				; get dx lo
  9619  bd20 18                 	clc
  9620  bd21 65f8               	adc x0				; calc x + dx
  9621  bd23 98                 	tya				; get hi
  9622  bd24 65f9               	adc x0+1
  9623  bd26 c5f7               	cmp sizex+1
  9624  bd28 b0e6               	bcs fferra			; hi too large -> error
  9625                          ; check x1+dx
  9626  bd2a 8a                 	txa
  9627  bd2b 18                 	clc
  9628  bd2c 65fa               	adc x1				; calc x1 + dx
  9629  bd2e 98                 	tya
  9630  bd2f 65fb               	adc x1+1
  9631  bd31 c5f7               	cmp sizex+1
  9632  bd33 b0db               	bcs fferra			; hi too large -> error
  9633                          ; check y0+dy
  9634  bd35 a5f5               	lda dy
  9635  bd37 38                 	sec
  9636  bd38 e901               	sbc #1				; calc dy - 1
  9637  bd3a aa                 	tax
  9638  bd3b 18                 	clc
  9639  bd3c 65f2               	adc y0				; calc y + dy
  9640  bd3e c9d4               	cmp #SIZEY			; > ymax ?
  9641  bd40 b0ce               	bcs fferra			; too large -> error
  9642                          ; check y1+dy
  9643  bd42 8a                 	txa
  9644  bd43 18                 	clc
  9645  bd44 65f3               	adc y1				; calc y1 + dy
  9646  bd46 c9d4               	cmp #SIZEY			; > ymax ?
  9647  bd48 b0c6               	bcs fferra			; too large -> error
  9648                          
  9649  bd4a a9208d01dca9918d...	+VdpCommand x0, x0+1, y0, x1, x1+1, y1, dx, dx+1, dy, zero, zero, HMMM
  9650  bdb4 4c84ff             	jmp waitcmd		; wait for command execution
  9651                          ; -------------------------------------------------------------------------------------------------
  9652                          ; set pixel x, y (preserves x, y / no validity check)
  9653                          ;   subroutine for Dot and Circle
  9654                          ;   checks if same vram bank like last time and skips bank setting for more speed
  9655                          SetPixel:
  9656  bdb7 a5f2               	lda y0
  9657  bdb9 29c0               	and #$c0			; isolate bit 6+7 (16k bank)
  9658  bdbb c5eb               	cmp lastvbank			; same bank like last time ?
  9659  bdbd f00d               	beq spchkm			; ..yes -> skip set bank
  9660  bdbf 85eb               	sta lastvbank			; remember bank
  9661                          ; set bank
  9662  bdc1 0a                 	asl				; address bits 14+15 -> bit 0+1
  9663  bdc2 2a                 	rol
  9664  bdc3 2a                 	rol
  9665  bdc4 8d01dca98e8d01dc   	+VdpSetReg 14			; set VRAM bank
  9666                          ; check mode
  9667  bdcc 24ea               spchkm:	bit mode
  9668  bdce 101b               	bpl spmode6			; -> set pixel mode 6
  9669                          ; mode 7: set address+set pixel
  9670  bdd0 a5f2               	lda y0				; get y again
  9671  bdd2 293f               	and #$3f			; remove VRAM address bit 14+15
  9672  bdd4 a6f8               	ldx x0
  9673                          	+VdpWait WAIT23,17-1
  9674  bdd6 8e01dc09408d01dc   	+VdpWriteAddress
  9675  bdde a5cf               	lda color
  9676  bde0 eaeaeaeaeaeaea     	+VdpWait WAITVRAM1,6
  9677  bde7 8d00dc             	sta VDPRamWrite
  9678  bdea 60                 	rts
  9679                          ; mode 6 read byte from VRAM
  9680  bdeb a5f9               spmode6:lda x0+1
  9681  bded 4a                 	lsr				; mode6: shift x right because two pixels in a byte
  9682  bdee a5f8               	lda x0
  9683  bdf0 6a                 	ror
  9684  bdf1 aa                 	tax				; remember x/2
  9685                          	+VdpWait WAIT23,21-1
  9686  bdf2 8d01dc             	sta VDPControl			; write address bits 0-7
  9687  bdf5 a5f2               	lda y0				; get y again
  9688  bdf7 293f               	and #$3f			; remove VRAM address bit 14+15, bit#6=0 read
  9689                          	+VdpWait WAIT12,8	
  9690  bdf9 8d01dc             	sta VDPControl
  9691                          
  9692  bdfc a5f8               	lda x0
  9693  bdfe 4a                  	lsr				; x bit#0 in carry
  9694  bdff eaeaeaeaeaea       	+VdpWait WAITVRAM1,8
  9695  be05 ad80dc             	lda VDPRamRead			; get byte
  9696  be08 b00e                 	bcs sppix1			; -> right pixel
  9697                          ; left pixel
  9698  be0a 290f               	and #$0f			;  clear left nibble	
  9699  be0c 85f0               	sta temp1
  9700  be0e a5cf                	lda color
  9701  be10 0a                  	asl				; shift color to hi nibble for left pixel
  9702  be11 0a                  	asl
  9703  be12 0a                  	asl
  9704  be13 0a                  	asl
  9705  be14 05f0               	ora temp1			; add old right pixel
  9706  be16 9004               	bcc spsetm6			; always (asl shifts hi nibble color=0 -> carry)
  9707                          ; right pixel
  9708  be18 29f0               sppix1: and #$f0			; clear right nibble
  9709  be1a 05cf               	ora color			; add new pixel to lo nibble
  9710                          ; write new byte
  9711  be1c a8                 spsetm6	tay				; new byte in y
  9712  be1d a5f2               	lda y0				; get y again
  9713  be1f 293f               	and #$3f			; remove VRAM address bit 14+15
  9714                          	+VdpWait WAIT23,18
  9715  be21 8e01dc09408d01dc   	+VdpWriteAddress
  9716  be29 eaeaeaeaeaeaeaea...	+VdpWait WAITVRAM1,3-1
  9717  be32 8c00dc             	sty VDPRamWrite
  9718  be35 60                 	rts
  9719                          ; -------------------------------------------------------------------------------------------------
  9720                          ; draw line from x, y to x1, y1 (x, y is set to target, no validity check)
  9721                          ;   subroutine for line, draw,..
  9722                          DrawLine:
  9723  be36 a200               	ldx #$00			; clear VDP LINE command  arg
  9724  be38 a5f3               	lda y1				; save target
  9725  be3a 48                 	pha
  9726  be3b a5fa               	lda x1
  9727  be3d 48                 	pha
  9728  be3e a5fb               	lda x1+1
  9729  be40 48                 	pha
  9730                          ; check x1 < x0 ?
  9731  be41 c5f9               	cmp x0+1
  9732  be43 9008               	bcc dlxchg			; x1 hi < x0 hi -> exchange
  9733  be45 d01e               	bne dlchky			; x1 hi > x0 hi -> skip
  9734  be47 a5fa               	lda x1				; hi equal - compare lo
  9735  be49 c5f8               	cmp x0
  9736  be4b b018               	bcs dlchky			; x1 >= x0 -> skip
  9737                          ; x1 < x0 exchange points
  9738  be4d a4fb               dlxchg:	ldy x1+1			; exchang x1 - x0
  9739  be4f a5f9               	lda x0+1
  9740  be51 85fb               	sta x1+1
  9741  be53 84f9               	sty x0+1
  9742  be55 a4fa               	ldy x1
  9743  be57 a5f8               	lda x0
  9744  be59 85fa               	sta x1
  9745  be5b 84f8               	sty x0
  9746  be5d a4f3               	ldy y1
  9747  be5f a5f2               	lda y0
  9748  be61 85f3               	sta y1
  9749  be63 84f2               	sty y0
  9750                          ; check y1 < y0 and calc dy
  9751  be65 a5f3               dlchky:	lda y1				; check y1 < y0
  9752  be67 c5f2               	cmp y0
  9753  be69 b00b               	bcs dldy			; y1 >= y0 -> skip
  9754                          ; calc dy backwards
  9755  be6b a5f2               	lda y0
  9756  be6d 38                 	sec
  9757  be6e e5f3               	sbc y1				; dy = y0 - y1
  9758  be70 85f5               	sta dy
  9759  be72 a208               	ldx #$08			; set VDP LINE command -y flag
  9760  be74 d007               	bne dldx			; skip alway
  9761                          ; calc dy
  9762  be76 a5f3               dldy:	lda y1
  9763  be78 38                 	sec
  9764  be79 e5f2               	sbc y0				; dy = y1 - y0
  9765  be7b 85f5               	sta dy
  9766                          ; calc dx
  9767  be7d a5fa               dldx:	lda x1
  9768  be7f 38                 	sec
  9769  be80 e5f8               	sbc x0				; dx = x1 - x0
  9770  be82 85fc               	sta dx
  9771  be84 a5fb               	lda x1+1
  9772  be86 e5f9               	sbc x0+1
  9773  be88 85fd               	sta dx+1
  9774                          ; check dx > dy (longer cathete)
  9775  be8a d00e               	bne dlcmd			; dx hi > 0 -> >dy -> skip 
  9776  be8c a5fc               	lda dx				; dx hi = 0: compare lo bytes
  9777  be8e c5f5               	cmp dy
  9778  be90 b008               	bcs dlcmd			; dx >= dy -> skip
  9779                          ; dy > dx 
  9780  be92 e8                 	inx				; set flag VDP LINE command longer cathete flag 
  9781  be93 a8                 	tay
  9782  be94 a5f5               	lda dy				; exchange dx - dy
  9783  be96 85fc               	sta dx
  9784  be98 84f5               	sty dy
  9785                          
  9786  be9a 8e8c03             dlcmd:	stx arg				; store command arg
  9787                          
  9788  be9d a9208d01dca9918d...	+VdpCommand zero, zero, zero, x0, x0+1, y0, dx, dx+1, dy, color, arg, LINE
  9789                          	
  9790  bf08 68                 	pla				; restore target
  9791  bf09 85f9               	sta x0+1
  9792  bf0b 68                 	pla
  9793  bf0c 85f8               	sta x0
  9794  bf0e 68                 	pla
  9795  bf0f 85f2               	sta y0
  9796  bf11 4c84ff             	jmp waitcmd			; wait for command execution
  9797                          ; -------------------------------------------------------------------------------------------------
  9798                          ; basic4+ 16bit parameter to intl, inth (faclo, facmo)
  9799                          ;   returns only lo byte in a
  9800  bf14 2097ae             Getbyte:jsr frmnum			; evaluate the formula
  9801  bf17 a574               	lda facsgn
  9802  bf19 3021               	bmi Verror9			; negative -> error
  9803  bf1b a56f               	lda facexp
  9804  bf1d c991               	cmp #145
  9805  bf1f b01b               	bcs Verror9			; too big -> error
  9806  bf21 2099a1             	jsr qint
  9807  bf24 a572               	lda inth
  9808  bf26 d014               	bne Verror9			; ..too large -> error
  9809  bf28 a573               	lda intl
  9810  bf2a 60                 	rts
  9811                          ; -------------------------------------------------------------------------------------------------
  9812                          ; basic4+ 16bit parameter to intl, inth (faclo, facmo)
  9813  bf2b 2097ae             Getint:	jsr frmnum			; evaluate the formula
  9814  bf2e a574               facint:	lda facsgn
  9815  bf30 300a               	bmi Verror9			; negative -> error
  9816  bf32 a56f               	lda facexp
  9817  bf34 c991               	cmp #145
  9818  bf36 b004               	bcs Verror9			; too big -> error
  9819  bf38 2099a1             	jsr qint
  9820  bf3b 60                 	rts
  9821                          ; -------------------------------------------------------------------------------------------------
  9822  bf3c 4c189b             Verror9:jmp fcerr
  9823                          ; -------------------------------------------------------------------------------------------------
  9824                          ; vdp statement dispatch table (startaddress -1)
  9825                          ; reslst
  9826                          VdpStmdsp:
  9827  bf3f 3bbf               	!byte <(Verror9-1), >(Verror9-1)		; $e9
  9828  bf41 8ab5               	!byte <(VDPMode-1), >(VDPMode-1)		; $ea
  9829  bf43 b0b5               	!byte <(VDPColor-1), >(VDPColor-1)		; $eb
  9830  bf45 beb5               	!byte <(VDPClear-1), >(VDPClear-1)		; $ec
  9831  bf47 e1b5               	!byte <(VDPDot-1), >(VDPDot-1)			; $ed
  9832  bf49 1eb6               	!byte <(VDPLine-1), >(VDPLine-1)		; $ee
  9833  bf4b 02b6               	!byte <(VDPSet-1), >(VDPSet-1)			; $ef
  9834  bf4d 3cb6               	!byte <(VDPDraw-1), >(VDPDraw-1)		; $f0
  9835  bf4f 5ab6               	!byte <(VDPFrame-1), >(VDPFrame-1)		; $f1
  9836  bf51 edb6               	!byte <(VDPBlock-1), >(VDPBlock-1)		; $f2
  9837  bf53 cfb7               	!byte <(VDPImage-1), >(VDPImage-1)		; $f3
  9838  bf55 97b8               	!byte <(VDPTest-1), >(VDPTest-1)		; $f4
  9839  bf57 f1b8               	!byte <(VDPCircle-1), >(VDPCircle-1)		; $f5
  9840  bf59 11ba               	!byte <(VDPSprite-1), >(VDPSprite-1)		; $f6
  9841  bf5b b0bb               	!byte <(VDPSpriteData-1), >(VDPSpriteData-1)	; $f7
  9842  bf5d 5bbb               	!byte <(VDPSpritePos-1), >(VDPSpritePos-1)	; $f8
  9843  bf5f 3bbf               	!byte <(Verror9-1), >(Verror9-1)		; $f9
  9844  bf61 98bc               	!byte <(VDPUserfont-1), >(VDPUserfont-1)	; $fa
  9845  bf63 3bbf               	!byte <(Verror9-1), >(Verror9-1)		; $fb
  9846  bf65 3bbf               	!byte <(Verror9-1), >(Verror9-1)		; $fc
  9847  bf67 b2ba               	!byte <(VDPSColor-1), >(VDPSColor-1)		; $fd
  9848  bf69 a9bc               	!byte <(VDPCopy-1), >(VDPCopy-1)		; $fe
  9849                          VdpStmdspEnd:
  9850                          ; -------------------------------------------------------------------------------------------------
  9851                          ; vdp statements (vdp reslst)
  9852                          Vdplst:					; upper left of screen is 0, 0
  9853                          TKVDP = $e9				; 16 colors from palette / 8bit color %RRRGGGBB
  9854  bf6b 494e49d4           	!scr "INI", $d4		; INIT			init graphics extension
  9855  bf6f 4d4f44c5           	!scr "MOD", $c5		; MODE g,c		g=0/1 on/off +2=PAL +4=Mode7, +8 YJK (only mode 7), frame color
  9856  bf73 434f4c4fd2         	!scr "COLO", $d2	; COLOR c		select draw/text color
  9857  bf78 434c4541d2         	!scr "CLEA", $d2	; CLEAR c		clear screen with backgroundcolor
  9858  bf7d 444fd4             	!scr "DO", $d4		; DOT x,y		set pixel x,y
  9859  bf80 4c494ec5           	!scr "LIN", $c5		; LINE x,y,x1,y1	line from x,y to x1,y1
  9860  bf84 5345d4             	!scr "SE", $d4		; SET x,y		set cursor to x,y
  9861  bf87 445241d7           	!scr "DRA", $d7		; DRAW x1,y1		draw line to x1,y1
  9862  bf8b 4652414dc5         	!scr "FRAM", $c5	; FRAME x,y,x1,y1	frame x,y=lower left, x1,y1=upper right
  9863  bf90 424c4f43cb         	!scr "BLOC", $cb	; BLOCK x,y,dx,dy	block x,y=lower left, size dx,dy (min. 1)
  9864  bf95 494d4147c5         	!scr "IMAG", $c5	; IMAGE x,y,adr,b	copy image (byte 0+1=dx,dy) from adr,bnk to x,y (only mode 6)
  9865                          TKTEST = $f4
  9866  bf9a 544553d4           	!scr "TES", $d4		; TEST(x)		function test returns pixel color (y with SET)
  9867  bf9e 434952434cc5       	!scr "CIRCL", $c5	; CIRCLE x,y,r		circle at x,y with radius r (x doubled in mode 6)
  9868  bfa4 5350524954c5       	!scr "SPRIT", $c5	; SPRITE n,p,f		sprite n=0-31, pattern p=0-63, flags f= bit#5-7 
  9869  bfaa 53444154c1         	!scr "SDAT", $c1	; SDATA p,cnt,adr,b	copy cnt=1-64 x 40 bytes to p=0-63 from adr, bank 
  9870  bfaf 53504fd3           	!scr "SPO", $d3		; SPOS n,x,y		move sprite n=0-31 to x, y pos. (0=upper left) 
  9871  bfb3 565052494ed4       	!scr "VPRIN", $d4	; VPRINT x,y,""		print with userfont to x, y	 
  9872  bfb9 55534552464f4ed4   	!scr "USERFON", $d4	; USERFONT adr		set userfont to adr=address
  9873  bfc1 555052494ed4       	!scr "UPRIN", $d4	; UPRINT ""		print with userfont to cursor pos 
  9874  bfc7 55504fd3           	!scr "UPO", $d3		; UPOS r,c		set uprint cursor to row, column
  9875  bfcb 53434f4c4fd2       	!scr "SCOLO", $d2	; SCOLOR n, c	mode6:	set palette color 0-15, color 0-15
  9876                          				;		mode7:	set uni color sprite n=0-31 with color c+flags 
  9877  bfd1 56434f50d9         	!scr "VCOP", $d9	; SCOPY x,y,dx,dy,x1,y1	copy screen data from x,y size dx,dy to x1,y1 
  9878  bfd6 01                 	!byte $01		; end of vdp reserved word list
  9879                          ; -------------------------------------------------------------------------------------------------
  9880                          ; interface jump vectors.
  9881                          *=vecorg 	; $ff6f kernal jump vector table
  9882                          vreset	*=*+3		; Power-on/off vector reset
  9883                          vmode	*=*+3		; VDP: set mode
  9884                          pgmkey	*=*+3		; Function key vector
  9885                          vclear	*=*+3		; VDP: clear screen with background color
  9886                          ioinit	*=*+3		; i/o initialization
  9887                          cint	*=*+3		; screen initialization
  9888                          alloc	*=*+3		; allocate routine
  9889                          waitcmd	*=*+3		; VDP: Wait for VDP command
  9890                          krestr	*=*+3		; restore i/o vectors
  9891                          lkupsa	*=*+3		; secondary to physical map
  9892                          lkupla	*=*+3		; logical to physical map
  9893                          setmsg	*=*+3		; control os messages
  9894                          second	*=*+3		; send sa after listen
  9895                          tksa	*=*+3		; send sa after talk
  9896                          topmem	*=*+3		; read/set top of memory
  9897                          membot	*=*+3		; read/set bottom of memory
  9898                          kscnky	*=*+3		; scan keyboard
  9899                          ksetmo	*=*+3		; set timeout in iec
  9900                          acptr	*=*+3		; hand shake iec byte in
  9901                          ciout	*=*+3		; hand shake iec byte out
  9902                          untlk	*=*+3		; send untalk out
  9903                          unlsn	*=*+3		; send unlisten out
  9904                          listn	*=*+3		; send listen out
  9905                          talk	*=*+3		; send talk out
  9906                          
  9907                          krdst	*=*+3		; return i/o status byte
  9908                          setlfs	*=*+3		; set la, fa and sa
  9909                          setnam	*=*+3		; set length and filename adr
  9910                          kopen	*=*+3		; open logical file
  9911                          kclose	*=*+3		; close  -      -
  9912                          kchkin	*=*+3		; open channel in
  9913                          kchout	*=*+3		; open   -     out
  9914                          
  9915                          clrch	*=*+3		; close i/o channel
  9916                          kbasin	*=*+3		; input from  -
  9917                          kbsout	*=*+3		; output -    -
  9918                          kload	*=*+3		; load from file
  9919                          ksave	*=*+3		; save to    -
  9920                          settim	*=*+3		; set internal clock
  9921                          rdtim	*=*+3		; read   -      -
  9922                          kstop	*=*+3		; scan stop key (break)
  9923                          kgetin	*=*+3		; get char from queue
  9924                          kclall	*=*+3		; close all files
  9925                          udtim	*=*+3		; increment clock
  9926                          scrorg	*=*+3		; return screen origin
  9927                          plot	*=*+3		; read/set .x,.y coords
  9928                          doscmd	*=*+3		; dos command
  9929                          ; -------------------------------------------------------------------------------------------------
  9930                          *=$bfff
